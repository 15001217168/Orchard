/*
** NOTE: This file is generated by Gulp and should not be edited directly!
** Any changes made directly to this file will be overwritten next time its asset group is processed by Gulp.
*/

/* http://keith-wood.name/calendars.html
   Calendars date picker for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	var pluginName = 'calendarsPicker';


	/** Create the calendars datepicker plugin.
		<p>Sets an input field to popup a calendar for date entry,
			or a <code>div</code> or <code>span</code> to show an inline calendar.</p>
		<p>Expects HTML like:</p>
		<pre>&lt;input type="text"> or &lt;div>&lt;/div></pre>
		<p>Provide inline configuration like:</p>
		<pre>&lt;input type="text" data-calendarsPicker="name: 'value'"/></pre>
	 	@class CalendarsPicker
		@augments JQPlugin
		@example $(selector).calendarsPicker()
 $(selector).calendarsPicker({minDate: 0, maxDate: '+1m +1w'}) */
	$.JQPlugin.createPlugin({
	
		/** The name of the plugin.
			@memberof CalendarsPicker */
		name: pluginName,
		
		/** Default template for generating a datepicker.
			Insert anywhere:
			<ul>
			<li>'{l10n:name}' to insert localised value for name,</li>
			<li>'{link:name}' to insert a link trigger for command name,</li>
			<li>'{button:name}' to insert a button trigger for command name,</li>
			<li>'{popup:start}...{popup:end}' to mark a section for inclusion in a popup datepicker only,</li>
			<li>'{inline:start}...{inline:end}' to mark a section for inclusion in an inline datepicker only.</li>
			</ul>
			@memberof CalendarsPicker
			@property picker {string} Overall structure: '{months}' to insert calendar months.
			@property monthRow {string} One row of months: '{months}' to insert calendar months.
			@property month {string} A single month: '{monthHeader<em>:dateFormat</em>}' to insert the month header -
						<em>dateFormat</em> is optional and defaults to 'MM yyyy',
						'{weekHeader}' to insert a week header, '{weeks}' to insert the month's weeks.
			@property weekHeader {string} A week header: '{days}' to insert individual day names.
			@property dayHeader {string} Individual day header: '{day}' to insert day name.
			@property week {string} One week of the month: '{days}' to insert the week's days,
						'{weekOfYear}' to insert week of year.
			@property day {string} An individual day: '{day}' to insert day value.
			@property monthSelector {string} jQuery selector, relative to picker, for a single month.
			@property daySelector {string} jQuery selector, relative to picker, for individual days.
			@property rtlClass {string} Class for right-to-left (RTL) languages.
			@property multiClass {string} Class for multi-month datepickers.
			@property defaultClass {string} Class for selectable dates.
			@property selectedClass {string} Class for currently selected dates.
			@property highlightedClass {string} Class for highlighted dates.
			@property todayClass {string} Class for today.
			@property otherMonthClass {string} Class for days from other months.
			@property weekendClass {string} Class for days on weekends.
			@property commandClass {string} Class prefix for commands.
			@property commandButtonClass {string} Extra class(es) for commands that are buttons.
			@property commandLinkClass {string} Extra class(es) for commands that are links.
			@property disabledClass {string} Class for disabled commands. */
		defaultRenderer: {
			picker: '<div class="calendars">' +
			'<div class="calendars-nav">{link:prev}{link:today}{link:next}</div>{months}' +
			'{popup:start}<div class="calendars-ctrl">{link:clear}{link:close}</div>{popup:end}' +
			'<div class="calendars-clear-fix"></div></div>',
			monthRow: '<div class="calendars-month-row">{months}</div>',
			month: '<div class="calendars-month"><div class="calendars-month-header">{monthHeader}</div>' +
			'<table><thead>{weekHeader}</thead><tbody>{weeks}</tbody></table></div>',
			weekHeader: '<tr>{days}</tr>',
			dayHeader: '<th>{day}</th>',
			week: '<tr>{days}</tr>',
			day: '<td>{day}</td>',
			monthSelector: '.calendars-month',
			daySelector: 'td',
			rtlClass: 'calendars-rtl',
			multiClass: 'calendars-multi',
			defaultClass: '',
			selectedClass: 'calendars-selected',
			highlightedClass: 'calendars-highlight',
			todayClass: 'calendars-today',
			otherMonthClass: 'calendars-other-month',
			weekendClass: 'calendars-weekend',
			commandClass: 'calendars-cmd',
			commandButtonClass: '',
			commandLinkClass: '',
			disabledClass: 'calendars-disabled'
		},
	
		/** Command actions that may be added to a layout by name.
			<ul>
			<li>prev - Show the previous month (based on <code>monthsToStep</code> option) - <em>PageUp</em></li>
			<li>prevJump - Show the previous year (based on <code>monthsToJump</code> option) - <em>Ctrl+PageUp</em></li>
			<li>next - Show the next month (based on <code>monthsToStep</code> option) - <em>PageDown</em></li>
			<li>nextJump - Show the next year (based on <code>monthsToJump</code> option) - <em>Ctrl+PageDown</em></li>
			<li>current - Show the currently selected month or today's if none selected - <em>Ctrl+Home</em></li>
			<li>today - Show today's month - <em>Ctrl+Home</em></li>
			<li>clear - Erase the date and close the datepicker popup - <em>Ctrl+End</em></li>
			<li>close - Close the datepicker popup - <em>Esc</em></li>
			<li>prevWeek - Move the cursor to the previous week - <em>Ctrl+Up</em></li>
			<li>prevDay - Move the cursor to the previous day - <em>Ctrl+Left</em></li>
			<li>nextDay - Move the cursor to the next day - <em>Ctrl+Right</em></li>
			<li>nextWeek - Move the cursor to the next week - <em>Ctrl+Down</em></li>
			</ul>
			The command name is the key name and is used to add the command to a layout
			with '{button:name}' or '{link:name}'. Each has the following attributes.
			@memberof CalendarsPicker
			@property text {string} The field in the regional settings for the displayed text.
			@property status {string} The field in the regional settings for the status text.
			@property keystroke {object} The keystroke to trigger the action, with attributes:
				<code>keyCode</code> {number} the code for the keystroke,
				<code>ctrlKey</code> {boolean} <code>true</code> if <em>Ctrl</em> is required,
				<code>altKey</code> {boolean} <code>true</code> if <em>Alt</em> is required,
				<code>shiftKey</code> {boolean} <code>true</code> if <em>Shift</em> is required.
			@property enabled {CalendarsPickerCommandEnabled} The function that indicates the command is enabled.
			@property date {CalendarsPickerCommandDate} The function to get the date associated with this action.
			@property action {CalendarsPickerCommandAction} The function that implements the action. */
		commands: {
			prev: {text: 'prevText', status: 'prevStatus', // Previous month
				keystroke: {keyCode: 33}, // Page up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(1 - inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).add(-1, 'd').compareTo(minDate) !== -1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(-inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, -inst.options.monthsToStep); }
			},
			prevJump: {text: 'prevJumpText', status: 'prevJumpStatus', // Previous year
				keystroke: {keyCode: 33, ctrlKey: true}, // Ctrl + Page up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(1 - inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).add(-1, 'd').compareTo(minDate) !== -1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(-inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, -inst.options.monthsToJump); }
			},
			next: {text: 'nextText', status: 'nextStatus', // Next month
				keystroke: {keyCode: 34}, // Page down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).compareTo(maxDate) !== +1); },
				date: function(inst) {
					return inst.drawDate.newDate().
						add(inst.options.monthsToStep - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, inst.options.monthsToStep); }
			},
			nextJump: {text: 'nextJumpText', status: 'nextJumpStatus', // Next year
				keystroke: {keyCode: 34, ctrlKey: true}, // Ctrl + Page down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay).compareTo(maxDate) !== +1);	},
				date: function(inst) {
					return inst.drawDate.newDate().
						add(inst.options.monthsToJump - inst.options.monthsOffset, 'm').
						day(inst.options.calendar.minDay); },
				action: function(inst) {
					plugin.changeMonth(this, inst.options.monthsToJump); }
			},
			current: {text: 'currentText', status: 'currentStatus', // Current month
				keystroke: {keyCode: 36, ctrlKey: true}, // Ctrl + Home
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					var maxDate = inst.get('maxDate');
					var curDate = inst.selectedDates[0] || inst.options.calendar.today();
					return (!minDate || curDate.compareTo(minDate) !== -1) &&
						(!maxDate || curDate.compareTo(maxDate) !== +1); },
				date: function(inst) {
					return inst.selectedDates[0] || inst.options.calendar.today(); },
				action: function(inst) {
					var curDate = inst.selectedDates[0] || inst.options.calendar.today();
					plugin.showMonth(this, curDate.year(), curDate.month()); }
			},
			today: {text: 'todayText', status: 'todayStatus', // Today's month
				keystroke: {keyCode: 36, ctrlKey: true}, // Ctrl + Home
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					var maxDate = inst.get('maxDate');
					return (!minDate || inst.options.calendar.today().compareTo(minDate) !== -1) &&
						(!maxDate || inst.options.calendar.today().compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.options.calendar.today(); },
				action: function(inst) { plugin.showMonth(this); }
			},
			clear: {text: 'clearText', status: 'clearStatus', // Clear the datepicker
				keystroke: {keyCode: 35, ctrlKey: true}, // Ctrl + End
				enabled: function(inst) { return true; },
				date: function(inst) { return null; },
				action: function(inst) { plugin.clear(this); }
			},
			close: {text: 'closeText', status: 'closeStatus', // Close the datepicker
				keystroke: {keyCode: 27}, // Escape
				enabled: function(inst) { return true; },
				date: function(inst) { return null; },
				action: function(inst) { plugin.hide(this); }
			},
			prevWeek: {text: 'prevWeekText', status: 'prevWeekStatus', // Previous week
				keystroke: {keyCode: 38, ctrlKey: true}, // Ctrl + Up
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().
						add(-inst.options.calendar.daysInWeek(), 'd').compareTo(minDate) !== -1); },
				date: function(inst) { return inst.drawDate.newDate().
					add(-inst.options.calendar.daysInWeek(), 'd'); },
				action: function(inst) { plugin.changeDay(this, -inst.options.calendar.daysInWeek()); }
			},
			prevDay: {text: 'prevDayText', status: 'prevDayStatus', // Previous day
				keystroke: {keyCode: 37, ctrlKey: true}, // Ctrl + Left
				enabled: function(inst) {
					var minDate = inst.curMinDate();
					return (!minDate || inst.drawDate.newDate().add(-1, 'd').
						compareTo(minDate) !== -1); },
				date: function(inst) { return inst.drawDate.newDate().add(-1, 'd'); },
				action: function(inst) { plugin.changeDay(this, -1); }
			},
			nextDay: {text: 'nextDayText', status: 'nextDayStatus', // Next day
				keystroke: {keyCode: 39, ctrlKey: true}, // Ctrl + Right
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().add(1, 'd').
						compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.drawDate.newDate().add(1, 'd'); },
				action: function(inst) { plugin.changeDay(this, 1); }
			},
			nextWeek: {text: 'nextWeekText', status: 'nextWeekStatus', // Next week
				keystroke: {keyCode: 40, ctrlKey: true}, // Ctrl + Down
				enabled: function(inst) {
					var maxDate = inst.get('maxDate');
					return (!maxDate || inst.drawDate.newDate().
						add(inst.options.calendar.daysInWeek(), 'd').compareTo(maxDate) !== +1); },
				date: function(inst) { return inst.drawDate.newDate().
					add(inst.options.calendar.daysInWeek(), 'd'); },
				action: function(inst) { plugin.changeDay(this, inst.options.calendar.daysInWeek()); }
			}
		},

		/** Determine whether a command is enabled.
			@callback CalendarsPickerCommandEnabled
			@param inst {object} The current instance settings.
			@return {boolean} <code>true</code> if this command is enabled, <code>false</code> if not.
			@example enabled: function(inst) {
	return !!inst.curMinDate();
 } */

		/** Calculate the representative date for a command.
			@callback CalendarsPickerCommandDate
			@param inst {object} The current instance settings.
			@return {CDate} A date appropriate for this command.
			@example date: function(inst) {
	return inst.curMinDate();
 } */

		/** Perform the action for a command.
			@callback CalendarsPickerCommandAction
			@param inst {object} The current instance settings.
			@example date: function(inst) {
	$.datepick.setDate(inst.elem, inst.curMinDate());
 } */

		/** Calculate the week of the year for a date.
			@callback CalendarsPickerCalculateWeek
			@param date {CDate} The date to evaluate.
			@return {number} The week of the year.
			@example calculateWeek: function(date) {
	var startYear = $.calendars.newDate(date.year(), 1, 1);
	return Math.floor((date.dayOfYear() - startYear.dayOfYear()) / 7) + 1;
 } */

		/** Provide information about an individual date shown in the calendar.
			@callback CalendarsPickerOnDate
			@param date {CDate} The date to evaluate.
			@return {object} Information about that date, with the properties above.
			@property selectable {boolean} <code>true</code> if this date can be selected.
			@property dateClass {string} Class(es) to be applied to the date.
			@property content {string} The date cell content.
			@property tooltip {string} A popup tooltip for the date.
			@example onDate: function(date) {
	return {selectable: date.day() > 0 && date.day() &lt; 5,
		dateClass: date.day() === 4 ? 'last-day' : ''};
 } */

		/** Update the datepicker display.
			@callback CalendarsPickerOnShow
			@param picker {jQuery} The datepicker <code>div</code> to be shown.
			@param inst {object} The current instance settings.
			@example onShow: function(picker, inst) {
	picker.append('&lt;button type="button">Hi&lt;/button>').
		find('button:last').click(function() {
			alert('Hi!');
		});
 } */

		/** React to navigating through the months/years.
			@callback CalendarsPickerOnChangeMonthYear
			@param year {number} The new year.
			@param month {number} The new month (1 to 12).
			@example onChangeMonthYear: function(year, month) {
	alert('Now in ' + month + '/' + year);
 } */
			
		/** Datepicker on select callback.
			Triggered when a date is selected.
			@callback CalendarsPickerOnSelect
			@param dates {CDate[]} The selected date(s).
			@example onSelect: function(dates) {
 	alert('Selected ' + dates);
 } */
			
		/** Datepicker on close callback.
			Triggered when a popup calendar is closed.
			@callback CalendarsPickerOnClose
			@param dates {CDate[]} The selected date(s).
			@example onClose: function(dates) {
 	alert('Selected ' + dates);
 } */
		
		/** Default settings for the plugin.
			@memberof CalendarsPicker
			@property [calendar=$.calendars.instance()] {Calendar} The calendar for this datepicker.
			@property [pickerClass=''] {string} CSS class to add to this instance of the datepicker.
			@property [showOnFocus=true] {boolean} <code>true</code> for popup on focus, <code>false</code> for not.
			@property [showTrigger=null] {string|Element|jQuery} Element to be cloned for a trigger, <code>null</code> for none.
			@property [showAnim='show'] {string} Name of jQuery animation for popup, '' for no animation.
			@property [showOptions=null] {object} Options for enhanced animations.
			@property [showSpeed='normal'] {string} Duration of display/closure.
			@property [popupContainer=null] {string|Element|jQuery} The element to which a popup calendar is added, <code>null</code> for body.
			@property [alignment='bottom'] {string} Alignment of popup - with nominated corner of input:
						'top' or 'bottom' aligns depending on language direction,
						'topLeft', 'topRight', 'bottomLeft', 'bottomRight'.
			@property [fixedWeeks=false] {boolean} <code>true</code> to always show 6 weeks, <code>false</code> to only show as many as are needed.
			@property [firstDay=null] {number} First day of the week, 0 = Sunday, 1 = Monday, etc., <code>null</code> for <code>calendar</code> default.
			@property [calculateWeek=null] {CalendarsPickerCalculateWeek} Calculate week of the year from a date, <code>null</code> for <code>calendar</code> default.
			@property [monthsToShow=1] {number|number[]} How many months to show, cols or [rows, cols].
			@property [monthsOffset=0] {number} How many months to offset the primary month by;
						may be a function that takes the date and returns the offset.
			@property [monthsToStep=1] {number} How many months to move when prev/next clicked.
			@property [monthsToJump=12] {number} How many months to move when large prev/next clicked.
			@property [useMouseWheel=true] {boolean} <code>true</code> to use mousewheel if available, <code>false</code> to never use it.
			@property [changeMonth=true] {boolean} <code>true</code> to change month/year via drop-down, <code>false</code> for navigation only.
			@property [yearRange='c-10:c+10'] {string} Range of years to show in drop-down: 'any' for direct text entry
						or 'start:end', where start/end are '+-nn' for relative to today
						or 'c+-nn' for relative to the currently selected date
						or 'nnnn' for an absolute year.
			@property [showOtherMonths=false] {boolean} <code>true</code> to show dates from other months, <code>false</code> to not show them.
			@property [selectOtherMonths=false] {boolean} <code>true</code> to allow selection of dates from other months too.
			@property [defaultDate=null] {string|number|CDate} Date to show if no other selected.
			@property [selectDefaultDate=false] {boolean} <code>true</code> to pre-select the default date if no other is chosen.
			@property [minDate=null] {string|number|CDate} The minimum selectable date.
			@property [maxDate=null] {string|number|CDate} The maximum selectable date.
			@property [dateFormat='mm/dd/yyyy'] {string} Format for dates.
			@property [autoSize=false] {boolean} <code>true</code> to size the input field according to the date format.
			@property [rangeSelect=false] {boolean} Allows for selecting a date range on one date picker.
			@property [rangeSeparator=' - '] {string} Text between two dates in a range.
			@property [multiSelect=0] {number} Maximum number of selectable dates, zero for single select.
			@property [multiSeparator=','] {string} Text between multiple dates.
			@property [onDate=null] {CalendarsPickerOnDate} Callback as a date is added to the datepicker.
			@property [onShow=null] {CalendarsPickerOnShow} Callback just before a datepicker is shown.
			@property [onChangeMonthYear=null] {CalendarsPickerOnChangeMonthYear} Callback when a new month/year is selected.
			@property [onSelect=null] {CalendarsPickerOnSelect} Callback when a date is selected.
			@property [onClose=null] {CalendarsPickerOnClose} Callback when a datepicker is closed.
			@property [altField=null] {string|Element|jQuery} Alternate field to update in synch with the datepicker.
			@property [altFormat=null] {string} Date format for alternate field, defaults to <code>dateFormat</code>.
			@property [constrainInput=true] {boolean} <code>true</code> to constrain typed input to <code>dateFormat</code> allowed characters.
			@property [commandsAsDateFormat=false] {boolean} <code>true</code> to apply
						<code><a href="#formatDate">formatDate</a></code> to the command texts.
			@property [commands=this.commands] {object} Command actions that may be added to a layout by name. */
		defaultOptions: {
			calendar: $.calendars.instance(),
			pickerClass: '',
			showOnFocus: true,
			showTrigger: null,
			showAnim: 'show',
			showOptions: {},
			showSpeed: 'normal',
			popupContainer: null,
			alignment: 'bottom',
			fixedWeeks: false,
			firstDay: null,
			calculateWeek: null,
			monthsToShow: 1,
			monthsOffset: 0,
			monthsToStep: 1,
			monthsToJump: 12,
			useMouseWheel: true,
			changeMonth: true,
			yearRange: 'c-10:c+10',
			showOtherMonths: false,
			selectOtherMonths: false,
			defaultDate: null,
			selectDefaultDate: false,
			minDate: null,
			maxDate: null,
			dateFormat: null,
			autoSize: false,
			rangeSelect: false,
			rangeSeparator: ' - ',
			multiSelect: 0,
			multiSeparator: ',',
			onDate: null,
			onShow: null,
			onChangeMonthYear: null,
			onSelect: null,
			onClose: null,
			altField: null,
			altFormat: null,
			constrainInput: true,
			commandsAsDateFormat: false,
			commands: {} // this.commands
		},

		/** Localisations for the plugin.
			Entries are objects indexed by the language code ('' being the default US/English).
			Each object has the following attributes.
			@memberof CalendarsPicker
			@property [renderer=this.defaultRenderer] {string} The rendering templates.
			@property [prevText='&lt;Prev'] {string} Text for the previous month command.
			@property [prevStatus='Show the previous month'] {string} Status text for the previous month command.
			@property [prevJumpText='&lt;&lt;'] {string} Text for the previous year command.
			@property [prevJumpStatus='Show the previous year'] {string} Status text for the previous year command.
			@property [nextText='Next&gt;'] {string} Text for the next month command.
			@property [nextStatus='Show the next month'] {string} Status text for the next month command.
			@property [nextJumpText='&gt;&gt;'] {string} Text for the next year command.
			@property [nextJumpStatus='Show the next year'] {string} Status text for the next year command.
			@property [currentText='Current'] {string} Text for the current month command.
			@property [currentStatus='Show the current month'] {string} Status text for the current month command.
			@property [todayText='Today'] {string} Text for the today's month command.
			@property [todayStatus='Show today\'s month'] {string} Status text for the today's month command.
			@property [clearText='Clear'] {string} Text for the clear command.
			@property [clearStatus='Clear all the dates'] {string} Status text for the clear command.
			@property [closeText='Close'] {string} Text for the close command.
			@property [closeStatus='Close the datepicker'] {string} Status text for the close command.
			@property [yearStatus='Change the year'] {string} Status text for year selection.
			@property [earlierText='&#160;&#160;▲'] {string} Text for earlier years.
			@property [laterText='&#160;&#160;▼'] {string} Text for later years.
			@property [monthStatus='Change the month'] {string} Status text for month selection.
			@property [weekText='Wk'] {string} Text for week of the year column header.
			@property [weekStatus='Week of the year'] {string} Status text for week of the year column header.
			@property [dayStatus='Select DD,&#160;M&#160;d,&#160;yyyy'] {string} Status text for selectable days.
			@property [defaultStatus='Select a date'] {string} Status text shown by default.
			@property [isRTL=false] {boolean} <code>true</code> if language is right-to-left. */
		regionalOptions: { // Available regional settings, indexed by language/country code
			'': { // Default regional settings - English/US
				renderer: {}, // this.defaultRenderer
				prevText: '&lt;Prev',
				prevStatus: 'Show the previous month',
				prevJumpText: '&lt;&lt;',
				prevJumpStatus: 'Show the previous year',
				nextText: 'Next&gt;',
				nextStatus: 'Show the next month',
				nextJumpText: '&gt;&gt;',
				nextJumpStatus: 'Show the next year',
				currentText: 'Current',
				currentStatus: 'Show the current month',
				todayText: 'Today',
				todayStatus: 'Show today\'s month',
				clearText: 'Clear',
				clearStatus: 'Clear all the dates',
				closeText: 'Close',
				closeStatus: 'Close the datepicker',
				yearStatus: 'Change the year',
				earlierText: '&#160;&#160;▲',
				laterText: '&#160;&#160;▼',
				monthStatus: 'Change the month',
				weekText: 'Wk',
				weekStatus: 'Week of the year',
				dayStatus: 'Select DD, M d, yyyy',
				defaultStatus: 'Select a date',
				isRTL: false
			}
		},
		
		/** Names of getter methods - those that can't be chained.
			@memberof CalendarsPicker */
		_getters: ['getDate', 'isDisabled', 'isSelectable', 'retrieveDate'],

		_disabled: [],
		
		_popupClass: 'calendars-popup', // Marker for popup division
		_triggerClass: 'calendars-trigger', // Marker for trigger element
		_disableClass: 'calendars-disable', // Marker for disabled element
		_monthYearClass: 'calendars-month-year', // Marker for month/year inputs
		_curMonthClass: 'calendars-month-', // Marker for current month/year
		_anyYearClass: 'calendars-any-year', // Marker for year direct input
		_curDoWClass: 'calendars-dow-', // Marker for day of week

		_init: function() {
			this.defaultOptions.commands = this.commands;
			this.regionalOptions[''].renderer = this.defaultRenderer;
			this._super();
		},

		_instSettings: function(elem, options) {
			return {selectedDates: [], drawDate: null, pickingRange: false,
				inline: ($.inArray(elem[0].nodeName.toLowerCase(), ['div', 'span']) > -1),
				get: function(name) { // Get a setting value, computing if necessary
					if ($.inArray(name, ['defaultDate', 'minDate', 'maxDate']) > -1) { // Decode date settings
						return this.options.calendar.determineDate(this.options[name], null,
							this.selectedDates[0], this.get('dateFormat'), this.getConfig());
					}
					if (name === 'dateFormat') {
						return this.options.dateFormat || this.options.calendar.local.dateFormat;
					}
					return this.options[name];
				},
				curMinDate: function() {
					return (this.pickingRange ? this.selectedDates[0] : this.get('minDate'));
				},
				getConfig: function() {
					return {dayNamesShort: this.options.dayNamesShort, dayNames: this.options.dayNames,
						monthNamesShort: this.options.monthNamesShort, monthNames: this.options.monthNames,
						calculateWeek: this.options.calculateWeek, shortYearCutoff: this.options.shortYearCutoff};
				}
			};
		},

		_postAttach: function(elem, inst) {
			if (inst.inline) {
				inst.drawDate = plugin._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				inst.prevDate = inst.drawDate.newDate();
				this._update(elem[0]);
				if ($.fn.mousewheel) {
					elem.mousewheel(this._doMouseWheel);
				}
			}
			else {
				this._attachments(elem, inst);
				elem.on('keydown.' + inst.name, this._keyDown).on('keypress.' + inst.name, this._keyPress).
					on('keyup.' + inst.name, this._keyUp);
				if (elem.attr('disabled')) {
					this.disable(elem[0]);
				}
			}
		},

		_optionsChanged: function(elem, inst, options) {
			if (options.calendar && options.calendar !== inst.options.calendar) {
				var discardDate = function(name) {
					return (typeof inst.options[name] === 'object' ? null : inst.options[name]);
				};
				options = $.extend({defaultDate: discardDate('defaultDate'),
					minDate: discardDate('minDate'), maxDate: discardDate('maxDate')}, options);
				inst.selectedDates = [];
				inst.drawDate = null;
			}
			var dates = inst.selectedDates;
			$.extend(inst.options, options);
			this.setDate(elem[0], dates, null, false, true);
			inst.pickingRange = false;
			var calendar = inst.options.calendar;
			var defaultDate = inst.get('defaultDate');
			inst.drawDate = this._checkMinMax((defaultDate ? defaultDate : inst.drawDate) ||
				defaultDate || calendar.today(), inst).newDate();
			if (!inst.inline) {
				this._attachments(elem, inst);
			}
			if (inst.inline || inst.div) {
				this._update(elem[0]);
			}
		},

		/** Attach events and trigger, if necessary.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The control to affect.
			@param inst {object} The current instance settings. */
		_attachments: function(elem, inst) {
			elem.off('focus.' + inst.name);
			if (inst.options.showOnFocus) {
				elem.on('focus.' + inst.name, this.show);
			}
			if (inst.trigger) {
				inst.trigger.remove();
			}
			var trigger = inst.options.showTrigger;
			inst.trigger = (!trigger ? $([]) :
				$(trigger).clone().removeAttr('id').addClass(this._triggerClass)
					[inst.options.isRTL ? 'insertBefore' : 'insertAfter'](elem).
					click(function() {
						if (!plugin.isDisabled(elem[0])) {
							plugin[plugin.curInst === inst ? 'hide' : 'show'](elem[0]);
						}
					}));
			this._autoSize(elem, inst);
			var dates = this._extractDates(inst, elem.val());
			if (dates) {
				this.setDate(elem[0], dates, null, true);
			}
			var defaultDate = inst.get('defaultDate');
			if (inst.options.selectDefaultDate && defaultDate && inst.selectedDates.length === 0) {
				this.setDate(elem[0], (defaultDate || inst.options.calendar.today()).newDate());
			}
		},

		/** Apply the maximum length for the date format.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The control to affect.
			@param inst {object} The current instance settings. */
		_autoSize: function(elem, inst) {
			if (inst.options.autoSize && !inst.inline) {
				var calendar = inst.options.calendar;
				var date = calendar.newDate(2009, 10, 20); // Ensure double digits
				var dateFormat = inst.get('dateFormat');
				if (dateFormat.match(/[DM]/)) {
					var findMax = function(names) {
						var max = 0;
						var maxI = 0;
						for (var i = 0; i < names.length; i++) {
							if (names[i].length > max) {
								max = names[i].length;
								maxI = i;
							}
						}
						return maxI;
					};
					date.month(findMax(calendar.local[dateFormat.match(/MM/) ? // Longest month
						'monthNames' : 'monthNamesShort']) + 1);
					date.day(findMax(calendar.local[dateFormat.match(/DD/) ? // Longest day
						'dayNames' : 'dayNamesShort']) + 20 - date.dayOfWeek());
				}
				inst.elem.attr('size', date.formatDate(dateFormat).length);
			}
		},

		_preDestroy: function(elem, inst) {
			if (inst.trigger) {
				inst.trigger.remove();
			}
			elem.empty().off('.' + inst.name);
			if (inst.inline && $.fn.mousewheel) {
				elem.unmousewheel();
			}
			if (!inst.inline && inst.options.autoSize) {
				elem.removeAttr('size');
			}
		},

		/** Apply multiple event functions.
			@memberof CalendarsPicker
			@param fns {function} The functions to apply.
			@example onShow: multipleEvents(fn1, fn2, ...) */
		multipleEvents: function(fns) {
			var funcs = arguments;
			return function(args) {
				for (var i = 0; i < funcs.length; i++) {
					funcs[i].apply(this, arguments);
				}
			};
		},

		/** Enable the control.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@example $(selector).datepick('enable') */
		enable: function(elem) {
			elem = $(elem);
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			var inst = this._getInst(elem);
			if (inst.inline) {
				elem.children('.' + this._disableClass).remove().end().
					find('button,select').prop('disabled', false).end().
					find('a').attr('href', 'javascript:void(0)');
			}
			else {
				elem.prop('disabled', false);
				inst.trigger.filter('button.' + this._triggerClass).prop('disabled', false).end().
					filter('img.' + this._triggerClass).css({opacity: '1.0', cursor: ''});
			}
			this._disabled = $.map(this._disabled,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
		},

		/** Disable the control.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@example $(selector).datepick('disable') */
		disable: function(elem) {
			elem = $(elem);
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			var inst = this._getInst(elem);
			if (inst.inline) {
				var inline = elem.children(':last');
				var offset = inline.offset();
				var relOffset = {left: 0, top: 0};
				inline.parents().each(function() {
					if ($(this).css('position') === 'relative') {
						relOffset = $(this).offset();
						return false;
					}
				});
				var zIndex = elem.css('zIndex');
				zIndex = (zIndex === 'auto' ? 0 : parseInt(zIndex, 10)) + 1;
				elem.prepend('<div class="' + this._disableClass + '" style="' +
					'width: ' + inline.outerWidth() + 'px; height: ' + inline.outerHeight() +
					'px; left: ' + (offset.left - relOffset.left) + 'px; top: ' +
					(offset.top - relOffset.top) + 'px; z-index: ' + zIndex + '"></div>').
					find('button,select').prop('disabled', true).end().
					find('a').removeAttr('href');
			}
			else {
				elem.prop('disabled', true);
				inst.trigger.filter('button.' + this._triggerClass).prop('disabled', true).end().
					filter('img.' + this._triggerClass).css({opacity: '0.5', cursor: 'default'});
			}
			this._disabled = $.map(this._disabled,
				function(value) { return (value === elem[0] ? null : value); }); // Delete entry
			this._disabled.push(elem[0]);
		},

		/** Is the first field in a jQuery collection disabled as a datepicker?
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@return {boolean} <code>true</code> if disabled, <code>false</code> if enabled.
			@example if ($(selector).datepick('isDisabled')) {...} */
		isDisabled: function(elem) {
			return (elem && $.inArray(elem, this._disabled) > -1);
		},

		/** Show a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Event|Element} a focus event or the control to use.
			@example $(selector).datepick('show') */
		show: function(elem) {
			elem = $(elem.target || elem);
			var inst = plugin._getInst(elem);
			if (plugin.curInst === inst) {
				return;
			}
			if (plugin.curInst) {
				plugin.hide(plugin.curInst, true);
			}
			if (!$.isEmptyObject(inst)) {
				// Retrieve existing date(s)
				inst.lastVal = null;
				inst.selectedDates = plugin._extractDates(inst, elem.val());
				inst.pickingRange = false;
				inst.drawDate = plugin._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				inst.prevDate = inst.drawDate.newDate();
				plugin.curInst = inst;
				// Generate content
				plugin._update(elem[0], true);
				// Adjust position before showing
				var offset = plugin._checkOffset(inst);
				inst.div.css({left: offset.left, top: offset.top});
				// And display
				var showAnim = inst.options.showAnim;
				var showSpeed = inst.options.showSpeed;
				showSpeed = (showSpeed === 'normal' && $.ui &&
					parseInt($.ui.version.substring(2)) >= 8 ? '_default' : showSpeed);
				if ($.effects && ($.effects[showAnim] || ($.effects.effect && $.effects.effect[showAnim]))) {
					var data = inst.div.data(); // Update old effects data
					for (var key in data) {
						if (key.match(/^ec\.storage\./)) {
							data[key] = inst._mainDiv.css(key.replace(/ec\.storage\./, ''));
						}
					}
					inst.div.data(data).show(showAnim, inst.options.showOptions, showSpeed);
				}
				else {
					inst.div[showAnim || 'show'](showAnim ? showSpeed : 0);
				}
			}
		},

		/** Extract possible dates from a string.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param text {string} The text to extract from.
			@return {CDate[]} The extracted dates. */
		_extractDates: function(inst, datesText) {
			if (datesText === inst.lastVal) {
				return;
			}
			inst.lastVal = datesText;
			datesText = datesText.split(inst.options.multiSelect ? inst.options.multiSeparator :
				(inst.options.rangeSelect ? inst.options.rangeSeparator : '\x00'));
			var dates = [];
			for (var i = 0; i < datesText.length; i++) {
				try {
					var date = inst.options.calendar.parseDate(inst.get('dateFormat'), datesText[i]);
					if (date) {
						var found = false;
						for (var j = 0; j < dates.length; j++) {
							if (dates[j].compareTo(date) === 0) {
								found = true;
								break;
							}
						}
						if (!found) {
							dates.push(date);
						}
					}
				}
				catch (e) {
					// Ignore
				}
			}
			dates.splice(inst.options.multiSelect || (inst.options.rangeSelect ? 2 : 1), dates.length);
			if (inst.options.rangeSelect && dates.length === 1) {
				dates[1] = dates[0];
			}
			return dates;
		},

		/** Update the datepicker display.
			@memberof CalendarsPicker
			@private
			@param elem {Event|Element} a focus event or the control to use.
			@param hidden {boolean} <code>true</code> to initially hide the datepicker. */
		_update: function(elem, hidden) {
			elem = $(elem.target || elem);
			var inst = plugin._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				if (inst.inline || plugin.curInst === inst) {
					if ($.isFunction(inst.options.onChangeMonthYear) && (!inst.prevDate ||
							inst.prevDate.year() !== inst.drawDate.year() ||
							inst.prevDate.month() !== inst.drawDate.month())) {
						inst.options.onChangeMonthYear.apply(elem[0],
							[inst.drawDate.year(), inst.drawDate.month()]);
					}
				}
				if (inst.inline) {
					var index = $('a, :input', elem).index($(':focus', elem));
					elem.html(this._generateContent(elem[0], inst));
					var focus = elem.find('a, :input');
					focus.eq(Math.max(Math.min(index, focus.length - 1), 0)).focus();
				}
				else if (plugin.curInst === inst) {
					if (!inst.div) {
						inst.div = $('<div></div>').addClass(this._popupClass).
							css({display: (hidden ? 'none' : 'static'), position: 'absolute',
								left: elem.offset().left, top: elem.offset().top + elem.outerHeight()}).
							appendTo($(inst.options.popupContainer || 'body'));
						if ($.fn.mousewheel) {
							inst.div.mousewheel(this._doMouseWheel);
						}
					}
					inst.div.html(this._generateContent(elem[0], inst));
					elem.focus();
				}
			}
		},

		/** Update the input field and any alternate field with the current dates.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to use.
			@param keyUp {boolean} <code>true</code> if coming from <code>keyUp</code> processing (internal). */
		_updateInput: function(elem, keyUp) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var value = '';
				var altValue = '';
				var sep = (inst.options.multiSelect ? inst.options.multiSeparator :
					inst.options.rangeSeparator);
				var calendar = inst.options.calendar;
				var dateFormat = inst.get('dateFormat');
				var altFormat = inst.options.altFormat || dateFormat;
				for (var i = 0; i < inst.selectedDates.length; i++) {
					value += (keyUp ? '' : (i > 0 ? sep : '') +
						calendar.formatDate(dateFormat, inst.selectedDates[i]));
					altValue += (i > 0 ? sep : '') +
						calendar.formatDate(altFormat, inst.selectedDates[i]);
				}
				if (!inst.inline && !keyUp) {
					$(elem).val(value);
				}
				$(inst.options.altField).val(altValue);
				if ($.isFunction(inst.options.onSelect) && !keyUp && !inst.inSelect) {
					inst.inSelect = true; // Prevent endless loops
					inst.options.onSelect.apply(elem, [inst.selectedDates]);
					inst.inSelect = false;
				}
			}
		},

		/** Retrieve the size of left and top borders for an element.
			@memberof CalendarsPicker
			@private
			@param elem {jQuery} The element of interest.
			@return {number[]} The left and top borders. */
		_getBorders: function(elem) {
			var convert = function(value) {
				return {thin: 1, medium: 3, thick: 5}[value] || value;
			};
			return [parseFloat(convert(elem.css('border-left-width'))),
				parseFloat(convert(elem.css('border-top-width')))];
		},

		/** Check positioning to remain on the screen.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@return {object} The updated offset for the datepicker. */
		_checkOffset: function(inst) {
			var base = (inst.elem.is(':hidden') && inst.trigger ? inst.trigger : inst.elem);
			var offset = base.offset();
			var browserWidth = $(window).width();
			var browserHeight = $(window).height();
			if (browserWidth === 0) {
				return offset;
			}
			var isFixed = false;
			$(inst.elem).parents().each(function() {
				isFixed |= $(this).css('position') === 'fixed';
				return !isFixed;
			});
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			var above = offset.top - (isFixed ? scrollY : 0) - inst.div.outerHeight();
			var below = offset.top - (isFixed ? scrollY : 0) + base.outerHeight();
			var alignL = offset.left - (isFixed ? scrollX : 0);
			var alignR = offset.left - (isFixed ? scrollX : 0) + base.outerWidth() - inst.div.outerWidth();
			var tooWide = (offset.left - scrollX + inst.div.outerWidth()) > browserWidth;
			var tooHigh = (offset.top - scrollY + inst.elem.outerHeight() +
				inst.div.outerHeight()) > browserHeight;
			inst.div.css('position', isFixed ? 'fixed' : 'absolute');
			var alignment = inst.options.alignment;
			if (alignment === 'topLeft') {
				offset = {left: alignL, top: above};
			}
			else if (alignment === 'topRight') {
				offset = {left: alignR, top: above};
			}
			else if (alignment === 'bottomLeft') {
				offset = {left: alignL, top: below};
			}
			else if (alignment === 'bottomRight') {
				offset = {left: alignR, top: below};
			}
			else if (alignment === 'top') {
				offset = {left: (inst.options.isRTL || tooWide ? alignR : alignL), top: above};
			}
			else { // bottom
				offset = {left: (inst.options.isRTL || tooWide ? alignR : alignL),
					top: (tooHigh ? above : below)};
			}
			offset.left = Math.max((isFixed ? 0 : scrollX), offset.left);
			offset.top = Math.max((isFixed ? 0 : scrollY), offset.top);
			return offset;
		},

		/** Close date picker if clicked elsewhere.
			@memberof CalendarsPicker
			@private
			@param event {MouseEvent} The mouse click to check. */
		_checkExternalClick: function(event) {
			if (!plugin.curInst) {
				return;
			}
			var elem = $(event.target);
			if (elem.closest('.' + plugin._popupClass + ',.' + plugin._triggerClass).length === 0 &&
					!elem.hasClass(plugin._getMarker())) {
				plugin.hide(plugin.curInst);
			}
		},

		/** Hide a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Element|object} The control to use or the current instance settings.
			@param immediate {boolean} <code>true</code> to close immediately without animation (internal).
			@example $(selector).datepick('hide') */
		hide: function(elem, immediate) {
			if (!elem) {
				return;
			}
			var inst = this._getInst(elem);
			if ($.isEmptyObject(inst)) {
				inst = elem;
			}
			if (inst && inst === plugin.curInst) {
				var showAnim = (immediate ? '' : inst.options.showAnim);
				var showSpeed = inst.options.showSpeed;
				showSpeed = (showSpeed === 'normal' && $.ui &&
					parseInt($.ui.version.substring(2)) >= 8 ? '_default' : showSpeed);
				var postProcess = function() {
					if (!inst.div) {
						return;
					}
					inst.div.remove();
					inst.div = null;
					plugin.curInst = null;
					if ($.isFunction(inst.options.onClose)) {
						inst.options.onClose.apply(elem, [inst.selectedDates]);
					}
				};
				inst.div.stop();
				if ($.effects && ($.effects[showAnim] || ($.effects.effect && $.effects.effect[showAnim]))) {
					inst.div.hide(showAnim, inst.options.showOptions, showSpeed, postProcess);
				}
				else {
					var hideAnim = (showAnim === 'slideDown' ? 'slideUp' :
						(showAnim === 'fadeIn' ? 'fadeOut' : 'hide'));
					inst.div[hideAnim]((showAnim ? showSpeed : ''), postProcess);
				}
				if (!showAnim) {
					postProcess();
				}
			}
		},

		/** Handle keystrokes in the datepicker.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if not handled, <code>false</code> if handled. */
		_keyDown: function(event) {
			var elem = (event.data && event.data.elem) || event.target;
			var inst = plugin._getInst(elem);
			var handled = false;
			if (inst.inline || inst.div) {
				if (event.keyCode === 9) { // Tab - close
					plugin.hide(elem);
				}
				else if (event.keyCode === 13) { // Enter - select
					plugin.selectDate(elem,
						$('a.' + inst.options.renderer.highlightedClass, inst.div)[0]);
					handled = true;
				}
				else { // Command keystrokes
					var commands = inst.options.commands;
					for (var name in commands) {
						var command = commands[name];
						if (command.keystroke.keyCode === event.keyCode &&
								!!command.keystroke.ctrlKey === !!(event.ctrlKey || event.metaKey) &&
								!!command.keystroke.altKey === event.altKey &&
								!!command.keystroke.shiftKey === event.shiftKey) {
							plugin.performAction(elem, name);
							handled = true;
							break;
						}
					}
				}
			}
			else { // Show on 'current' keystroke
				var command = inst.options.commands.current;
				if (command.keystroke.keyCode === event.keyCode &&
						!!command.keystroke.ctrlKey === !!(event.ctrlKey || event.metaKey) &&
						!!command.keystroke.altKey === event.altKey &&
						!!command.keystroke.shiftKey === event.shiftKey) {
					plugin.show(elem);
					handled = true;
				}
			}
			inst.ctrlKey = ((event.keyCode < 48 && event.keyCode !== 32) || event.ctrlKey || event.metaKey);
			if (handled) {
				event.preventDefault();
				event.stopPropagation();
			}
			return !handled;
		},

		/** Filter keystrokes in the datepicker.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if allowed, <code>false</code> if not allowed. */
		_keyPress: function(event) {
			var inst = plugin._getInst((event.data && event.data.elem) || event.target);
			if (!$.isEmptyObject(inst) && inst.options.constrainInput) {
				var ch = String.fromCharCode(event.keyCode || event.charCode);
				var allowedChars = plugin._allowedChars(inst);
				return (event.metaKey || inst.ctrlKey || ch < ' ' ||
					!allowedChars || allowedChars.indexOf(ch) > -1);
			}
			return true;
		},

		/** Determine the set of characters allowed by the date format.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@return {string} The set of allowed characters, or <code>null</code> if anything allowed. */
		_allowedChars: function(inst) {
			var allowedChars = (inst.options.multiSelect ? inst.options.multiSeparator :
				(inst.options.rangeSelect ? inst.options.rangeSeparator : ''));
			var literal = false;
			var hasNum = false;
			var dateFormat = inst.get('dateFormat');
			for (var i = 0; i < dateFormat.length; i++) {
				var ch = dateFormat.charAt(i);
				if (literal) {
					if (ch === "'" && dateFormat.charAt(i + 1) !== "'") {
						literal = false;
					}
					else {
						allowedChars += ch;
					}
				}
				else {
					switch (ch) {
						case 'd': case 'm': case 'o': case 'w':
							allowedChars += (hasNum ? '' : '0123456789'); hasNum = true; break;
						case 'y': case '@': case '!':
							allowedChars += (hasNum ? '' : '0123456789') + '-'; hasNum = true; break;
						case 'J':
							allowedChars += (hasNum ? '' : '0123456789') + '-.'; hasNum = true; break;
						case 'D': case 'M': case 'Y':
							return null; // Accept anything
						case "'":
							if (dateFormat.charAt(i + 1) === "'") {
								allowedChars += "'";
							}
							else {
								literal = true;
							}
							break;
						default:
							allowedChars += ch;
					}
				}
			}
			return allowedChars;
		},

		/** Synchronise datepicker with the field.
			@memberof CalendarsPicker
			@private
			@param event {KeyEvent} The keystroke.
			@return {boolean} <code>true</code> if allowed, <code>false</code> if not allowed. */
		_keyUp: function(event) {
			var elem = (event.data && event.data.elem) || event.target;
			var inst = plugin._getInst(elem);
			if (!$.isEmptyObject(inst) && !inst.ctrlKey && inst.lastVal !== inst.elem.val()) {
				try {
					var dates = plugin._extractDates(inst, inst.elem.val());
					if (dates.length > 0) {
						plugin.setDate(elem, dates, null, true);
					}
				}
				catch (event) {
					// Ignore
				}
			}
			return true;
		},

		/** Increment/decrement month/year on mouse wheel activity.
			@memberof CalendarsPicker
			@private
			@param event {event} The mouse wheel event.
			@param delta {number} The amount of change. */
		_doMouseWheel: function(event, delta) {
			var elem = (plugin.curInst && plugin.curInst.elem[0]) ||
				$(event.target).closest('.' + plugin._getMarker())[0];
			if (plugin.isDisabled(elem)) {
				return;
			}
			var inst = plugin._getInst(elem);
			if (inst.options.useMouseWheel) {
				delta = (delta < 0 ? -1 : +1);
				plugin.changeMonth(elem, -inst.options[event.ctrlKey ? 'monthsToJump' : 'monthsToStep'] * delta);
			}
			event.preventDefault();
		},

		/** Clear an input and close a popup datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to use.
			@example $(selector).datepick('clear') */
		clear: function(elem) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				inst.selectedDates = [];
				this.hide(elem);
				var defaultDate = inst.get('defaultDate');
				if (inst.options.selectDefaultDate && defaultDate) {
					this.setDate(elem, (defaultDate || inst.options.calendar.today()).newDate());
				}
				else {
					this._updateInput(elem);
				}
			}
		},

		/** Retrieve the selected date(s) for a datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@return {CDate[]} The selected date(s).
			@example var dates = $(selector).datepick('getDate') */
		getDate: function(elem) {
			var inst = this._getInst(elem);
			return (!$.isEmptyObject(inst) ? inst.selectedDates : []);
		},

		/** Set the selected date(s) for a datepicker.
			@memberof CalendarsPicker
			@param elem {Element} the control to examine.
			@param dates {CDate|number|string|array} the selected date(s).
			@param [endDate] {CDate|number|string} the ending date for a range.
			@param [keyUp] {boolean} <code>true</code> if coming from <code>keyUp</code> processing (internal).
			@param [setOpt] {boolean} <code>true</code> if coming from option processing (internal).
			@example $(selector).datepick('setDate', new Date(2014, 12-1, 25))
 $(selector).datepick('setDate', '12/25/2014', '01/01/2015')
 $(selector).datepick('setDate', [date1, date2, date3]) */
		setDate: function(elem, dates, endDate, keyUp, setOpt) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				if (!$.isArray(dates)) {
					dates = [dates];
					if (endDate) {
						dates.push(endDate);
					}
				}
				var minDate = inst.get('minDate');
				var maxDate = inst.get('maxDate');
				var curDate = inst.selectedDates[0];
				inst.selectedDates = [];
				for (var i = 0; i < dates.length; i++) {
					var date = inst.options.calendar.determineDate(
						dates[i], null, curDate, inst.get('dateFormat'), inst.getConfig());
					if (date) {
						if ((!minDate || date.compareTo(minDate) !== -1) &&
								(!maxDate || date.compareTo(maxDate) !== +1)) {
							var found = false;
							for (var j = 0; j < inst.selectedDates.length; j++) {
								if (inst.selectedDates[j].compareTo(date) === 0) {
									found = true;
									break;
								}
							}
							if (!found) {
								inst.selectedDates.push(date);
							}
						}
					}
				}
				inst.selectedDates.splice(inst.options.multiSelect ||
					(inst.options.rangeSelect ? 2 : 1), inst.selectedDates.length);
				if (inst.options.rangeSelect) {
					switch (inst.selectedDates.length) {
						case 1: inst.selectedDates[1] = inst.selectedDates[0]; break;
						case 2: inst.selectedDates[1] =
							(inst.selectedDates[0].compareTo(inst.selectedDates[1]) === +1 ?
							inst.selectedDates[0] : inst.selectedDates[1]); break;
					}
					inst.pickingRange = false;
				}
				inst.prevDate = (inst.drawDate ? inst.drawDate.newDate() : null);
				inst.drawDate = this._checkMinMax((inst.selectedDates[0] ||
					inst.get('defaultDate') || inst.options.calendar.today()).newDate(), inst);
				if (!setOpt) {
					this._update(elem);
					this._updateInput(elem, keyUp);
				}
			}
		},

		/** Determine whether a date is selectable for this datepicker.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to check.
			@param date {CDate|string|number} The date to check.
			@return {boolean} <code>true</code> if selectable, <code>false</code> if not.
			@example var selectable = $(selector).datepick('isSelectable', date) */
		isSelectable: function(elem, date) {
			var inst = this._getInst(elem);
			if ($.isEmptyObject(inst)) {
				return false;
			}
			date = inst.options.calendar.determineDate(date,
				inst.selectedDates[0] || inst.options.calendar.today(), null,
				inst.options.dateFormat, inst.getConfig());
			return this._isSelectable(elem, date, inst.options.onDate,
				inst.get('minDate'), inst.get('maxDate'));
		},

		/** Internally determine whether a date is selectable for this datepicker.
			@memberof CalendarsPicker
			@private
			@param elem {Element} the control to check.
			@param date {CDate} The date to check.
			@param onDate {function|boolean} Any <code>onDate</code> callback or <code>callback.selectable</code>.
			@param minDate {CDate} The minimum allowed date.
			@param maxDate {CDate} The maximum allowed date.
			@return {boolean} <code>true</code> if selectable, <code>false</code> if not. */
		_isSelectable: function(elem, date, onDate, minDate, maxDate) {
			var dateInfo = (typeof onDate === 'boolean' ? {selectable: onDate} :
				(!$.isFunction(onDate) ? {} : onDate.apply(elem, [date, true])));
			return (dateInfo.selectable !== false) &&
				(!minDate || date.toJD() >= minDate.toJD()) && (!maxDate || date.toJD() <= maxDate.toJD());
		},

		/** Perform a named action for a datepicker.
			@memberof CalendarsPicker
			@param elem {element} The control to affect.
			@param action {string} The name of the action. */
		performAction: function(elem, action) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && !this.isDisabled(elem)) {
				var commands = inst.options.commands;
				if (commands[action] && commands[action].enabled.apply(elem, [inst])) {
					commands[action].action.apply(elem, [inst]);
				}
			}
		},

		/** Set the currently shown month, defaulting to today's.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param [year] {number} The year to show.
			@param [month] {number} The month to show (1-12).
			@param [day] {number} The day to show.
			@example $(selector).datepick('showMonth', 2014, 12, 25) */
		showMonth: function(elem, year, month, day) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && (day != null ||
					(inst.drawDate.year() !== year || inst.drawDate.month() !== month))) {
				inst.prevDate = inst.drawDate.newDate();
				var calendar = inst.options.calendar;
				var show = this._checkMinMax((year != null ?
					calendar.newDate(year, month, 1) : calendar.today()), inst);
				inst.drawDate.date(show.year(), show.month(), 
					(day != null ? day : Math.min(inst.drawDate.day(),
					calendar.daysInMonth(show.year(), show.month()))));
				this._update(elem);
			}
		},

		/** Adjust the currently shown month.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param offset {number} The number of months to change by.
			@example $(selector).datepick('changeMonth', 2)*/
		changeMonth: function(elem, offset) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var date = inst.drawDate.newDate().add(offset, 'm');
				this.showMonth(elem, date.year(), date.month());
			}
		},

		/** Adjust the currently shown day.
			@memberof CalendarsPicker
			@param elem {Element} The control to affect.
			@param offset {number} The number of days to change by.
			@example $(selector).datepick('changeDay', 7)*/
		changeDay: function(elem, offset) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst)) {
				var date = inst.drawDate.newDate().add(offset, 'd');
				this.showMonth(elem, date.year(), date.month(), date.day());
			}
		},

		/** Restrict a date to the minimum/maximum specified.
			@memberof CalendarsPicker
			@private
			@param date {CDate} The date to check.
			@param inst {object} The current instance settings. */
		_checkMinMax: function(date, inst) {
			var minDate = inst.get('minDate');
			var maxDate = inst.get('maxDate');
			date = (minDate && date.compareTo(minDate) === -1 ? minDate.newDate() : date);
			date = (maxDate && date.compareTo(maxDate) === +1 ? maxDate.newDate() : date);
			return date;
		},

		/** Retrieve the date associated with an entry in the datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@param target {Element} The selected datepicker element.
			@return {CDate} The corresponding date, or <code>null</code>.			
			@example var date = $(selector).datepick('retrieveDate', $('div.datepick-popup a:contains(10)')[0]) */
		retrieveDate: function(elem, target) {
			var inst = this._getInst(elem);
			return ($.isEmptyObject(inst) ? null : inst.options.calendar.fromJD(
				parseFloat(target.className.replace(/^.*jd(\d+\.5).*$/, '$1'))));
		},

		/** Select a date for this datepicker.
			@memberof CalendarsPicker
			@param elem {Element} The control to examine.
			@param target {Element} The selected datepicker element.
			@example $(selector).datepick('selectDate', $('div.datepick-popup a:contains(10)')[0]) */
		selectDate: function(elem, target) {
			var inst = this._getInst(elem);
			if (!$.isEmptyObject(inst) && !this.isDisabled(elem)) {
				var date = this.retrieveDate(elem, target);
				if (inst.options.multiSelect) {
					var found = false;
					for (var i = 0; i < inst.selectedDates.length; i++) {
						if (date.compareTo(inst.selectedDates[i]) === 0) {
							inst.selectedDates.splice(i, 1);
							found = true;
							break;
						}
					}
					if (!found && inst.selectedDates.length < inst.options.multiSelect) {
						inst.selectedDates.push(date);
					}
				}
				else if (inst.options.rangeSelect) {
					if (inst.pickingRange) {
						inst.selectedDates[1] = date;
					}
					else {
						inst.selectedDates = [date, date];
					}
					inst.pickingRange = !inst.pickingRange;
				}
				else {
					inst.selectedDates = [date];
				}
				inst.prevDate = inst.drawDate = date.newDate();
				this._updateInput(elem);
				if (inst.inline || inst.pickingRange || inst.selectedDates.length <
						(inst.options.multiSelect || (inst.options.rangeSelect ? 2 : 1))) {
					this._update(elem);
				}
				else {
					this.hide(elem);
				}
			}
		},

		/** Generate the datepicker content for this control.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to affect.
			@param inst {object} The current instance settings.
			@return {jQuery} The datepicker content */
		_generateContent: function(elem, inst) {
			var monthsToShow = inst.options.monthsToShow;
			monthsToShow = ($.isArray(monthsToShow) ? monthsToShow : [1, monthsToShow]);
			inst.drawDate = this._checkMinMax(
				inst.drawDate || inst.get('defaultDate') || inst.options.calendar.today(), inst);
			var drawDate = inst.drawDate.newDate().add(-inst.options.monthsOffset, 'm');
			// Generate months
			var monthRows = '';
			for (var row = 0; row < monthsToShow[0]; row++) {
				var months = '';
				for (var col = 0; col < monthsToShow[1]; col++) {
					months += this._generateMonth(elem, inst, drawDate.year(),
						drawDate.month(), inst.options.calendar, inst.options.renderer, (row === 0 && col === 0));
					drawDate.add(1, 'm');
				}
				monthRows += this._prepare(inst.options.renderer.monthRow, inst).replace(/\{months\}/, months);
			}
			var picker = this._prepare(inst.options.renderer.picker, inst).replace(/\{months\}/, monthRows).
				replace(/\{weekHeader\}/g, this._generateDayHeaders(inst, inst.options.calendar, inst.options.renderer));
			// Add commands
			var addCommand = function(type, open, close, name, classes) {
				if (picker.indexOf('{' + type + ':' + name + '}') === -1) {
					return;
				}
				var command = inst.options.commands[name];
				var date = (inst.options.commandsAsDateFormat ? command.date.apply(elem, [inst]) : null);
				picker = picker.replace(new RegExp('\\{' + type + ':' + name + '\\}', 'g'),
					'<' + open + (command.status ? ' title="' + inst.options[command.status] + '"' : '') +
					' class="' + inst.options.renderer.commandClass + ' ' +
					inst.options.renderer.commandClass + '-' + name + ' ' + classes +
					(command.enabled(inst) ? '' : ' ' + inst.options.renderer.disabledClass) + '">' +
					(date ? date.formatDate(inst.options[command.text]) :
					inst.options[command.text]) + '</' + close + '>');
			};
			for (var name in inst.options.commands) {
				addCommand('button', 'button type="button"', 'button', name,
					inst.options.renderer.commandButtonClass);
				addCommand('link', 'a href="javascript:void(0)"', 'a', name,
					inst.options.renderer.commandLinkClass);
			}
			picker = $(picker);
			if (monthsToShow[1] > 1) {
				var count = 0;
				$(inst.options.renderer.monthSelector, picker).each(function() {
					var nth = ++count % monthsToShow[1];
					$(this).addClass(nth === 1 ? 'first' : (nth === 0 ? 'last' : ''));
				});
			}
			// Add datepicker behaviour
			var self = this;
			function removeHighlight() {
				(inst.inline ? $(this).closest('.' + self._getMarker()) : inst.div).
					find(inst.options.renderer.daySelector + ' a').
					removeClass(inst.options.renderer.highlightedClass);
			}
			picker.find(inst.options.renderer.daySelector + ' a').hover(
					function() {
						removeHighlight.apply(this);
						$(this).addClass(inst.options.renderer.highlightedClass);
					},
					removeHighlight).
				click(function() {
					self.selectDate(elem, this);
				}).end().
				find('select.' + this._monthYearClass + ':not(.' + this._anyYearClass + ')').
				change(function() {
					var monthYear = $(this).val().split('/');
					self.showMonth(elem, parseInt(monthYear[1], 10), parseInt(monthYear[0], 10));
				}).end().
				find('select.' + this._anyYearClass).click(function() {
					$(this).css('visibility', 'hidden').
						next('input').css({left: this.offsetLeft, top: this.offsetTop,
						width: this.offsetWidth, height: this.offsetHeight}).show().focus();
				}).end().
				find('input.' + self._monthYearClass).change(function() {
					try {
						var year = parseInt($(this).val(), 10);
						year = (isNaN(year) ? inst.drawDate.year() : year);
						self.showMonth(elem, year, inst.drawDate.month(), inst.drawDate.day());
					}
					catch (e) {
						alert(e);
					}
				}).keydown(function(event) {
					if (event.keyCode === 13) { // Enter
						$(event.elem).change();
					}
					else if (event.keyCode === 27) { // Escape
						$(event.elem).hide().prev('select').css('visibility', 'visible');
						inst.elem.focus();
					}
				});
			// Add keyboard handling
			var data = {elem: inst.elem[0]};
			picker.keydown(data, this._keyDown).keypress(data, this._keyPress).keyup(data, this._keyUp);
			// Add command behaviour
			picker.find('.' + inst.options.renderer.commandClass).click(function() {
					if (!$(this).hasClass(inst.options.renderer.disabledClass)) {
						var action = this.className.replace(
							new RegExp('^.*' + inst.options.renderer.commandClass + '-([^ ]+).*$'), '$1');
						plugin.performAction(elem, action);
					}
				});
			// Add classes
			if (inst.options.isRTL) {
				picker.addClass(inst.options.renderer.rtlClass);
			}
			if (monthsToShow[0] * monthsToShow[1] > 1) {
				picker.addClass(inst.options.renderer.multiClass);
			}
			if (inst.options.pickerClass) {
				picker.addClass(inst.options.pickerClass);
			}
			// Resize
			$('body').append(picker);
			var width = 0;
			picker.find(inst.options.renderer.monthSelector).each(function() {
				width += $(this).outerWidth();
			});
			picker.width(width / monthsToShow[0]);
			// Pre-show customisation
			if ($.isFunction(inst.options.onShow)) {
				inst.options.onShow.apply(elem, [picker, inst.options.calendar, inst]);
			}
			return picker;
		},

		/** Generate the content for a single month.
			@memberof CalendarsPicker
			@private
			@param elem {Element} The control to affect.
			@param inst {object} The current instance settings.
			@param year {number} The year to generate.
			@param month {number} The month to generate.
			@param calendar {BaseCalendar} The current calendar.
			@param renderer {object} The rendering templates.
			@param first {boolean} <code>true</code> if first of multiple months.
			@return {string} The month content. */
		_generateMonth: function(elem, inst, year, month, calendar, renderer, first) {
			var daysInMonth = calendar.daysInMonth(year, month);
			var monthsToShow = inst.options.monthsToShow;
			monthsToShow = ($.isArray(monthsToShow) ? monthsToShow : [1, monthsToShow]);
			var fixedWeeks = inst.options.fixedWeeks || (monthsToShow[0] * monthsToShow[1] > 1);
			var firstDay = inst.options.firstDay;
			firstDay = (firstDay == null ? calendar.local.firstDay : firstDay);
			var leadDays = (calendar.dayOfWeek(year, month, calendar.minDay) -
				firstDay + calendar.daysInWeek()) % calendar.daysInWeek();
			var numWeeks = (fixedWeeks ? 6 : Math.ceil((leadDays + daysInMonth) / calendar.daysInWeek()));
			var selectOtherMonths = inst.options.selectOtherMonths && inst.options.showOtherMonths;
			var minDate = (inst.pickingRange ? inst.selectedDates[0] : inst.get('minDate'));
			var maxDate = inst.get('maxDate');
			var showWeeks = renderer.week.indexOf('{weekOfYear}') > -1;
			var today = calendar.today();
			var drawDate = calendar.newDate(year, month, calendar.minDay);
			drawDate.add(-leadDays - (fixedWeeks &&
				(drawDate.dayOfWeek() === firstDay || drawDate.daysInMonth() < calendar.daysInWeek())?
				calendar.daysInWeek() : 0), 'd');
			var jd = drawDate.toJD();
			// Generate weeks
			var weeks = '';
			for (var week = 0; week < numWeeks; week++) {
				var weekOfYear = (!showWeeks ? '' : '<span class="jd' + jd + '">' +
					($.isFunction(inst.options.calculateWeek) ?
					inst.options.calculateWeek(drawDate) : drawDate.weekOfYear()) + '</span>');
				var days = '';
				for (var day = 0; day < calendar.daysInWeek(); day++) {
					var selected = false;
					if (inst.options.rangeSelect && inst.selectedDates.length > 0) {
						selected = (drawDate.compareTo(inst.selectedDates[0]) !== -1 &&
							drawDate.compareTo(inst.selectedDates[1]) !== +1)
					}
					else {
						for (var i = 0; i < inst.selectedDates.length; i++) {
							if (inst.selectedDates[i].compareTo(drawDate) === 0) {
								selected = true;
								break;
							}
						}
					}
					var dateInfo = (!$.isFunction(inst.options.onDate) ? {} :
						inst.options.onDate.apply(elem, [drawDate, drawDate.month() === month]));
					var selectable = (selectOtherMonths || drawDate.month() === month) &&
						this._isSelectable(elem, drawDate, dateInfo.selectable, minDate, maxDate);
					days += this._prepare(renderer.day, inst).replace(/\{day\}/g,
						(selectable ? '<a href="javascript:void(0)"' : '<span') +
						' class="jd' + jd + ' ' + (dateInfo.dateClass || '') +
						(selected && (selectOtherMonths || drawDate.month() === month) ?
						' ' + renderer.selectedClass : '') +
						(selectable ? ' ' + renderer.defaultClass : '') +
						(drawDate.weekDay() ? '' : ' ' + renderer.weekendClass) +
						(drawDate.month() === month ? '' : ' ' + renderer.otherMonthClass) +
						(drawDate.compareTo(today) === 0 && drawDate.month() === month ?
						' ' + renderer.todayClass : '') +
						(drawDate.compareTo(inst.drawDate) === 0 && drawDate.month() === month ?
						' ' + renderer.highlightedClass : '') + '"' +
						(dateInfo.title || (inst.options.dayStatus && selectable) ? ' title="' +
						(dateInfo.title || drawDate.formatDate(inst.options.dayStatus)) + '"' : '') + '>' +
						(inst.options.showOtherMonths || drawDate.month() === month ?
						dateInfo.content || drawDate.day() : '&#160;') +
						(selectable ? '</a>' : '</span>'));
					drawDate.add(1, 'd');
					jd++;
				}
				weeks += this._prepare(renderer.week, inst).replace(/\{days\}/g, days).
					replace(/\{weekOfYear\}/g, weekOfYear);
			}
			var monthHeader = this._prepare(renderer.month, inst).match(/\{monthHeader(:[^\}]+)?\}/);
			monthHeader = (monthHeader[0].length <= 13 ? 'MM yyyy' :
				monthHeader[0].substring(13, monthHeader[0].length - 1));
			monthHeader = (first ? this._generateMonthSelection(
				inst, year, month, minDate, maxDate, monthHeader, calendar, renderer) :
				calendar.formatDate(monthHeader, calendar.newDate(year, month, calendar.minDay)));
			var weekHeader = this._prepare(renderer.weekHeader, inst).
				replace(/\{days\}/g, this._generateDayHeaders(inst, calendar, renderer));
			return this._prepare(renderer.month, inst).replace(/\{monthHeader(:[^\}]+)?\}/g, monthHeader).
				replace(/\{weekHeader\}/g, weekHeader).replace(/\{weeks\}/g, weeks);
		},

		/** Generate the HTML for the day headers.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param calendar {BaseCalendar} The current calendar.
			@param renderer {object} The rendering templates.
			@return {string} A week's worth of day headers. */
		_generateDayHeaders: function(inst, calendar, renderer) {
			var firstDay = inst.options.firstDay;
			firstDay = (firstDay == null ? calendar.local.firstDay : firstDay);
			var header = '';
			for (var day = 0; day < calendar.daysInWeek(); day++) {
				var dow = (day + firstDay) % calendar.daysInWeek();
				header += this._prepare(renderer.dayHeader, inst).replace(/\{day\}/g,
					'<span class="' + this._curDoWClass + dow + '" title="' +
					calendar.local.dayNames[dow] + '">' + calendar.local.dayNamesMin[dow] + '</span>');
			}
			return header;
		},

		/** Generate selection controls for month.
			@memberof CalendarsPicker
			@private
			@param inst {object} The current instance settings.
			@param year {number} The year to generate.
			@param month {number} The month to generate.
			@param minDate {CDate} The minimum date allowed.
			@param maxDate {CDate} The maximum date allowed.
			@param monthHeader {string} The month/year format.
			@param calendar {BaseCalendar} The current calendar.
			@return {string} The month selection content. */
		_generateMonthSelection: function(inst, year, month, minDate, maxDate, monthHeader, calendar) {
			if (!inst.options.changeMonth) {
				return calendar.formatDate(monthHeader, calendar.newDate(year, month, 1));
			}
			// Months
			var monthNames = calendar.local[
				'monthNames' + (monthHeader.match(/mm/i) ? '' : 'Short')];
			var html = monthHeader.replace(/m+/i, '\\x2E').replace(/y+/i, '\\x2F');
			var selector = '<select class="' + this._monthYearClass +
				'" title="' + inst.options.monthStatus + '">';
			var maxMonth = calendar.monthsInYear(year) + calendar.minMonth;
			for (var m = calendar.minMonth; m < maxMonth; m++) {
				if ((!minDate || calendar.newDate(year, m,
						calendar.daysInMonth(year, m) - 1 + calendar.minDay).
						compareTo(minDate) !== -1) &&
						(!maxDate || calendar.newDate(year, m, calendar.minDay).
						compareTo(maxDate) !== +1)) {
					selector += '<option value="' + m + '/' + year + '"' +
						(month === m ? ' selected="selected"' : '') + '>' +
						monthNames[m - calendar.minMonth] + '</option>';
				}
			}
			selector += '</select>';
			html = html.replace(/\\x2E/, selector);
			// Years
			var yearRange = inst.options.yearRange;
			if (yearRange === 'any') {
				selector = '<select class="' + this._monthYearClass + ' ' + this._anyYearClass +
					'" title="' + inst.options.yearStatus + '">' +
					'<option>' + year + '</option></select>' +
					'<input class="' + this._monthYearClass + ' ' + this._curMonthClass +
					month + '" value="' + year + '">';
			}
			else {
				yearRange = yearRange.split(':');
				var todayYear = calendar.today().year();
				var start = (yearRange[0].match('c[+-].*') ? year + parseInt(yearRange[0].substring(1), 10) :
					((yearRange[0].match('[+-].*') ? todayYear : 0) + parseInt(yearRange[0], 10)));
				var end = (yearRange[1].match('c[+-].*') ? year + parseInt(yearRange[1].substring(1), 10) :
					((yearRange[1].match('[+-].*') ? todayYear : 0) + parseInt(yearRange[1], 10)));
				selector = '<select class="' + this._monthYearClass +
					'" title="' + inst.options.yearStatus + '">';
				start = calendar.newDate(start + 1, calendar.firstMonth, calendar.minDay).add(-1, 'd');
				end = calendar.newDate(end, calendar.firstMonth, calendar.minDay);
				var addYear = function(y, yDisplay) {
					if (y !== 0 || calendar.hasYearZero) {
						selector += '<option value="' +
							Math.min(month, calendar.monthsInYear(y) - 1 + calendar.minMonth) +
							'/' + y + '"' + (year === y ? ' selected="selected"' : '') + '>' +
							(yDisplay || y) + '</option>';
					}
				};
				if (start.toJD() < end.toJD()) {
					start = (minDate && minDate.compareTo(start) === +1 ? minDate : start).year();
					end = (maxDate && maxDate.compareTo(end) === -1 ? maxDate : end).year();
					var earlierLater = Math.floor((end - start) / 2);
					if (!minDate || minDate.year() < start) {
						addYear(start - earlierLater, inst.options.earlierText);
					}
					for (var y = start; y <= end; y++) {
						addYear(y);
					}
					if (!maxDate || maxDate.year() > end) {
						addYear(end + earlierLater, inst.options.laterText);
					}
				}
				else {
					start = (maxDate && maxDate.compareTo(start) === -1 ? maxDate : start).year();
					end = (minDate && minDate.compareTo(end) === +1 ? minDate : end).year();
					var earlierLater = Math.floor((start - end) / 2);
					if (!maxDate || maxDate.year() > start) {
						addYear(start + earlierLater, inst.options.earlierText);
					}
					for (var y = start; y >= end; y--) {
						addYear(y);
					}
					if (!minDate || minDate.year() < end) {
						addYear(end - earlierLater, inst.options.laterText);
					}
				}
				selector += '</select>';
			}
			html = html.replace(/\\x2F/, selector);
			return html;
		},

		/** Prepare a render template for use.
			Exclude popup/inline sections that are not applicable.
			Localise text of the form: {l10n:name}.
			@memberof CalendarsPicker
			@private
			@param text {string} The text to localise.
			@param inst {object} The current instance settings.
			@return {string} The localised text. */
		_prepare: function(text, inst) {
			var replaceSection = function(type, retain) {
				while (true) {
					var start = text.indexOf('{' + type + ':start}');
					if (start === -1) {
						return;
					}
					var end = text.substring(start).indexOf('{' + type + ':end}');
					if (end > -1) {
						text = text.substring(0, start) +
							(retain ? text.substr(start + type.length + 8, end - type.length - 8) : '') +
							text.substring(start + end + type.length + 6);
					}
				}
			};
			replaceSection('inline', inst.inline);
			replaceSection('popup', !inst.inline);
			var pattern = /\{l10n:([^\}]+)\}/;
			var matches = null;
			while (matches = pattern.exec(text)) {
				text = text.replace(matches[0], inst.options[matches[1]]);
			}
			return text;
		}
	});

	var plugin = $.calendarsPicker; // Singleton instance

	$(function() {
		$(document).on('mousedown.' + pluginName, plugin._checkExternalClick).
			on('resize.' + pluginName, function() { plugin.hide(plugin.curInst); });
	});

})(jQuery);

/* http://keith-wood.name/calendars.html
   Calendars date picker extensions for jQuery v2.0.1.
   Written by Keith Wood (kbwood{at}iinet.com.au) August 2009.
   Available under the MIT (http://keith-wood.name/licence.html) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	var themeRollerRenderer = {
		picker: '<div{popup:start} id="ui-datepicker-div"{popup:end} class="ui-datepicker ui-widget ' +
		'ui-widget-content ui-helper-clearfix ui-corner-all{inline:start} ui-datepicker-inline{inline:end}">' +
		'<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix ui-corner-all">' +
		'{link:prev}{link:today}{link:next}</div>{months}' +
		'{popup:start}<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix ' +
		'ui-corner-all">{button:clear}{button:close}</div>{popup:end}' +
		'<div class="ui-helper-clearfix"></div></div>',
		monthRow: '<div class="ui-datepicker-row-break">{months}</div>',
		month: '<div class="ui-datepicker-group">' +
		'<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix ui-corner-all">{monthHeader:MM yyyy}</div>' +
		'<table class="ui-datepicker-calendar"><thead>{weekHeader}</thead><tbody>{weeks}</tbody></table></div>',
		weekHeader: '<tr>{days}</tr>',
		dayHeader: '<th>{day}</th>',
		week: '<tr>{days}</tr>',
		day: '<td>{day}</td>',
		monthSelector: '.ui-datepicker-group',
		daySelector: 'td',
		rtlClass: 'ui-datepicker-rtl',
		multiClass: 'ui-datepicker-multi',
		defaultClass: 'ui-state-default',
		selectedClass: 'ui-state-active',
		highlightedClass: 'ui-state-hover',
		todayClass: 'ui-state-highlight',
		otherMonthClass: 'ui-datepicker-other-month',
		weekendClass: 'ui-datepicker-week-end',
		commandClass: 'ui-datepicker-cmd',
		commandButtonClass: 'ui-state-default ui-corner-all',
		commandLinkClass: '',
		disabledClass: 'ui-datepicker-disabled'
	};

	$.extend($.calendarsPicker, {

		/** Template for generating a calendar picker showing week of year.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker */
		weekOfYearRenderer: $.extend({}, $.calendarsPicker.defaultRenderer, {
			weekHeader: '<tr><th class="calendars-week">' +
			'<span title="{l10n:weekStatus}">{l10n:weekText}</span></th>{days}</tr>',
			week: '<tr><td class="calendars-week">{weekOfYear}</td>{days}</tr>'
		}),

		/** ThemeRoller template for generating a calendar picker.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker */
		themeRollerRenderer: themeRollerRenderer,

		/** ThemeRoller template for generating a calendar picker showing week of year.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker */
		themeRollerWeekOfYearRenderer: $.extend({}, themeRollerRenderer, {
			weekHeader: '<tr><th class="ui-state-hover"><span>{l10n:weekText}</span></th>{days}</tr>',
			week: '<tr><td class="ui-state-hover">{weekOfYear}</td>{days}</tr>'
		}),

		/** Don't allow weekends to be selected.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker
			@param date {CDate} The current date.
			@return {object} Information about this date.
			@example onDate: $.calendarsPicker.noWeekends */
		noWeekends: function(date) {
			return {selectable: date.weekDay()};
		},

		/** Change the first day of the week by clicking on the day header.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker
			@param picker {jQuery} The completed datepicker division.
			@param calendar {BaseCalendar} The calendar implementation.
			@param inst {object} The current instance settings.
			@example onShow: $.calendarsPicker.changeFirstDay */
		changeFirstDay: function(picker, calendar, inst) {
			var target = $(this);
			picker.find('th span').each(function() {
				if (this.parentNode.className.match(/.*calendars-week.*/)) {
					return;
				}
				$('<a href="javascript:void(0)" class="' + this.className +
						'" title="Change first day of the week">' + $(this).text() + '</a>').
					click(function() {
						var dow = parseInt(this.className.replace(/^.*calendars-dow-(\d+).*$/, '$1'), 10);
						target.calendarsPicker('option', {firstDay: dow});
					}).
					replaceAll(this);
			});
		},

		/** A function to call when a date is hovered.
			@callback CalendarsPickerOnHover
			@param date {CDate} The date being hovered or <code>null</code> on exit.
			@param selectable {boolean} <code>true</code> if this date is selectable, <code>false</code> if not.
			@example function showHovered(date, selectable) {
	$('#feedback').text('You are viewing ' + (date ? date.formatDate() : 'nothing'));
 } */

		/** Add a callback when hovering over dates.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker
			@param onHover {CalendarsPickerOnHover} The callback when hovering.
			@example onShow: $.calendarsPicker.hoverCallback(showHovered) */
		hoverCallback: function(onHover) {
			return function(picker, calendar, inst) {
				if ($.isFunction(onHover)) {
					var target = this;
					var renderer = inst.options.renderer;
					picker.find(renderer.daySelector + ' a, ' + renderer.daySelector + ' span').
						hover(function() {
							onHover.apply(target, [$(target).calendarsPicker('retrieveDate', this),
								this.nodeName.toLowerCase() === 'a']);
						},
						function() { onHover.apply(target, []); });
				}
			};
		},

		/** Highlight the entire week when hovering over it.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker
			@param picker {jQuery} The completed datepicker division.
			@param calendar {BaseCalendar} The calendar implementation.
			@param inst {object} The current instance settings.
			@example onShow: $.calendarsPicker.highlightWeek */
		highlightWeek: function(picker, calendar, inst) {
			var target = this;
			var renderer = inst.options.renderer;
			picker.find(renderer.daySelector + ' a, ' + renderer.daySelector + ' span').
				hover(function() {
					$(this).parents('tr').find(renderer.daySelector + ' *').
						addClass(renderer.highlightedClass);
				},
				function() {
					$(this).parents('tr').find(renderer.daySelector + ' *').
						removeClass(renderer.highlightedClass);
				});
		},

		/** Show a status bar with messages.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker
			@param picker {jQuery} The completed datepicker division.
			@param calendar {BaseCalendar} The calendar implementation.
			@param inst {object} The current instance settings.
			@example onShow: $.calendarsPicker.showStatus */
		showStatus: function(picker, calendar, inst) {
			var isTR = (inst.options.renderer.selectedClass === 'ui-state-active');
			var defaultStatus = inst.options.defaultStatus || '&#160;';
			var status = $('<div class="' + (!isTR ? 'calendars-status' :
				'ui-datepicker-status ui-widget-header ui-helper-clearfix ui-corner-all') + '">' +
				defaultStatus + '</div>').
				insertAfter(picker.find('.calendars-month-row:last,.ui-datepicker-row-break:last'));
			picker.find('*[title]').each(function() {
					var title = $(this).attr('title');
					$(this).removeAttr('title').hover(
						function() { status.text(title || defaultStatus); },
						function() { status.text(defaultStatus); });
				});
		},

		/** Allow easier navigation by month.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker
			@param picker {jQuery} The completed datepicker division.
			@param calendar {BaseCalendar} The calendar implementation.
			@param inst {object} The current instance settings.
			@example onShow: $.calendarsPicker.monthNavigation */
		monthNavigation: function(picker, calendar, inst) {
			var target = $(this);
			var isTR = (inst.options.renderer.selectedClass === 'ui-state-active');
			var minDate = inst.curMinDate();
			var maxDate = inst.get('maxDate');
			var year = inst.drawDate.year();
			var html = '<div class="' + (!isTR ? 'calendars-month-nav' : 'ui-datepicker-month-nav') + '">';
			for (var i = 0; i < calendar.monthsInYear(year); i++) {
				var ord = calendar.fromMonthOfYear(year, i + calendar.minMonth) - calendar.minMonth;
				var inRange = ((!minDate || calendar.newDate(year, i + calendar.minMonth,
					calendar.daysInMonth(year, i + calendar.minMonth)).compareTo(minDate) > -1) && (!maxDate ||
					calendar.newDate(year, i + calendar.minMonth, calendar.minDay).compareTo(maxDate) < +1));
				html += '<div>' + (inRange ? '<a href="#" class="jd' +
					calendar.newDate(year, i + calendar.minMonth, calendar.minDay).toJD() + '"' : '<span') +
					' title="' + calendar.local.monthNames[ord] + '">' + calendar.local.monthNamesShort[ord] +
					(inRange ? '</a>' : '</span>') + '</div>';
			}
			html += '</div>';
			$(html).insertAfter(picker.find('div.calendars-nav,div.ui-datepicker-header:first')).
				find('a').click(function() {
					var date = target.calendarsPicker('retrieveDate', this);
					target.calendarsPicker('showMonth', date.year(), date.month());
					return false;
				});
		},

		/** Select an entire week when clicking on a week number.
			Use in conjunction with <code>weekOfYearRenderer</code>.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker
			@param picker {jQuery} The completed datepicker division.
			@param calendar {BaseCalendar} The calendar implementation.
			@param inst {object} The current instance settings.
			@example onShow: $.calendarsPicker.selectWeek */
		selectWeek: function(picker, calendar, inst) {
			var target = $(this);
			picker.find('td.calendars-week span').each(function() {
				$('<a href="javascript:void(0)" class="' +
						this.className + '" title="Select the entire week">' +
						$(this).text() + '</a>').
					click(function() {
						var date = target.calendarsPicker('retrieveDate', this);
						var dates = [date];
						for (var i = 1; i < calendar.daysInWeek(); i++) {
							dates.push(date = date.newDate().add(1, 'd'));
						}
						if (inst.options.rangeSelect) {
							dates.splice(1, dates.length - 2);
						}
						target.calendarsPicker('setDate', dates).calendarsPicker('hide');
					}).
					replaceAll(this);
			});
		},

		/** Select an entire month when clicking on the week header.
			Use in conjunction with <code>weekOfYearRenderer</code>.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker
			@param picker {jQuery} The completed datepicker division.
			@param calendar {BaseCalendar} The calendar implementation.
			@param inst {object} The current instance settings.
			@example onShow: $.calendarsPicker.selectMonth */
		selectMonth: function(picker, calendar, inst) {
			var target = $(this);
			picker.find('th.calendars-week').each(function() {
				$('<a href="javascript:void(0)" title="Select the entire month">' +
						$(this).text() + '</a>').
					click(function() {
						var date = target.calendarsPicker('retrieveDate', $(this).parents('table').
							find('td:not(.calendars-week) *:not(.calendars-other-month)')[0]);
						var dates = [date.day(1)];
						var dim = calendar.daysInMonth(date);
						for (var i = 1; i < dim; i++) {
							dates.push(date = date.newDate().add(1, 'd'));
						}
						if (inst.options.rangeSelect) {
							dates.splice(1, dates.length - 2);
						}
						target.calendarsPicker('setDate', dates).calendarsPicker('hide');
					}).
					appendTo(this);
			});
		},

		/** Select a month only instead of a single day.
			Found in the <code>jquery.calendars.picker.ext.js</code> module.
			@memberof CalendarsPicker
			@param picker {jQuery} The completed datepicker division.
			@param calendar {BaseCalendar} The calendar implementation.
			@param inst {object} The current instance settings.
			@example onShow: $.calendarsPicker.monthOnly */
		monthOnly: function(picker, calendar, inst) {
			var target = $(this);
			var selectMonth = $('<div style="text-align: center;"><button type="button">Select</button></div>').
				insertAfter(picker.find('.calendars-month-row:last,.ui-datepicker-row-break:last')).
				children().click(function() {
					var monthYear = picker.find('.calendars-month-year:first').val().split('/');
					target.calendarsPicker('setDate', calendar.newDate(
						parseInt(monthYear[1], 10), parseInt(monthYear[0], 10), calendar.minDay)).
						calendarsPicker('hide');
				});
			picker.find('.calendars-month-row table,.ui-datepicker-row-break table').remove();
		}
	});

})(jQuery);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpxdWVyeS5jYWxlbmRhcnMucGlja2VyLmpzIiwianF1ZXJ5LmNhbGVuZGFycy5waWNrZXIuZXh0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3eERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImpxdWVyeS5jYWxlbmRhcnMucGlja2VyLmZ1bGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBodHRwOi8va2VpdGgtd29vZC5uYW1lL2NhbGVuZGFycy5odG1sXHJcbiAgIENhbGVuZGFycyBkYXRlIHBpY2tlciBmb3IgalF1ZXJ5IHYyLjAuMS5cclxuICAgV3JpdHRlbiBieSBLZWl0aCBXb29kIChrYndvb2R7YXR9aWluZXQuY29tLmF1KSBBdWd1c3QgMjAwOS5cclxuICAgQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgKGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvbGljZW5jZS5odG1sKSBsaWNlbnNlLiBcclxuICAgUGxlYXNlIGF0dHJpYnV0ZSB0aGUgYXV0aG9yIGlmIHlvdSB1c2UgaXQuICovXHJcblxyXG4oZnVuY3Rpb24oJCkgeyAvLyBIaWRlIHNjb3BlLCBubyAkIGNvbmZsaWN0XHJcblxyXG5cdHZhciBwbHVnaW5OYW1lID0gJ2NhbGVuZGFyc1BpY2tlcic7XHJcblxyXG5cclxuXHQvKiogQ3JlYXRlIHRoZSBjYWxlbmRhcnMgZGF0ZXBpY2tlciBwbHVnaW4uXHJcblx0XHQ8cD5TZXRzIGFuIGlucHV0IGZpZWxkIHRvIHBvcHVwIGEgY2FsZW5kYXIgZm9yIGRhdGUgZW50cnksXHJcblx0XHRcdG9yIGEgPGNvZGU+ZGl2PC9jb2RlPiBvciA8Y29kZT5zcGFuPC9jb2RlPiB0byBzaG93IGFuIGlubGluZSBjYWxlbmRhci48L3A+XHJcblx0XHQ8cD5FeHBlY3RzIEhUTUwgbGlrZTo8L3A+XHJcblx0XHQ8cHJlPiZsdDtpbnB1dCB0eXBlPVwidGV4dFwiPiBvciAmbHQ7ZGl2PiZsdDsvZGl2PjwvcHJlPlxyXG5cdFx0PHA+UHJvdmlkZSBpbmxpbmUgY29uZmlndXJhdGlvbiBsaWtlOjwvcD5cclxuXHRcdDxwcmU+Jmx0O2lucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS1jYWxlbmRhcnNQaWNrZXI9XCJuYW1lOiAndmFsdWUnXCIvPjwvcHJlPlxyXG5cdCBcdEBjbGFzcyBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdEBhdWdtZW50cyBKUVBsdWdpblxyXG5cdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuY2FsZW5kYXJzUGlja2VyKClcclxuICQoc2VsZWN0b3IpLmNhbGVuZGFyc1BpY2tlcih7bWluRGF0ZTogMCwgbWF4RGF0ZTogJysxbSArMXcnfSkgKi9cclxuXHQkLkpRUGx1Z2luLmNyZWF0ZVBsdWdpbih7XHJcblx0XHJcblx0XHQvKiogVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlciAqL1xyXG5cdFx0bmFtZTogcGx1Z2luTmFtZSxcclxuXHRcdFxyXG5cdFx0LyoqIERlZmF1bHQgdGVtcGxhdGUgZm9yIGdlbmVyYXRpbmcgYSBkYXRlcGlja2VyLlxyXG5cdFx0XHRJbnNlcnQgYW55d2hlcmU6XHJcblx0XHRcdDx1bD5cclxuXHRcdFx0PGxpPid7bDEwbjpuYW1lfScgdG8gaW5zZXJ0IGxvY2FsaXNlZCB2YWx1ZSBmb3IgbmFtZSw8L2xpPlxyXG5cdFx0XHQ8bGk+J3tsaW5rOm5hbWV9JyB0byBpbnNlcnQgYSBsaW5rIHRyaWdnZXIgZm9yIGNvbW1hbmQgbmFtZSw8L2xpPlxyXG5cdFx0XHQ8bGk+J3tidXR0b246bmFtZX0nIHRvIGluc2VydCBhIGJ1dHRvbiB0cmlnZ2VyIGZvciBjb21tYW5kIG5hbWUsPC9saT5cclxuXHRcdFx0PGxpPid7cG9wdXA6c3RhcnR9Li4ue3BvcHVwOmVuZH0nIHRvIG1hcmsgYSBzZWN0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBwb3B1cCBkYXRlcGlja2VyIG9ubHksPC9saT5cclxuXHRcdFx0PGxpPid7aW5saW5lOnN0YXJ0fS4uLntpbmxpbmU6ZW5kfScgdG8gbWFyayBhIHNlY3Rpb24gZm9yIGluY2x1c2lvbiBpbiBhbiBpbmxpbmUgZGF0ZXBpY2tlciBvbmx5LjwvbGk+XHJcblx0XHRcdDwvdWw+XHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByb3BlcnR5IHBpY2tlciB7c3RyaW5nfSBPdmVyYWxsIHN0cnVjdHVyZTogJ3ttb250aHN9JyB0byBpbnNlcnQgY2FsZW5kYXIgbW9udGhzLlxyXG5cdFx0XHRAcHJvcGVydHkgbW9udGhSb3cge3N0cmluZ30gT25lIHJvdyBvZiBtb250aHM6ICd7bW9udGhzfScgdG8gaW5zZXJ0IGNhbGVuZGFyIG1vbnRocy5cclxuXHRcdFx0QHByb3BlcnR5IG1vbnRoIHtzdHJpbmd9IEEgc2luZ2xlIG1vbnRoOiAne21vbnRoSGVhZGVyPGVtPjpkYXRlRm9ybWF0PC9lbT59JyB0byBpbnNlcnQgdGhlIG1vbnRoIGhlYWRlciAtXHJcblx0XHRcdFx0XHRcdDxlbT5kYXRlRm9ybWF0PC9lbT4gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICdNTSB5eXl5JyxcclxuXHRcdFx0XHRcdFx0J3t3ZWVrSGVhZGVyfScgdG8gaW5zZXJ0IGEgd2VlayBoZWFkZXIsICd7d2Vla3N9JyB0byBpbnNlcnQgdGhlIG1vbnRoJ3Mgd2Vla3MuXHJcblx0XHRcdEBwcm9wZXJ0eSB3ZWVrSGVhZGVyIHtzdHJpbmd9IEEgd2VlayBoZWFkZXI6ICd7ZGF5c30nIHRvIGluc2VydCBpbmRpdmlkdWFsIGRheSBuYW1lcy5cclxuXHRcdFx0QHByb3BlcnR5IGRheUhlYWRlciB7c3RyaW5nfSBJbmRpdmlkdWFsIGRheSBoZWFkZXI6ICd7ZGF5fScgdG8gaW5zZXJ0IGRheSBuYW1lLlxyXG5cdFx0XHRAcHJvcGVydHkgd2VlayB7c3RyaW5nfSBPbmUgd2VlayBvZiB0aGUgbW9udGg6ICd7ZGF5c30nIHRvIGluc2VydCB0aGUgd2VlaydzIGRheXMsXHJcblx0XHRcdFx0XHRcdCd7d2Vla09mWWVhcn0nIHRvIGluc2VydCB3ZWVrIG9mIHllYXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBkYXkge3N0cmluZ30gQW4gaW5kaXZpZHVhbCBkYXk6ICd7ZGF5fScgdG8gaW5zZXJ0IGRheSB2YWx1ZS5cclxuXHRcdFx0QHByb3BlcnR5IG1vbnRoU2VsZWN0b3Ige3N0cmluZ30galF1ZXJ5IHNlbGVjdG9yLCByZWxhdGl2ZSB0byBwaWNrZXIsIGZvciBhIHNpbmdsZSBtb250aC5cclxuXHRcdFx0QHByb3BlcnR5IGRheVNlbGVjdG9yIHtzdHJpbmd9IGpRdWVyeSBzZWxlY3RvciwgcmVsYXRpdmUgdG8gcGlja2VyLCBmb3IgaW5kaXZpZHVhbCBkYXlzLlxyXG5cdFx0XHRAcHJvcGVydHkgcnRsQ2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIHJpZ2h0LXRvLWxlZnQgKFJUTCkgbGFuZ3VhZ2VzLlxyXG5cdFx0XHRAcHJvcGVydHkgbXVsdGlDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgbXVsdGktbW9udGggZGF0ZXBpY2tlcnMuXHJcblx0XHRcdEBwcm9wZXJ0eSBkZWZhdWx0Q2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIHNlbGVjdGFibGUgZGF0ZXMuXHJcblx0XHRcdEBwcm9wZXJ0eSBzZWxlY3RlZENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZXMuXHJcblx0XHRcdEBwcm9wZXJ0eSBoaWdobGlnaHRlZENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBoaWdobGlnaHRlZCBkYXRlcy5cclxuXHRcdFx0QHByb3BlcnR5IHRvZGF5Q2xhc3Mge3N0cmluZ30gQ2xhc3MgZm9yIHRvZGF5LlxyXG5cdFx0XHRAcHJvcGVydHkgb3RoZXJNb250aENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBkYXlzIGZyb20gb3RoZXIgbW9udGhzLlxyXG5cdFx0XHRAcHJvcGVydHkgd2Vla2VuZENsYXNzIHtzdHJpbmd9IENsYXNzIGZvciBkYXlzIG9uIHdlZWtlbmRzLlxyXG5cdFx0XHRAcHJvcGVydHkgY29tbWFuZENsYXNzIHtzdHJpbmd9IENsYXNzIHByZWZpeCBmb3IgY29tbWFuZHMuXHJcblx0XHRcdEBwcm9wZXJ0eSBjb21tYW5kQnV0dG9uQ2xhc3Mge3N0cmluZ30gRXh0cmEgY2xhc3MoZXMpIGZvciBjb21tYW5kcyB0aGF0IGFyZSBidXR0b25zLlxyXG5cdFx0XHRAcHJvcGVydHkgY29tbWFuZExpbmtDbGFzcyB7c3RyaW5nfSBFeHRyYSBjbGFzcyhlcykgZm9yIGNvbW1hbmRzIHRoYXQgYXJlIGxpbmtzLlxyXG5cdFx0XHRAcHJvcGVydHkgZGlzYWJsZWRDbGFzcyB7c3RyaW5nfSBDbGFzcyBmb3IgZGlzYWJsZWQgY29tbWFuZHMuICovXHJcblx0XHRkZWZhdWx0UmVuZGVyZXI6IHtcclxuXHRcdFx0cGlja2VyOiAnPGRpdiBjbGFzcz1cImNhbGVuZGFyc1wiPicgK1xyXG5cdFx0XHQnPGRpdiBjbGFzcz1cImNhbGVuZGFycy1uYXZcIj57bGluazpwcmV2fXtsaW5rOnRvZGF5fXtsaW5rOm5leHR9PC9kaXY+e21vbnRoc30nICtcclxuXHRcdFx0J3twb3B1cDpzdGFydH08ZGl2IGNsYXNzPVwiY2FsZW5kYXJzLWN0cmxcIj57bGluazpjbGVhcn17bGluazpjbG9zZX08L2Rpdj57cG9wdXA6ZW5kfScgK1xyXG5cdFx0XHQnPGRpdiBjbGFzcz1cImNhbGVuZGFycy1jbGVhci1maXhcIj48L2Rpdj48L2Rpdj4nLFxyXG5cdFx0XHRtb250aFJvdzogJzxkaXYgY2xhc3M9XCJjYWxlbmRhcnMtbW9udGgtcm93XCI+e21vbnRoc308L2Rpdj4nLFxyXG5cdFx0XHRtb250aDogJzxkaXYgY2xhc3M9XCJjYWxlbmRhcnMtbW9udGhcIj48ZGl2IGNsYXNzPVwiY2FsZW5kYXJzLW1vbnRoLWhlYWRlclwiPnttb250aEhlYWRlcn08L2Rpdj4nICtcclxuXHRcdFx0Jzx0YWJsZT48dGhlYWQ+e3dlZWtIZWFkZXJ9PC90aGVhZD48dGJvZHk+e3dlZWtzfTwvdGJvZHk+PC90YWJsZT48L2Rpdj4nLFxyXG5cdFx0XHR3ZWVrSGVhZGVyOiAnPHRyPntkYXlzfTwvdHI+JyxcclxuXHRcdFx0ZGF5SGVhZGVyOiAnPHRoPntkYXl9PC90aD4nLFxyXG5cdFx0XHR3ZWVrOiAnPHRyPntkYXlzfTwvdHI+JyxcclxuXHRcdFx0ZGF5OiAnPHRkPntkYXl9PC90ZD4nLFxyXG5cdFx0XHRtb250aFNlbGVjdG9yOiAnLmNhbGVuZGFycy1tb250aCcsXHJcblx0XHRcdGRheVNlbGVjdG9yOiAndGQnLFxyXG5cdFx0XHRydGxDbGFzczogJ2NhbGVuZGFycy1ydGwnLFxyXG5cdFx0XHRtdWx0aUNsYXNzOiAnY2FsZW5kYXJzLW11bHRpJyxcclxuXHRcdFx0ZGVmYXVsdENsYXNzOiAnJyxcclxuXHRcdFx0c2VsZWN0ZWRDbGFzczogJ2NhbGVuZGFycy1zZWxlY3RlZCcsXHJcblx0XHRcdGhpZ2hsaWdodGVkQ2xhc3M6ICdjYWxlbmRhcnMtaGlnaGxpZ2h0JyxcclxuXHRcdFx0dG9kYXlDbGFzczogJ2NhbGVuZGFycy10b2RheScsXHJcblx0XHRcdG90aGVyTW9udGhDbGFzczogJ2NhbGVuZGFycy1vdGhlci1tb250aCcsXHJcblx0XHRcdHdlZWtlbmRDbGFzczogJ2NhbGVuZGFycy13ZWVrZW5kJyxcclxuXHRcdFx0Y29tbWFuZENsYXNzOiAnY2FsZW5kYXJzLWNtZCcsXHJcblx0XHRcdGNvbW1hbmRCdXR0b25DbGFzczogJycsXHJcblx0XHRcdGNvbW1hbmRMaW5rQ2xhc3M6ICcnLFxyXG5cdFx0XHRkaXNhYmxlZENsYXNzOiAnY2FsZW5kYXJzLWRpc2FibGVkJ1xyXG5cdFx0fSxcclxuXHRcclxuXHRcdC8qKiBDb21tYW5kIGFjdGlvbnMgdGhhdCBtYXkgYmUgYWRkZWQgdG8gYSBsYXlvdXQgYnkgbmFtZS5cclxuXHRcdFx0PHVsPlxyXG5cdFx0XHQ8bGk+cHJldiAtIFNob3cgdGhlIHByZXZpb3VzIG1vbnRoIChiYXNlZCBvbiA8Y29kZT5tb250aHNUb1N0ZXA8L2NvZGU+IG9wdGlvbikgLSA8ZW0+UGFnZVVwPC9lbT48L2xpPlxyXG5cdFx0XHQ8bGk+cHJldkp1bXAgLSBTaG93IHRoZSBwcmV2aW91cyB5ZWFyIChiYXNlZCBvbiA8Y29kZT5tb250aHNUb0p1bXA8L2NvZGU+IG9wdGlvbikgLSA8ZW0+Q3RybCtQYWdlVXA8L2VtPjwvbGk+XHJcblx0XHRcdDxsaT5uZXh0IC0gU2hvdyB0aGUgbmV4dCBtb250aCAoYmFzZWQgb24gPGNvZGU+bW9udGhzVG9TdGVwPC9jb2RlPiBvcHRpb24pIC0gPGVtPlBhZ2VEb3duPC9lbT48L2xpPlxyXG5cdFx0XHQ8bGk+bmV4dEp1bXAgLSBTaG93IHRoZSBuZXh0IHllYXIgKGJhc2VkIG9uIDxjb2RlPm1vbnRoc1RvSnVtcDwvY29kZT4gb3B0aW9uKSAtIDxlbT5DdHJsK1BhZ2VEb3duPC9lbT48L2xpPlxyXG5cdFx0XHQ8bGk+Y3VycmVudCAtIFNob3cgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBtb250aCBvciB0b2RheSdzIGlmIG5vbmUgc2VsZWN0ZWQgLSA8ZW0+Q3RybCtIb21lPC9lbT48L2xpPlxyXG5cdFx0XHQ8bGk+dG9kYXkgLSBTaG93IHRvZGF5J3MgbW9udGggLSA8ZW0+Q3RybCtIb21lPC9lbT48L2xpPlxyXG5cdFx0XHQ8bGk+Y2xlYXIgLSBFcmFzZSB0aGUgZGF0ZSBhbmQgY2xvc2UgdGhlIGRhdGVwaWNrZXIgcG9wdXAgLSA8ZW0+Q3RybCtFbmQ8L2VtPjwvbGk+XHJcblx0XHRcdDxsaT5jbG9zZSAtIENsb3NlIHRoZSBkYXRlcGlja2VyIHBvcHVwIC0gPGVtPkVzYzwvZW0+PC9saT5cclxuXHRcdFx0PGxpPnByZXZXZWVrIC0gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBwcmV2aW91cyB3ZWVrIC0gPGVtPkN0cmwrVXA8L2VtPjwvbGk+XHJcblx0XHRcdDxsaT5wcmV2RGF5IC0gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBwcmV2aW91cyBkYXkgLSA8ZW0+Q3RybCtMZWZ0PC9lbT48L2xpPlxyXG5cdFx0XHQ8bGk+bmV4dERheSAtIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgbmV4dCBkYXkgLSA8ZW0+Q3RybCtSaWdodDwvZW0+PC9saT5cclxuXHRcdFx0PGxpPm5leHRXZWVrIC0gTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBuZXh0IHdlZWsgLSA8ZW0+Q3RybCtEb3duPC9lbT48L2xpPlxyXG5cdFx0XHQ8L3VsPlxyXG5cdFx0XHRUaGUgY29tbWFuZCBuYW1lIGlzIHRoZSBrZXkgbmFtZSBhbmQgaXMgdXNlZCB0byBhZGQgdGhlIGNvbW1hbmQgdG8gYSBsYXlvdXRcclxuXHRcdFx0d2l0aCAne2J1dHRvbjpuYW1lfScgb3IgJ3tsaW5rOm5hbWV9Jy4gRWFjaCBoYXMgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcm9wZXJ0eSB0ZXh0IHtzdHJpbmd9IFRoZSBmaWVsZCBpbiB0aGUgcmVnaW9uYWwgc2V0dGluZ3MgZm9yIHRoZSBkaXNwbGF5ZWQgdGV4dC5cclxuXHRcdFx0QHByb3BlcnR5IHN0YXR1cyB7c3RyaW5nfSBUaGUgZmllbGQgaW4gdGhlIHJlZ2lvbmFsIHNldHRpbmdzIGZvciB0aGUgc3RhdHVzIHRleHQuXHJcblx0XHRcdEBwcm9wZXJ0eSBrZXlzdHJva2Uge29iamVjdH0gVGhlIGtleXN0cm9rZSB0byB0cmlnZ2VyIHRoZSBhY3Rpb24sIHdpdGggYXR0cmlidXRlczpcclxuXHRcdFx0XHQ8Y29kZT5rZXlDb2RlPC9jb2RlPiB7bnVtYmVyfSB0aGUgY29kZSBmb3IgdGhlIGtleXN0cm9rZSxcclxuXHRcdFx0XHQ8Y29kZT5jdHJsS2V5PC9jb2RlPiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgPGVtPkN0cmw8L2VtPiBpcyByZXF1aXJlZCxcclxuXHRcdFx0XHQ8Y29kZT5hbHRLZXk8L2NvZGU+IHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiA8ZW0+QWx0PC9lbT4gaXMgcmVxdWlyZWQsXHJcblx0XHRcdFx0PGNvZGU+c2hpZnRLZXk8L2NvZGU+IHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiA8ZW0+U2hpZnQ8L2VtPiBpcyByZXF1aXJlZC5cclxuXHRcdFx0QHByb3BlcnR5IGVuYWJsZWQge0NhbGVuZGFyc1BpY2tlckNvbW1hbmRFbmFibGVkfSBUaGUgZnVuY3Rpb24gdGhhdCBpbmRpY2F0ZXMgdGhlIGNvbW1hbmQgaXMgZW5hYmxlZC5cclxuXHRcdFx0QHByb3BlcnR5IGRhdGUge0NhbGVuZGFyc1BpY2tlckNvbW1hbmREYXRlfSBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBkYXRlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFjdGlvbi5cclxuXHRcdFx0QHByb3BlcnR5IGFjdGlvbiB7Q2FsZW5kYXJzUGlja2VyQ29tbWFuZEFjdGlvbn0gVGhlIGZ1bmN0aW9uIHRoYXQgaW1wbGVtZW50cyB0aGUgYWN0aW9uLiAqL1xyXG5cdFx0Y29tbWFuZHM6IHtcclxuXHRcdFx0cHJldjoge3RleHQ6ICdwcmV2VGV4dCcsIHN0YXR1czogJ3ByZXZTdGF0dXMnLCAvLyBQcmV2aW91cyBtb250aFxyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDMzfSwgLy8gUGFnZSB1cFxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5jdXJNaW5EYXRlKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCFtaW5EYXRlIHx8IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0XHRhZGQoMSAtIGluc3Qub3B0aW9ucy5tb250aHNUb1N0ZXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxyXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSkuYWRkKC0xLCAnZCcpLmNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpOyB9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHJldHVybiBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdFx0YWRkKC1pbnN0Lm9wdGlvbnMubW9udGhzVG9TdGVwIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cclxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0cGx1Z2luLmNoYW5nZU1vbnRoKHRoaXMsIC1pbnN0Lm9wdGlvbnMubW9udGhzVG9TdGVwKTsgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRwcmV2SnVtcDoge3RleHQ6ICdwcmV2SnVtcFRleHQnLCBzdGF0dXM6ICdwcmV2SnVtcFN0YXR1cycsIC8vIFByZXZpb3VzIHllYXJcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzMywgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBQYWdlIHVwXHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmN1ck1pbkRhdGUoKTtcclxuXHRcdFx0XHRcdHJldHVybiAoIW1pbkRhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRcdGFkZCgxIC0gaW5zdC5vcHRpb25zLm1vbnRoc1RvSnVtcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXHJcblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KS5hZGQoLTEsICdkJykuY29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSk7IH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0XHRhZGQoLWluc3Qub3B0aW9ucy5tb250aHNUb0p1bXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxyXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSk7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHRwbHVnaW4uY2hhbmdlTW9udGgodGhpcywgLWluc3Qub3B0aW9ucy5tb250aHNUb0p1bXApOyB9XHJcblx0XHRcdH0sXHJcblx0XHRcdG5leHQ6IHt0ZXh0OiAnbmV4dFRleHQnLCBzdGF0dXM6ICduZXh0U3RhdHVzJywgLy8gTmV4dCBtb250aFxyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM0fSwgLy8gUGFnZSBkb3duXHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuICghbWF4RGF0ZSB8fCBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5tb250aHNUb1N0ZXAgLSBpbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpLlxyXG5cdFx0XHRcdFx0XHRkYXkoaW5zdC5vcHRpb25zLmNhbGVuZGFyLm1pbkRheSkuY29tcGFyZVRvKG1heERhdGUpICE9PSArMSk7IH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0XHRhZGQoaW5zdC5vcHRpb25zLm1vbnRoc1RvU3RlcCAtIGluc3Qub3B0aW9ucy5tb250aHNPZmZzZXQsICdtJykuXHJcblx0XHRcdFx0XHRcdGRheShpbnN0Lm9wdGlvbnMuY2FsZW5kYXIubWluRGF5KTsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHBsdWdpbi5jaGFuZ2VNb250aCh0aGlzLCBpbnN0Lm9wdGlvbnMubW9udGhzVG9TdGVwKTsgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRuZXh0SnVtcDoge3RleHQ6ICduZXh0SnVtcFRleHQnLCBzdGF0dXM6ICduZXh0SnVtcFN0YXR1cycsIC8vIE5leHQgeWVhclxyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM0LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIFBhZ2UgZG93blxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcclxuXHRcdFx0XHRcdHJldHVybiAoIW1heERhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRcdGFkZChpbnN0Lm9wdGlvbnMubW9udGhzVG9KdW1wIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cclxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpLmNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpO1x0fSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRcdGFkZChpbnN0Lm9wdGlvbnMubW9udGhzVG9KdW1wIC0gaW5zdC5vcHRpb25zLm1vbnRoc09mZnNldCwgJ20nKS5cclxuXHRcdFx0XHRcdFx0ZGF5KGluc3Qub3B0aW9ucy5jYWxlbmRhci5taW5EYXkpOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0cGx1Z2luLmNoYW5nZU1vbnRoKHRoaXMsIGluc3Qub3B0aW9ucy5tb250aHNUb0p1bXApOyB9XHJcblx0XHRcdH0sXHJcblx0XHRcdGN1cnJlbnQ6IHt0ZXh0OiAnY3VycmVudFRleHQnLCBzdGF0dXM6ICdjdXJyZW50U3RhdHVzJywgLy8gQ3VycmVudCBtb250aFxyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM2LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIEhvbWVcclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0XHRcdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuY3VyTWluRGF0ZSgpO1xyXG5cdFx0XHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xyXG5cdFx0XHRcdFx0dmFyIGN1ckRhdGUgPSBpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCFtaW5EYXRlIHx8IGN1ckRhdGUuY29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSkgJiZcclxuXHRcdFx0XHRcdFx0KCFtYXhEYXRlIHx8IGN1ckRhdGUuY29tcGFyZVRvKG1heERhdGUpICE9PSArMSk7IH0sXHJcblx0XHRcdFx0ZGF0ZTogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGluc3Quc2VsZWN0ZWREYXRlc1swXSB8fCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIudG9kYXkoKTsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHZhciBjdXJEYXRlID0gaW5zdC5zZWxlY3RlZERhdGVzWzBdIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpO1xyXG5cdFx0XHRcdFx0cGx1Z2luLnNob3dNb250aCh0aGlzLCBjdXJEYXRlLnllYXIoKSwgY3VyRGF0ZS5tb250aCgpKTsgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR0b2RheToge3RleHQ6ICd0b2RheVRleHQnLCBzdGF0dXM6ICd0b2RheVN0YXR1cycsIC8vIFRvZGF5J3MgbW9udGhcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzNiwgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBIb21lXHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmN1ck1pbkRhdGUoKTtcclxuXHRcdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcclxuXHRcdFx0XHRcdHJldHVybiAoIW1pbkRhdGUgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkuY29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSkgJiZcclxuXHRcdFx0XHRcdFx0KCFtYXhEYXRlIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpLmNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpOyB9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkgeyBwbHVnaW4uc2hvd01vbnRoKHRoaXMpOyB9XHJcblx0XHRcdH0sXHJcblx0XHRcdGNsZWFyOiB7dGV4dDogJ2NsZWFyVGV4dCcsIHN0YXR1czogJ2NsZWFyU3RhdHVzJywgLy8gQ2xlYXIgdGhlIGRhdGVwaWNrZXJcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzNSwgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBFbmRcclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiB0cnVlOyB9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIG51bGw7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5jbGVhcih0aGlzKTsgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRjbG9zZToge3RleHQ6ICdjbG9zZVRleHQnLCBzdGF0dXM6ICdjbG9zZVN0YXR1cycsIC8vIENsb3NlIHRoZSBkYXRlcGlja2VyXHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogMjd9LCAvLyBFc2NhcGVcclxuXHRcdFx0XHRlbmFibGVkOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiB0cnVlOyB9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIG51bGw7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5oaWRlKHRoaXMpOyB9XHJcblx0XHRcdH0sXHJcblx0XHRcdHByZXZXZWVrOiB7dGV4dDogJ3ByZXZXZWVrVGV4dCcsIHN0YXR1czogJ3ByZXZXZWVrU3RhdHVzJywgLy8gUHJldmlvdXMgd2Vla1xyXG5cdFx0XHRcdGtleXN0cm9rZToge2tleUNvZGU6IDM4LCBjdHJsS2V5OiB0cnVlfSwgLy8gQ3RybCArIFVwXHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmN1ck1pbkRhdGUoKTtcclxuXHRcdFx0XHRcdHJldHVybiAoIW1pbkRhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRcdGFkZCgtaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRheXNJbldlZWsoKSwgJ2QnKS5jb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKTsgfSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5cclxuXHRcdFx0XHRcdGFkZCgtaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRheXNJbldlZWsoKSwgJ2QnKTsgfSxcclxuXHRcdFx0XHRhY3Rpb246IGZ1bmN0aW9uKGluc3QpIHsgcGx1Z2luLmNoYW5nZURheSh0aGlzLCAtaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRheXNJbldlZWsoKSk7IH1cclxuXHRcdFx0fSxcclxuXHRcdFx0cHJldkRheToge3RleHQ6ICdwcmV2RGF5VGV4dCcsIHN0YXR1czogJ3ByZXZEYXlTdGF0dXMnLCAvLyBQcmV2aW91cyBkYXlcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzNywgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBMZWZ0XHJcblx0XHRcdFx0ZW5hYmxlZDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmN1ck1pbkRhdGUoKTtcclxuXHRcdFx0XHRcdHJldHVybiAoIW1pbkRhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKC0xLCAnZCcpLlxyXG5cdFx0XHRcdFx0XHRjb21wYXJlVG8obWluRGF0ZSkgIT09IC0xKTsgfSxcclxuXHRcdFx0XHRkYXRlOiBmdW5jdGlvbihpbnN0KSB7IHJldHVybiBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5hZGQoLTEsICdkJyk7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5jaGFuZ2VEYXkodGhpcywgLTEpOyB9XHJcblx0XHRcdH0sXHJcblx0XHRcdG5leHREYXk6IHt0ZXh0OiAnbmV4dERheVRleHQnLCBzdGF0dXM6ICduZXh0RGF5U3RhdHVzJywgLy8gTmV4dCBkYXlcclxuXHRcdFx0XHRrZXlzdHJva2U6IHtrZXlDb2RlOiAzOSwgY3RybEtleTogdHJ1ZX0sIC8vIEN0cmwgKyBSaWdodFxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcclxuXHRcdFx0XHRcdHJldHVybiAoIW1heERhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKDEsICdkJykuXHJcblx0XHRcdFx0XHRcdGNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpOyB9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLmFkZCgxLCAnZCcpOyB9LFxyXG5cdFx0XHRcdGFjdGlvbjogZnVuY3Rpb24oaW5zdCkgeyBwbHVnaW4uY2hhbmdlRGF5KHRoaXMsIDEpOyB9XHJcblx0XHRcdH0sXHJcblx0XHRcdG5leHRXZWVrOiB7dGV4dDogJ25leHRXZWVrVGV4dCcsIHN0YXR1czogJ25leHRXZWVrU3RhdHVzJywgLy8gTmV4dCB3ZWVrXHJcblx0XHRcdFx0a2V5c3Ryb2tlOiB7a2V5Q29kZTogNDAsIGN0cmxLZXk6IHRydWV9LCAvLyBDdHJsICsgRG93blxyXG5cdFx0XHRcdGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcclxuXHRcdFx0XHRcdHJldHVybiAoIW1heERhdGUgfHwgaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuXHJcblx0XHRcdFx0XHRcdGFkZChpbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZGF5c0luV2VlaygpLCAnZCcpLmNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpOyB9LFxyXG5cdFx0XHRcdGRhdGU6IGZ1bmN0aW9uKGluc3QpIHsgcmV0dXJuIGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpLlxyXG5cdFx0XHRcdFx0YWRkKGluc3Qub3B0aW9ucy5jYWxlbmRhci5kYXlzSW5XZWVrKCksICdkJyk7IH0sXHJcblx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbihpbnN0KSB7IHBsdWdpbi5jaGFuZ2VEYXkodGhpcywgaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRheXNJbldlZWsoKSk7IH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHdoZXRoZXIgYSBjb21tYW5kIGlzIGVuYWJsZWQuXHJcblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJDb21tYW5kRW5hYmxlZFxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBjb21tYW5kIGlzIGVuYWJsZWQsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QuXHJcblx0XHRcdEBleGFtcGxlIGVuYWJsZWQ6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRyZXR1cm4gISFpbnN0LmN1ck1pbkRhdGUoKTtcclxuIH0gKi9cclxuXHJcblx0XHQvKiogQ2FsY3VsYXRlIHRoZSByZXByZXNlbnRhdGl2ZSBkYXRlIGZvciBhIGNvbW1hbmQuXHJcblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJDb21tYW5kRGF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHJldHVybiB7Q0RhdGV9IEEgZGF0ZSBhcHByb3ByaWF0ZSBmb3IgdGhpcyBjb21tYW5kLlxyXG5cdFx0XHRAZXhhbXBsZSBkYXRlOiBmdW5jdGlvbihpbnN0KSB7XHJcblx0cmV0dXJuIGluc3QuY3VyTWluRGF0ZSgpO1xyXG4gfSAqL1xyXG5cclxuXHRcdC8qKiBQZXJmb3JtIHRoZSBhY3Rpb24gZm9yIGEgY29tbWFuZC5cclxuXHRcdFx0QGNhbGxiYWNrIENhbGVuZGFyc1BpY2tlckNvbW1hbmRBY3Rpb25cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBleGFtcGxlIGRhdGU6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHQkLmRhdGVwaWNrLnNldERhdGUoaW5zdC5lbGVtLCBpbnN0LmN1ck1pbkRhdGUoKSk7XHJcbiB9ICovXHJcblxyXG5cdFx0LyoqIENhbGN1bGF0ZSB0aGUgd2VlayBvZiB0aGUgeWVhciBmb3IgYSBkYXRlLlxyXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyQ2FsY3VsYXRlV2Vla1xyXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV9IFRoZSBkYXRlIHRvIGV2YWx1YXRlLlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJ9IFRoZSB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG5cdFx0XHRAZXhhbXBsZSBjYWxjdWxhdGVXZWVrOiBmdW5jdGlvbihkYXRlKSB7XHJcblx0dmFyIHN0YXJ0WWVhciA9ICQuY2FsZW5kYXJzLm5ld0RhdGUoZGF0ZS55ZWFyKCksIDEsIDEpO1xyXG5cdHJldHVybiBNYXRoLmZsb29yKChkYXRlLmRheU9mWWVhcigpIC0gc3RhcnRZZWFyLmRheU9mWWVhcigpKSAvIDcpICsgMTtcclxuIH0gKi9cclxuXHJcblx0XHQvKiogUHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCBhbiBpbmRpdmlkdWFsIGRhdGUgc2hvd24gaW4gdGhlIGNhbGVuZGFyLlxyXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyT25EYXRlXHJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIGRhdGUgdG8gZXZhbHVhdGUuXHJcblx0XHRcdEByZXR1cm4ge29iamVjdH0gSW5mb3JtYXRpb24gYWJvdXQgdGhhdCBkYXRlLCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGFib3ZlLlxyXG5cdFx0XHRAcHJvcGVydHkgc2VsZWN0YWJsZSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBkYXRlIGNhbiBiZSBzZWxlY3RlZC5cclxuXHRcdFx0QHByb3BlcnR5IGRhdGVDbGFzcyB7c3RyaW5nfSBDbGFzcyhlcykgdG8gYmUgYXBwbGllZCB0byB0aGUgZGF0ZS5cclxuXHRcdFx0QHByb3BlcnR5IGNvbnRlbnQge3N0cmluZ30gVGhlIGRhdGUgY2VsbCBjb250ZW50LlxyXG5cdFx0XHRAcHJvcGVydHkgdG9vbHRpcCB7c3RyaW5nfSBBIHBvcHVwIHRvb2x0aXAgZm9yIHRoZSBkYXRlLlxyXG5cdFx0XHRAZXhhbXBsZSBvbkRhdGU6IGZ1bmN0aW9uKGRhdGUpIHtcclxuXHRyZXR1cm4ge3NlbGVjdGFibGU6IGRhdGUuZGF5KCkgPiAwICYmIGRhdGUuZGF5KCkgJmx0OyA1LFxyXG5cdFx0ZGF0ZUNsYXNzOiBkYXRlLmRheSgpID09PSA0ID8gJ2xhc3QtZGF5JyA6ICcnfTtcclxuIH0gKi9cclxuXHJcblx0XHQvKiogVXBkYXRlIHRoZSBkYXRlcGlja2VyIGRpc3BsYXkuXHJcblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJPblNob3dcclxuXHRcdFx0QHBhcmFtIHBpY2tlciB7alF1ZXJ5fSBUaGUgZGF0ZXBpY2tlciA8Y29kZT5kaXY8L2NvZGU+IHRvIGJlIHNob3duLlxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QGV4YW1wbGUgb25TaG93OiBmdW5jdGlvbihwaWNrZXIsIGluc3QpIHtcclxuXHRwaWNrZXIuYXBwZW5kKCcmbHQ7YnV0dG9uIHR5cGU9XCJidXR0b25cIj5IaSZsdDsvYnV0dG9uPicpLlxyXG5cdFx0ZmluZCgnYnV0dG9uOmxhc3QnKS5jbGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0YWxlcnQoJ0hpIScpO1xyXG5cdFx0fSk7XHJcbiB9ICovXHJcblxyXG5cdFx0LyoqIFJlYWN0IHRvIG5hdmlnYXRpbmcgdGhyb3VnaCB0aGUgbW9udGhzL3llYXJzLlxyXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyT25DaGFuZ2VNb250aFllYXJcclxuXHRcdFx0QHBhcmFtIHllYXIge251bWJlcn0gVGhlIG5ldyB5ZWFyLlxyXG5cdFx0XHRAcGFyYW0gbW9udGgge251bWJlcn0gVGhlIG5ldyBtb250aCAoMSB0byAxMikuXHJcblx0XHRcdEBleGFtcGxlIG9uQ2hhbmdlTW9udGhZZWFyOiBmdW5jdGlvbih5ZWFyLCBtb250aCkge1xyXG5cdGFsZXJ0KCdOb3cgaW4gJyArIG1vbnRoICsgJy8nICsgeWVhcik7XHJcbiB9ICovXHJcblx0XHRcdFxyXG5cdFx0LyoqIERhdGVwaWNrZXIgb24gc2VsZWN0IGNhbGxiYWNrLlxyXG5cdFx0XHRUcmlnZ2VyZWQgd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWQuXHJcblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJPblNlbGVjdFxyXG5cdFx0XHRAcGFyYW0gZGF0ZXMge0NEYXRlW119IFRoZSBzZWxlY3RlZCBkYXRlKHMpLlxyXG5cdFx0XHRAZXhhbXBsZSBvblNlbGVjdDogZnVuY3Rpb24oZGF0ZXMpIHtcclxuIFx0YWxlcnQoJ1NlbGVjdGVkICcgKyBkYXRlcyk7XHJcbiB9ICovXHJcblx0XHRcdFxyXG5cdFx0LyoqIERhdGVwaWNrZXIgb24gY2xvc2UgY2FsbGJhY2suXHJcblx0XHRcdFRyaWdnZXJlZCB3aGVuIGEgcG9wdXAgY2FsZW5kYXIgaXMgY2xvc2VkLlxyXG5cdFx0XHRAY2FsbGJhY2sgQ2FsZW5kYXJzUGlja2VyT25DbG9zZVxyXG5cdFx0XHRAcGFyYW0gZGF0ZXMge0NEYXRlW119IFRoZSBzZWxlY3RlZCBkYXRlKHMpLlxyXG5cdFx0XHRAZXhhbXBsZSBvbkNsb3NlOiBmdW5jdGlvbihkYXRlcykge1xyXG4gXHRhbGVydCgnU2VsZWN0ZWQgJyArIGRhdGVzKTtcclxuIH0gKi9cclxuXHRcdFxyXG5cdFx0LyoqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHRoZSBwbHVnaW4uXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByb3BlcnR5IFtjYWxlbmRhcj0kLmNhbGVuZGFycy5pbnN0YW5jZSgpXSB7Q2FsZW5kYXJ9IFRoZSBjYWxlbmRhciBmb3IgdGhpcyBkYXRlcGlja2VyLlxyXG5cdFx0XHRAcHJvcGVydHkgW3BpY2tlckNsYXNzPScnXSB7c3RyaW5nfSBDU1MgY2xhc3MgdG8gYWRkIHRvIHRoaXMgaW5zdGFuY2Ugb2YgdGhlIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBwcm9wZXJ0eSBbc2hvd09uRm9jdXM9dHJ1ZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGZvciBwb3B1cCBvbiBmb2N1cywgPGNvZGU+ZmFsc2U8L2NvZGU+IGZvciBub3QuXHJcblx0XHRcdEBwcm9wZXJ0eSBbc2hvd1RyaWdnZXI9bnVsbF0ge3N0cmluZ3xFbGVtZW50fGpRdWVyeX0gRWxlbWVudCB0byBiZSBjbG9uZWQgZm9yIGEgdHJpZ2dlciwgPGNvZGU+bnVsbDwvY29kZT4gZm9yIG5vbmUuXHJcblx0XHRcdEBwcm9wZXJ0eSBbc2hvd0FuaW09J3Nob3cnXSB7c3RyaW5nfSBOYW1lIG9mIGpRdWVyeSBhbmltYXRpb24gZm9yIHBvcHVwLCAnJyBmb3Igbm8gYW5pbWF0aW9uLlxyXG5cdFx0XHRAcHJvcGVydHkgW3Nob3dPcHRpb25zPW51bGxdIHtvYmplY3R9IE9wdGlvbnMgZm9yIGVuaGFuY2VkIGFuaW1hdGlvbnMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbc2hvd1NwZWVkPSdub3JtYWwnXSB7c3RyaW5nfSBEdXJhdGlvbiBvZiBkaXNwbGF5L2Nsb3N1cmUuXHJcblx0XHRcdEBwcm9wZXJ0eSBbcG9wdXBDb250YWluZXI9bnVsbF0ge3N0cmluZ3xFbGVtZW50fGpRdWVyeX0gVGhlIGVsZW1lbnQgdG8gd2hpY2ggYSBwb3B1cCBjYWxlbmRhciBpcyBhZGRlZCwgPGNvZGU+bnVsbDwvY29kZT4gZm9yIGJvZHkuXHJcblx0XHRcdEBwcm9wZXJ0eSBbYWxpZ25tZW50PSdib3R0b20nXSB7c3RyaW5nfSBBbGlnbm1lbnQgb2YgcG9wdXAgLSB3aXRoIG5vbWluYXRlZCBjb3JuZXIgb2YgaW5wdXQ6XHJcblx0XHRcdFx0XHRcdCd0b3AnIG9yICdib3R0b20nIGFsaWducyBkZXBlbmRpbmcgb24gbGFuZ3VhZ2UgZGlyZWN0aW9uLFxyXG5cdFx0XHRcdFx0XHQndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0Jy5cclxuXHRcdFx0QHByb3BlcnR5IFtmaXhlZFdlZWtzPWZhbHNlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gYWx3YXlzIHNob3cgNiB3ZWVrcywgPGNvZGU+ZmFsc2U8L2NvZGU+IHRvIG9ubHkgc2hvdyBhcyBtYW55IGFzIGFyZSBuZWVkZWQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbZmlyc3REYXk9bnVsbF0ge251bWJlcn0gRmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCAwID0gU3VuZGF5LCAxID0gTW9uZGF5LCBldGMuLCA8Y29kZT5udWxsPC9jb2RlPiBmb3IgPGNvZGU+Y2FsZW5kYXI8L2NvZGU+IGRlZmF1bHQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbY2FsY3VsYXRlV2Vlaz1udWxsXSB7Q2FsZW5kYXJzUGlja2VyQ2FsY3VsYXRlV2Vla30gQ2FsY3VsYXRlIHdlZWsgb2YgdGhlIHllYXIgZnJvbSBhIGRhdGUsIDxjb2RlPm51bGw8L2NvZGU+IGZvciA8Y29kZT5jYWxlbmRhcjwvY29kZT4gZGVmYXVsdC5cclxuXHRcdFx0QHByb3BlcnR5IFttb250aHNUb1Nob3c9MV0ge251bWJlcnxudW1iZXJbXX0gSG93IG1hbnkgbW9udGhzIHRvIHNob3csIGNvbHMgb3IgW3Jvd3MsIGNvbHNdLlxyXG5cdFx0XHRAcHJvcGVydHkgW21vbnRoc09mZnNldD0wXSB7bnVtYmVyfSBIb3cgbWFueSBtb250aHMgdG8gb2Zmc2V0IHRoZSBwcmltYXJ5IG1vbnRoIGJ5O1xyXG5cdFx0XHRcdFx0XHRtYXkgYmUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBkYXRlIGFuZCByZXR1cm5zIHRoZSBvZmZzZXQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhzVG9TdGVwPTFdIHtudW1iZXJ9IEhvdyBtYW55IG1vbnRocyB0byBtb3ZlIHdoZW4gcHJldi9uZXh0IGNsaWNrZWQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhzVG9KdW1wPTEyXSB7bnVtYmVyfSBIb3cgbWFueSBtb250aHMgdG8gbW92ZSB3aGVuIGxhcmdlIHByZXYvbmV4dCBjbGlja2VkLlxyXG5cdFx0XHRAcHJvcGVydHkgW3VzZU1vdXNlV2hlZWw9dHJ1ZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIHVzZSBtb3VzZXdoZWVsIGlmIGF2YWlsYWJsZSwgPGNvZGU+ZmFsc2U8L2NvZGU+IHRvIG5ldmVyIHVzZSBpdC5cclxuXHRcdFx0QHByb3BlcnR5IFtjaGFuZ2VNb250aD10cnVlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gY2hhbmdlIG1vbnRoL3llYXIgdmlhIGRyb3AtZG93biwgPGNvZGU+ZmFsc2U8L2NvZGU+IGZvciBuYXZpZ2F0aW9uIG9ubHkuXHJcblx0XHRcdEBwcm9wZXJ0eSBbeWVhclJhbmdlPSdjLTEwOmMrMTAnXSB7c3RyaW5nfSBSYW5nZSBvZiB5ZWFycyB0byBzaG93IGluIGRyb3AtZG93bjogJ2FueScgZm9yIGRpcmVjdCB0ZXh0IGVudHJ5XHJcblx0XHRcdFx0XHRcdG9yICdzdGFydDplbmQnLCB3aGVyZSBzdGFydC9lbmQgYXJlICcrLW5uJyBmb3IgcmVsYXRpdmUgdG8gdG9kYXlcclxuXHRcdFx0XHRcdFx0b3IgJ2MrLW5uJyBmb3IgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlXHJcblx0XHRcdFx0XHRcdG9yICdubm5uJyBmb3IgYW4gYWJzb2x1dGUgeWVhci5cclxuXHRcdFx0QHByb3BlcnR5IFtzaG93T3RoZXJNb250aHM9ZmFsc2VdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBzaG93IGRhdGVzIGZyb20gb3RoZXIgbW9udGhzLCA8Y29kZT5mYWxzZTwvY29kZT4gdG8gbm90IHNob3cgdGhlbS5cclxuXHRcdFx0QHByb3BlcnR5IFtzZWxlY3RPdGhlck1vbnRocz1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGFsbG93IHNlbGVjdGlvbiBvZiBkYXRlcyBmcm9tIG90aGVyIG1vbnRocyB0b28uXHJcblx0XHRcdEBwcm9wZXJ0eSBbZGVmYXVsdERhdGU9bnVsbF0ge3N0cmluZ3xudW1iZXJ8Q0RhdGV9IERhdGUgdG8gc2hvdyBpZiBubyBvdGhlciBzZWxlY3RlZC5cclxuXHRcdFx0QHByb3BlcnR5IFtzZWxlY3REZWZhdWx0RGF0ZT1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIHByZS1zZWxlY3QgdGhlIGRlZmF1bHQgZGF0ZSBpZiBubyBvdGhlciBpcyBjaG9zZW4uXHJcblx0XHRcdEBwcm9wZXJ0eSBbbWluRGF0ZT1udWxsXSB7c3RyaW5nfG51bWJlcnxDRGF0ZX0gVGhlIG1pbmltdW0gc2VsZWN0YWJsZSBkYXRlLlxyXG5cdFx0XHRAcHJvcGVydHkgW21heERhdGU9bnVsbF0ge3N0cmluZ3xudW1iZXJ8Q0RhdGV9IFRoZSBtYXhpbXVtIHNlbGVjdGFibGUgZGF0ZS5cclxuXHRcdFx0QHByb3BlcnR5IFtkYXRlRm9ybWF0PSdtbS9kZC95eXl5J10ge3N0cmluZ30gRm9ybWF0IGZvciBkYXRlcy5cclxuXHRcdFx0QHByb3BlcnR5IFthdXRvU2l6ZT1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIHNpemUgdGhlIGlucHV0IGZpZWxkIGFjY29yZGluZyB0byB0aGUgZGF0ZSBmb3JtYXQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbcmFuZ2VTZWxlY3Q9ZmFsc2VdIHtib29sZWFufSBBbGxvd3MgZm9yIHNlbGVjdGluZyBhIGRhdGUgcmFuZ2Ugb24gb25lIGRhdGUgcGlja2VyLlxyXG5cdFx0XHRAcHJvcGVydHkgW3JhbmdlU2VwYXJhdG9yPScgLSAnXSB7c3RyaW5nfSBUZXh0IGJldHdlZW4gdHdvIGRhdGVzIGluIGEgcmFuZ2UuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbXVsdGlTZWxlY3Q9MF0ge251bWJlcn0gTWF4aW11bSBudW1iZXIgb2Ygc2VsZWN0YWJsZSBkYXRlcywgemVybyBmb3Igc2luZ2xlIHNlbGVjdC5cclxuXHRcdFx0QHByb3BlcnR5IFttdWx0aVNlcGFyYXRvcj0nLCddIHtzdHJpbmd9IFRleHQgYmV0d2VlbiBtdWx0aXBsZSBkYXRlcy5cclxuXHRcdFx0QHByb3BlcnR5IFtvbkRhdGU9bnVsbF0ge0NhbGVuZGFyc1BpY2tlck9uRGF0ZX0gQ2FsbGJhY2sgYXMgYSBkYXRlIGlzIGFkZGVkIHRvIHRoZSBkYXRlcGlja2VyLlxyXG5cdFx0XHRAcHJvcGVydHkgW29uU2hvdz1udWxsXSB7Q2FsZW5kYXJzUGlja2VyT25TaG93fSBDYWxsYmFjayBqdXN0IGJlZm9yZSBhIGRhdGVwaWNrZXIgaXMgc2hvd24uXHJcblx0XHRcdEBwcm9wZXJ0eSBbb25DaGFuZ2VNb250aFllYXI9bnVsbF0ge0NhbGVuZGFyc1BpY2tlck9uQ2hhbmdlTW9udGhZZWFyfSBDYWxsYmFjayB3aGVuIGEgbmV3IG1vbnRoL3llYXIgaXMgc2VsZWN0ZWQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbb25TZWxlY3Q9bnVsbF0ge0NhbGVuZGFyc1BpY2tlck9uU2VsZWN0fSBDYWxsYmFjayB3aGVuIGEgZGF0ZSBpcyBzZWxlY3RlZC5cclxuXHRcdFx0QHByb3BlcnR5IFtvbkNsb3NlPW51bGxdIHtDYWxlbmRhcnNQaWNrZXJPbkNsb3NlfSBDYWxsYmFjayB3aGVuIGEgZGF0ZXBpY2tlciBpcyBjbG9zZWQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbYWx0RmllbGQ9bnVsbF0ge3N0cmluZ3xFbGVtZW50fGpRdWVyeX0gQWx0ZXJuYXRlIGZpZWxkIHRvIHVwZGF0ZSBpbiBzeW5jaCB3aXRoIHRoZSBkYXRlcGlja2VyLlxyXG5cdFx0XHRAcHJvcGVydHkgW2FsdEZvcm1hdD1udWxsXSB7c3RyaW5nfSBEYXRlIGZvcm1hdCBmb3IgYWx0ZXJuYXRlIGZpZWxkLCBkZWZhdWx0cyB0byA8Y29kZT5kYXRlRm9ybWF0PC9jb2RlPi5cclxuXHRcdFx0QHByb3BlcnR5IFtjb25zdHJhaW5JbnB1dD10cnVlXSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gdG8gY29uc3RyYWluIHR5cGVkIGlucHV0IHRvIDxjb2RlPmRhdGVGb3JtYXQ8L2NvZGU+IGFsbG93ZWQgY2hhcmFjdGVycy5cclxuXHRcdFx0QHByb3BlcnR5IFtjb21tYW5kc0FzRGF0ZUZvcm1hdD1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IHRvIGFwcGx5XHJcblx0XHRcdFx0XHRcdDxjb2RlPjxhIGhyZWY9XCIjZm9ybWF0RGF0ZVwiPmZvcm1hdERhdGU8L2E+PC9jb2RlPiB0byB0aGUgY29tbWFuZCB0ZXh0cy5cclxuXHRcdFx0QHByb3BlcnR5IFtjb21tYW5kcz10aGlzLmNvbW1hbmRzXSB7b2JqZWN0fSBDb21tYW5kIGFjdGlvbnMgdGhhdCBtYXkgYmUgYWRkZWQgdG8gYSBsYXlvdXQgYnkgbmFtZS4gKi9cclxuXHRcdGRlZmF1bHRPcHRpb25zOiB7XHJcblx0XHRcdGNhbGVuZGFyOiAkLmNhbGVuZGFycy5pbnN0YW5jZSgpLFxyXG5cdFx0XHRwaWNrZXJDbGFzczogJycsXHJcblx0XHRcdHNob3dPbkZvY3VzOiB0cnVlLFxyXG5cdFx0XHRzaG93VHJpZ2dlcjogbnVsbCxcclxuXHRcdFx0c2hvd0FuaW06ICdzaG93JyxcclxuXHRcdFx0c2hvd09wdGlvbnM6IHt9LFxyXG5cdFx0XHRzaG93U3BlZWQ6ICdub3JtYWwnLFxyXG5cdFx0XHRwb3B1cENvbnRhaW5lcjogbnVsbCxcclxuXHRcdFx0YWxpZ25tZW50OiAnYm90dG9tJyxcclxuXHRcdFx0Zml4ZWRXZWVrczogZmFsc2UsXHJcblx0XHRcdGZpcnN0RGF5OiBudWxsLFxyXG5cdFx0XHRjYWxjdWxhdGVXZWVrOiBudWxsLFxyXG5cdFx0XHRtb250aHNUb1Nob3c6IDEsXHJcblx0XHRcdG1vbnRoc09mZnNldDogMCxcclxuXHRcdFx0bW9udGhzVG9TdGVwOiAxLFxyXG5cdFx0XHRtb250aHNUb0p1bXA6IDEyLFxyXG5cdFx0XHR1c2VNb3VzZVdoZWVsOiB0cnVlLFxyXG5cdFx0XHRjaGFuZ2VNb250aDogdHJ1ZSxcclxuXHRcdFx0eWVhclJhbmdlOiAnYy0xMDpjKzEwJyxcclxuXHRcdFx0c2hvd090aGVyTW9udGhzOiBmYWxzZSxcclxuXHRcdFx0c2VsZWN0T3RoZXJNb250aHM6IGZhbHNlLFxyXG5cdFx0XHRkZWZhdWx0RGF0ZTogbnVsbCxcclxuXHRcdFx0c2VsZWN0RGVmYXVsdERhdGU6IGZhbHNlLFxyXG5cdFx0XHRtaW5EYXRlOiBudWxsLFxyXG5cdFx0XHRtYXhEYXRlOiBudWxsLFxyXG5cdFx0XHRkYXRlRm9ybWF0OiBudWxsLFxyXG5cdFx0XHRhdXRvU2l6ZTogZmFsc2UsXHJcblx0XHRcdHJhbmdlU2VsZWN0OiBmYWxzZSxcclxuXHRcdFx0cmFuZ2VTZXBhcmF0b3I6ICcgLSAnLFxyXG5cdFx0XHRtdWx0aVNlbGVjdDogMCxcclxuXHRcdFx0bXVsdGlTZXBhcmF0b3I6ICcsJyxcclxuXHRcdFx0b25EYXRlOiBudWxsLFxyXG5cdFx0XHRvblNob3c6IG51bGwsXHJcblx0XHRcdG9uQ2hhbmdlTW9udGhZZWFyOiBudWxsLFxyXG5cdFx0XHRvblNlbGVjdDogbnVsbCxcclxuXHRcdFx0b25DbG9zZTogbnVsbCxcclxuXHRcdFx0YWx0RmllbGQ6IG51bGwsXHJcblx0XHRcdGFsdEZvcm1hdDogbnVsbCxcclxuXHRcdFx0Y29uc3RyYWluSW5wdXQ6IHRydWUsXHJcblx0XHRcdGNvbW1hbmRzQXNEYXRlRm9ybWF0OiBmYWxzZSxcclxuXHRcdFx0Y29tbWFuZHM6IHt9IC8vIHRoaXMuY29tbWFuZHNcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIExvY2FsaXNhdGlvbnMgZm9yIHRoZSBwbHVnaW4uXHJcblx0XHRcdEVudHJpZXMgYXJlIG9iamVjdHMgaW5kZXhlZCBieSB0aGUgbGFuZ3VhZ2UgY29kZSAoJycgYmVpbmcgdGhlIGRlZmF1bHQgVVMvRW5nbGlzaCkuXHJcblx0XHRcdEVhY2ggb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByb3BlcnR5IFtyZW5kZXJlcj10aGlzLmRlZmF1bHRSZW5kZXJlcl0ge3N0cmluZ30gVGhlIHJlbmRlcmluZyB0ZW1wbGF0ZXMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbcHJldlRleHQ9JyZsdDtQcmV2J10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIHByZXZpb3VzIG1vbnRoIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbcHJldlN0YXR1cz0nU2hvdyB0aGUgcHJldmlvdXMgbW9udGgnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIHByZXZpb3VzIG1vbnRoIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbcHJldkp1bXBUZXh0PScmbHQ7Jmx0OyddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBwcmV2aW91cyB5ZWFyIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbcHJldkp1bXBTdGF0dXM9J1Nob3cgdGhlIHByZXZpb3VzIHllYXInXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIHByZXZpb3VzIHllYXIgY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtuZXh0VGV4dD0nTmV4dCZndDsnXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgbmV4dCBtb250aCBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW25leHRTdGF0dXM9J1Nob3cgdGhlIG5leHQgbW9udGgnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIG5leHQgbW9udGggY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtuZXh0SnVtcFRleHQ9JyZndDsmZ3Q7J10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIG5leHQgeWVhciBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW25leHRKdW1wU3RhdHVzPSdTaG93IHRoZSBuZXh0IHllYXInXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIG5leHQgeWVhciBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW2N1cnJlbnRUZXh0PSdDdXJyZW50J10ge3N0cmluZ30gVGV4dCBmb3IgdGhlIGN1cnJlbnQgbW9udGggY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtjdXJyZW50U3RhdHVzPSdTaG93IHRoZSBjdXJyZW50IG1vbnRoJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSBjdXJyZW50IG1vbnRoIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbdG9kYXlUZXh0PSdUb2RheSddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSB0b2RheSdzIG1vbnRoIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbdG9kYXlTdGF0dXM9J1Nob3cgdG9kYXlcXCdzIG1vbnRoJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSB0b2RheSdzIG1vbnRoIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbY2xlYXJUZXh0PSdDbGVhciddIHtzdHJpbmd9IFRleHQgZm9yIHRoZSBjbGVhciBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW2NsZWFyU3RhdHVzPSdDbGVhciBhbGwgdGhlIGRhdGVzJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHRoZSBjbGVhciBjb21tYW5kLlxyXG5cdFx0XHRAcHJvcGVydHkgW2Nsb3NlVGV4dD0nQ2xvc2UnXSB7c3RyaW5nfSBUZXh0IGZvciB0aGUgY2xvc2UgY29tbWFuZC5cclxuXHRcdFx0QHByb3BlcnR5IFtjbG9zZVN0YXR1cz0nQ2xvc2UgdGhlIGRhdGVwaWNrZXInXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgdGhlIGNsb3NlIGNvbW1hbmQuXHJcblx0XHRcdEBwcm9wZXJ0eSBbeWVhclN0YXR1cz0nQ2hhbmdlIHRoZSB5ZWFyJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHllYXIgc2VsZWN0aW9uLlxyXG5cdFx0XHRAcHJvcGVydHkgW2VhcmxpZXJUZXh0PScmIzE2MDsmIzE2MDvilrInXSB7c3RyaW5nfSBUZXh0IGZvciBlYXJsaWVyIHllYXJzLlxyXG5cdFx0XHRAcHJvcGVydHkgW2xhdGVyVGV4dD0nJiMxNjA7JiMxNjA74pa8J10ge3N0cmluZ30gVGV4dCBmb3IgbGF0ZXIgeWVhcnMuXHJcblx0XHRcdEBwcm9wZXJ0eSBbbW9udGhTdGF0dXM9J0NoYW5nZSB0aGUgbW9udGgnXSB7c3RyaW5nfSBTdGF0dXMgdGV4dCBmb3IgbW9udGggc2VsZWN0aW9uLlxyXG5cdFx0XHRAcHJvcGVydHkgW3dlZWtUZXh0PSdXayddIHtzdHJpbmd9IFRleHQgZm9yIHdlZWsgb2YgdGhlIHllYXIgY29sdW1uIGhlYWRlci5cclxuXHRcdFx0QHByb3BlcnR5IFt3ZWVrU3RhdHVzPSdXZWVrIG9mIHRoZSB5ZWFyJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHdlZWsgb2YgdGhlIHllYXIgY29sdW1uIGhlYWRlci5cclxuXHRcdFx0QHByb3BlcnR5IFtkYXlTdGF0dXM9J1NlbGVjdCBERCwmIzE2MDtNJiMxNjA7ZCwmIzE2MDt5eXl5J10ge3N0cmluZ30gU3RhdHVzIHRleHQgZm9yIHNlbGVjdGFibGUgZGF5cy5cclxuXHRcdFx0QHByb3BlcnR5IFtkZWZhdWx0U3RhdHVzPSdTZWxlY3QgYSBkYXRlJ10ge3N0cmluZ30gU3RhdHVzIHRleHQgc2hvd24gYnkgZGVmYXVsdC5cclxuXHRcdFx0QHByb3BlcnR5IFtpc1JUTD1mYWxzZV0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGxhbmd1YWdlIGlzIHJpZ2h0LXRvLWxlZnQuICovXHJcblx0XHRyZWdpb25hbE9wdGlvbnM6IHsgLy8gQXZhaWxhYmxlIHJlZ2lvbmFsIHNldHRpbmdzLCBpbmRleGVkIGJ5IGxhbmd1YWdlL2NvdW50cnkgY29kZVxyXG5cdFx0XHQnJzogeyAvLyBEZWZhdWx0IHJlZ2lvbmFsIHNldHRpbmdzIC0gRW5nbGlzaC9VU1xyXG5cdFx0XHRcdHJlbmRlcmVyOiB7fSwgLy8gdGhpcy5kZWZhdWx0UmVuZGVyZXJcclxuXHRcdFx0XHRwcmV2VGV4dDogJyZsdDtQcmV2JyxcclxuXHRcdFx0XHRwcmV2U3RhdHVzOiAnU2hvdyB0aGUgcHJldmlvdXMgbW9udGgnLFxyXG5cdFx0XHRcdHByZXZKdW1wVGV4dDogJyZsdDsmbHQ7JyxcclxuXHRcdFx0XHRwcmV2SnVtcFN0YXR1czogJ1Nob3cgdGhlIHByZXZpb3VzIHllYXInLFxyXG5cdFx0XHRcdG5leHRUZXh0OiAnTmV4dCZndDsnLFxyXG5cdFx0XHRcdG5leHRTdGF0dXM6ICdTaG93IHRoZSBuZXh0IG1vbnRoJyxcclxuXHRcdFx0XHRuZXh0SnVtcFRleHQ6ICcmZ3Q7Jmd0OycsXHJcblx0XHRcdFx0bmV4dEp1bXBTdGF0dXM6ICdTaG93IHRoZSBuZXh0IHllYXInLFxyXG5cdFx0XHRcdGN1cnJlbnRUZXh0OiAnQ3VycmVudCcsXHJcblx0XHRcdFx0Y3VycmVudFN0YXR1czogJ1Nob3cgdGhlIGN1cnJlbnQgbW9udGgnLFxyXG5cdFx0XHRcdHRvZGF5VGV4dDogJ1RvZGF5JyxcclxuXHRcdFx0XHR0b2RheVN0YXR1czogJ1Nob3cgdG9kYXlcXCdzIG1vbnRoJyxcclxuXHRcdFx0XHRjbGVhclRleHQ6ICdDbGVhcicsXHJcblx0XHRcdFx0Y2xlYXJTdGF0dXM6ICdDbGVhciBhbGwgdGhlIGRhdGVzJyxcclxuXHRcdFx0XHRjbG9zZVRleHQ6ICdDbG9zZScsXHJcblx0XHRcdFx0Y2xvc2VTdGF0dXM6ICdDbG9zZSB0aGUgZGF0ZXBpY2tlcicsXHJcblx0XHRcdFx0eWVhclN0YXR1czogJ0NoYW5nZSB0aGUgeWVhcicsXHJcblx0XHRcdFx0ZWFybGllclRleHQ6ICcmIzE2MDsmIzE2MDvilrInLFxyXG5cdFx0XHRcdGxhdGVyVGV4dDogJyYjMTYwOyYjMTYwO+KWvCcsXHJcblx0XHRcdFx0bW9udGhTdGF0dXM6ICdDaGFuZ2UgdGhlIG1vbnRoJyxcclxuXHRcdFx0XHR3ZWVrVGV4dDogJ1drJyxcclxuXHRcdFx0XHR3ZWVrU3RhdHVzOiAnV2VlayBvZiB0aGUgeWVhcicsXHJcblx0XHRcdFx0ZGF5U3RhdHVzOiAnU2VsZWN0IERELCBNIGQsIHl5eXknLFxyXG5cdFx0XHRcdGRlZmF1bHRTdGF0dXM6ICdTZWxlY3QgYSBkYXRlJyxcclxuXHRcdFx0XHRpc1JUTDogZmFsc2VcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0LyoqIE5hbWVzIG9mIGdldHRlciBtZXRob2RzIC0gdGhvc2UgdGhhdCBjYW4ndCBiZSBjaGFpbmVkLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyICovXHJcblx0XHRfZ2V0dGVyczogWydnZXREYXRlJywgJ2lzRGlzYWJsZWQnLCAnaXNTZWxlY3RhYmxlJywgJ3JldHJpZXZlRGF0ZSddLFxyXG5cclxuXHRcdF9kaXNhYmxlZDogW10sXHJcblx0XHRcclxuXHRcdF9wb3B1cENsYXNzOiAnY2FsZW5kYXJzLXBvcHVwJywgLy8gTWFya2VyIGZvciBwb3B1cCBkaXZpc2lvblxyXG5cdFx0X3RyaWdnZXJDbGFzczogJ2NhbGVuZGFycy10cmlnZ2VyJywgLy8gTWFya2VyIGZvciB0cmlnZ2VyIGVsZW1lbnRcclxuXHRcdF9kaXNhYmxlQ2xhc3M6ICdjYWxlbmRhcnMtZGlzYWJsZScsIC8vIE1hcmtlciBmb3IgZGlzYWJsZWQgZWxlbWVudFxyXG5cdFx0X21vbnRoWWVhckNsYXNzOiAnY2FsZW5kYXJzLW1vbnRoLXllYXInLCAvLyBNYXJrZXIgZm9yIG1vbnRoL3llYXIgaW5wdXRzXHJcblx0XHRfY3VyTW9udGhDbGFzczogJ2NhbGVuZGFycy1tb250aC0nLCAvLyBNYXJrZXIgZm9yIGN1cnJlbnQgbW9udGgveWVhclxyXG5cdFx0X2FueVllYXJDbGFzczogJ2NhbGVuZGFycy1hbnkteWVhcicsIC8vIE1hcmtlciBmb3IgeWVhciBkaXJlY3QgaW5wdXRcclxuXHRcdF9jdXJEb1dDbGFzczogJ2NhbGVuZGFycy1kb3ctJywgLy8gTWFya2VyIGZvciBkYXkgb2Ygd2Vla1xyXG5cclxuXHRcdF9pbml0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dGhpcy5kZWZhdWx0T3B0aW9ucy5jb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XHJcblx0XHRcdHRoaXMucmVnaW9uYWxPcHRpb25zWycnXS5yZW5kZXJlciA9IHRoaXMuZGVmYXVsdFJlbmRlcmVyO1xyXG5cdFx0XHR0aGlzLl9zdXBlcigpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfaW5zdFNldHRpbmdzOiBmdW5jdGlvbihlbGVtLCBvcHRpb25zKSB7XHJcblx0XHRcdHJldHVybiB7c2VsZWN0ZWREYXRlczogW10sIGRyYXdEYXRlOiBudWxsLCBwaWNraW5nUmFuZ2U6IGZhbHNlLFxyXG5cdFx0XHRcdGlubGluZTogKCQuaW5BcnJheShlbGVtWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIFsnZGl2JywgJ3NwYW4nXSkgPiAtMSksXHJcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbihuYW1lKSB7IC8vIEdldCBhIHNldHRpbmcgdmFsdWUsIGNvbXB1dGluZyBpZiBuZWNlc3NhcnlcclxuXHRcdFx0XHRcdGlmICgkLmluQXJyYXkobmFtZSwgWydkZWZhdWx0RGF0ZScsICdtaW5EYXRlJywgJ21heERhdGUnXSkgPiAtMSkgeyAvLyBEZWNvZGUgZGF0ZSBzZXR0aW5nc1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNhbGVuZGFyLmRldGVybWluZURhdGUodGhpcy5vcHRpb25zW25hbWVdLCBudWxsLFxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWREYXRlc1swXSwgdGhpcy5nZXQoJ2RhdGVGb3JtYXQnKSwgdGhpcy5nZXRDb25maWcoKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobmFtZSA9PT0gJ2RhdGVGb3JtYXQnKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMuZGF0ZUZvcm1hdCB8fCB0aGlzLm9wdGlvbnMuY2FsZW5kYXIubG9jYWwuZGF0ZUZvcm1hdDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbbmFtZV07XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRjdXJNaW5EYXRlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiAodGhpcy5waWNraW5nUmFuZ2UgPyB0aGlzLnNlbGVjdGVkRGF0ZXNbMF0gOiB0aGlzLmdldCgnbWluRGF0ZScpKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGdldENvbmZpZzogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4ge2RheU5hbWVzU2hvcnQ6IHRoaXMub3B0aW9ucy5kYXlOYW1lc1Nob3J0LCBkYXlOYW1lczogdGhpcy5vcHRpb25zLmRheU5hbWVzLFxyXG5cdFx0XHRcdFx0XHRtb250aE5hbWVzU2hvcnQ6IHRoaXMub3B0aW9ucy5tb250aE5hbWVzU2hvcnQsIG1vbnRoTmFtZXM6IHRoaXMub3B0aW9ucy5tb250aE5hbWVzLFxyXG5cdFx0XHRcdFx0XHRjYWxjdWxhdGVXZWVrOiB0aGlzLm9wdGlvbnMuY2FsY3VsYXRlV2Vlaywgc2hvcnRZZWFyQ3V0b2ZmOiB0aGlzLm9wdGlvbnMuc2hvcnRZZWFyQ3V0b2ZmfTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHR9LFxyXG5cclxuXHRcdF9wb3N0QXR0YWNoOiBmdW5jdGlvbihlbGVtLCBpbnN0KSB7XHJcblx0XHRcdGlmIChpbnN0LmlubGluZSkge1xyXG5cdFx0XHRcdGluc3QuZHJhd0RhdGUgPSBwbHVnaW4uX2NoZWNrTWluTWF4KChpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gfHxcclxuXHRcdFx0XHRcdGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpKS5uZXdEYXRlKCksIGluc3QpO1xyXG5cdFx0XHRcdGluc3QucHJldkRhdGUgPSBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKTtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGUoZWxlbVswXSk7XHJcblx0XHRcdFx0aWYgKCQuZm4ubW91c2V3aGVlbCkge1xyXG5cdFx0XHRcdFx0ZWxlbS5tb3VzZXdoZWVsKHRoaXMuX2RvTW91c2VXaGVlbCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuX2F0dGFjaG1lbnRzKGVsZW0sIGluc3QpO1xyXG5cdFx0XHRcdGVsZW0ub24oJ2tleWRvd24uJyArIGluc3QubmFtZSwgdGhpcy5fa2V5RG93bikub24oJ2tleXByZXNzLicgKyBpbnN0Lm5hbWUsIHRoaXMuX2tleVByZXNzKS5cclxuXHRcdFx0XHRcdG9uKCdrZXl1cC4nICsgaW5zdC5uYW1lLCB0aGlzLl9rZXlVcCk7XHJcblx0XHRcdFx0aWYgKGVsZW0uYXR0cignZGlzYWJsZWQnKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5kaXNhYmxlKGVsZW1bMF0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHRfb3B0aW9uc0NoYW5nZWQ6IGZ1bmN0aW9uKGVsZW0sIGluc3QsIG9wdGlvbnMpIHtcclxuXHRcdFx0aWYgKG9wdGlvbnMuY2FsZW5kYXIgJiYgb3B0aW9ucy5jYWxlbmRhciAhPT0gaW5zdC5vcHRpb25zLmNhbGVuZGFyKSB7XHJcblx0XHRcdFx0dmFyIGRpc2NhcmREYXRlID0gZnVuY3Rpb24obmFtZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuICh0eXBlb2YgaW5zdC5vcHRpb25zW25hbWVdID09PSAnb2JqZWN0JyA/IG51bGwgOiBpbnN0Lm9wdGlvbnNbbmFtZV0pO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0b3B0aW9ucyA9ICQuZXh0ZW5kKHtkZWZhdWx0RGF0ZTogZGlzY2FyZERhdGUoJ2RlZmF1bHREYXRlJyksXHJcblx0XHRcdFx0XHRtaW5EYXRlOiBkaXNjYXJkRGF0ZSgnbWluRGF0ZScpLCBtYXhEYXRlOiBkaXNjYXJkRGF0ZSgnbWF4RGF0ZScpfSwgb3B0aW9ucyk7XHJcblx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzID0gW107XHJcblx0XHRcdFx0aW5zdC5kcmF3RGF0ZSA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGRhdGVzID0gaW5zdC5zZWxlY3RlZERhdGVzO1xyXG5cdFx0XHQkLmV4dGVuZChpbnN0Lm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdFx0XHR0aGlzLnNldERhdGUoZWxlbVswXSwgZGF0ZXMsIG51bGwsIGZhbHNlLCB0cnVlKTtcclxuXHRcdFx0aW5zdC5waWNraW5nUmFuZ2UgPSBmYWxzZTtcclxuXHRcdFx0dmFyIGNhbGVuZGFyID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyO1xyXG5cdFx0XHR2YXIgZGVmYXVsdERhdGUgPSBpbnN0LmdldCgnZGVmYXVsdERhdGUnKTtcclxuXHRcdFx0aW5zdC5kcmF3RGF0ZSA9IHRoaXMuX2NoZWNrTWluTWF4KChkZWZhdWx0RGF0ZSA/IGRlZmF1bHREYXRlIDogaW5zdC5kcmF3RGF0ZSkgfHxcclxuXHRcdFx0XHRkZWZhdWx0RGF0ZSB8fCBjYWxlbmRhci50b2RheSgpLCBpbnN0KS5uZXdEYXRlKCk7XHJcblx0XHRcdGlmICghaW5zdC5pbmxpbmUpIHtcclxuXHRcdFx0XHR0aGlzLl9hdHRhY2htZW50cyhlbGVtLCBpbnN0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoaW5zdC5pbmxpbmUgfHwgaW5zdC5kaXYpIHtcclxuXHRcdFx0XHR0aGlzLl91cGRhdGUoZWxlbVswXSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEF0dGFjaCBldmVudHMgYW5kIHRyaWdnZXIsIGlmIG5lY2Vzc2FyeS5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7alF1ZXJ5fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLiAqL1xyXG5cdFx0X2F0dGFjaG1lbnRzOiBmdW5jdGlvbihlbGVtLCBpbnN0KSB7XHJcblx0XHRcdGVsZW0ub2ZmKCdmb2N1cy4nICsgaW5zdC5uYW1lKTtcclxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy5zaG93T25Gb2N1cykge1xyXG5cdFx0XHRcdGVsZW0ub24oJ2ZvY3VzLicgKyBpbnN0Lm5hbWUsIHRoaXMuc2hvdyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGluc3QudHJpZ2dlcikge1xyXG5cdFx0XHRcdGluc3QudHJpZ2dlci5yZW1vdmUoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgdHJpZ2dlciA9IGluc3Qub3B0aW9ucy5zaG93VHJpZ2dlcjtcclxuXHRcdFx0aW5zdC50cmlnZ2VyID0gKCF0cmlnZ2VyID8gJChbXSkgOlxyXG5cdFx0XHRcdCQodHJpZ2dlcikuY2xvbmUoKS5yZW1vdmVBdHRyKCdpZCcpLmFkZENsYXNzKHRoaXMuX3RyaWdnZXJDbGFzcylcclxuXHRcdFx0XHRcdFtpbnN0Lm9wdGlvbnMuaXNSVEwgPyAnaW5zZXJ0QmVmb3JlJyA6ICdpbnNlcnRBZnRlciddKGVsZW0pLlxyXG5cdFx0XHRcdFx0Y2xpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGlmICghcGx1Z2luLmlzRGlzYWJsZWQoZWxlbVswXSkpIHtcclxuXHRcdFx0XHRcdFx0XHRwbHVnaW5bcGx1Z2luLmN1ckluc3QgPT09IGluc3QgPyAnaGlkZScgOiAnc2hvdyddKGVsZW1bMF0pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KSk7XHJcblx0XHRcdHRoaXMuX2F1dG9TaXplKGVsZW0sIGluc3QpO1xyXG5cdFx0XHR2YXIgZGF0ZXMgPSB0aGlzLl9leHRyYWN0RGF0ZXMoaW5zdCwgZWxlbS52YWwoKSk7XHJcblx0XHRcdGlmIChkYXRlcykge1xyXG5cdFx0XHRcdHRoaXMuc2V0RGF0ZShlbGVtWzBdLCBkYXRlcywgbnVsbCwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGRlZmF1bHREYXRlID0gaW5zdC5nZXQoJ2RlZmF1bHREYXRlJyk7XHJcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMuc2VsZWN0RGVmYXVsdERhdGUgJiYgZGVmYXVsdERhdGUgJiYgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdHRoaXMuc2V0RGF0ZShlbGVtWzBdLCAoZGVmYXVsdERhdGUgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkpLm5ld0RhdGUoKSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEFwcGx5IHRoZSBtYXhpbXVtIGxlbmd0aCBmb3IgdGhlIGRhdGUgZm9ybWF0LlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtqUXVlcnl9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuICovXHJcblx0XHRfYXV0b1NpemU6IGZ1bmN0aW9uKGVsZW0sIGluc3QpIHtcclxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy5hdXRvU2l6ZSAmJiAhaW5zdC5pbmxpbmUpIHtcclxuXHRcdFx0XHR2YXIgY2FsZW5kYXIgPSBpbnN0Lm9wdGlvbnMuY2FsZW5kYXI7XHJcblx0XHRcdFx0dmFyIGRhdGUgPSBjYWxlbmRhci5uZXdEYXRlKDIwMDksIDEwLCAyMCk7IC8vIEVuc3VyZSBkb3VibGUgZGlnaXRzXHJcblx0XHRcdFx0dmFyIGRhdGVGb3JtYXQgPSBpbnN0LmdldCgnZGF0ZUZvcm1hdCcpO1xyXG5cdFx0XHRcdGlmIChkYXRlRm9ybWF0Lm1hdGNoKC9bRE1dLykpIHtcclxuXHRcdFx0XHRcdHZhciBmaW5kTWF4ID0gZnVuY3Rpb24obmFtZXMpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG1heCA9IDA7XHJcblx0XHRcdFx0XHRcdHZhciBtYXhJID0gMDtcclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChuYW1lc1tpXS5sZW5ndGggPiBtYXgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG1heCA9IG5hbWVzW2ldLmxlbmd0aDtcclxuXHRcdFx0XHRcdFx0XHRcdG1heEkgPSBpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF4STtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRkYXRlLm1vbnRoKGZpbmRNYXgoY2FsZW5kYXIubG9jYWxbZGF0ZUZvcm1hdC5tYXRjaCgvTU0vKSA/IC8vIExvbmdlc3QgbW9udGhcclxuXHRcdFx0XHRcdFx0J21vbnRoTmFtZXMnIDogJ21vbnRoTmFtZXNTaG9ydCddKSArIDEpO1xyXG5cdFx0XHRcdFx0ZGF0ZS5kYXkoZmluZE1heChjYWxlbmRhci5sb2NhbFtkYXRlRm9ybWF0Lm1hdGNoKC9ERC8pID8gLy8gTG9uZ2VzdCBkYXlcclxuXHRcdFx0XHRcdFx0J2RheU5hbWVzJyA6ICdkYXlOYW1lc1Nob3J0J10pICsgMjAgLSBkYXRlLmRheU9mV2VlaygpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aW5zdC5lbGVtLmF0dHIoJ3NpemUnLCBkYXRlLmZvcm1hdERhdGUoZGF0ZUZvcm1hdCkubGVuZ3RoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHRfcHJlRGVzdHJveTogZnVuY3Rpb24oZWxlbSwgaW5zdCkge1xyXG5cdFx0XHRpZiAoaW5zdC50cmlnZ2VyKSB7XHJcblx0XHRcdFx0aW5zdC50cmlnZ2VyLnJlbW92ZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsZW0uZW1wdHkoKS5vZmYoJy4nICsgaW5zdC5uYW1lKTtcclxuXHRcdFx0aWYgKGluc3QuaW5saW5lICYmICQuZm4ubW91c2V3aGVlbCkge1xyXG5cdFx0XHRcdGVsZW0udW5tb3VzZXdoZWVsKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFpbnN0LmlubGluZSAmJiBpbnN0Lm9wdGlvbnMuYXV0b1NpemUpIHtcclxuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHIoJ3NpemUnKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQXBwbHkgbXVsdGlwbGUgZXZlbnQgZnVuY3Rpb25zLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBmbnMge2Z1bmN0aW9ufSBUaGUgZnVuY3Rpb25zIHRvIGFwcGx5LlxyXG5cdFx0XHRAZXhhbXBsZSBvblNob3c6IG11bHRpcGxlRXZlbnRzKGZuMSwgZm4yLCAuLi4pICovXHJcblx0XHRtdWx0aXBsZUV2ZW50czogZnVuY3Rpb24oZm5zKSB7XHJcblx0XHRcdHZhciBmdW5jcyA9IGFyZ3VtZW50cztcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRmdW5jc1tpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEVuYWJsZSB0aGUgY29udHJvbC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnZW5hYmxlJykgKi9cclxuXHRcdGVuYWJsZTogZnVuY3Rpb24oZWxlbSkge1xyXG5cdFx0XHRlbGVtID0gJChlbGVtKTtcclxuXHRcdFx0aWYgKCFlbGVtLmhhc0NsYXNzKHRoaXMuX2dldE1hcmtlcigpKSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmIChpbnN0LmlubGluZSkge1xyXG5cdFx0XHRcdGVsZW0uY2hpbGRyZW4oJy4nICsgdGhpcy5fZGlzYWJsZUNsYXNzKS5yZW1vdmUoKS5lbmQoKS5cclxuXHRcdFx0XHRcdGZpbmQoJ2J1dHRvbixzZWxlY3QnKS5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKS5lbmQoKS5cclxuXHRcdFx0XHRcdGZpbmQoJ2EnKS5hdHRyKCdocmVmJywgJ2phdmFzY3JpcHQ6dm9pZCgwKScpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGVsZW0ucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XHJcblx0XHRcdFx0aW5zdC50cmlnZ2VyLmZpbHRlcignYnV0dG9uLicgKyB0aGlzLl90cmlnZ2VyQ2xhc3MpLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpLmVuZCgpLlxyXG5cdFx0XHRcdFx0ZmlsdGVyKCdpbWcuJyArIHRoaXMuX3RyaWdnZXJDbGFzcykuY3NzKHtvcGFjaXR5OiAnMS4wJywgY3Vyc29yOiAnJ30pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX2Rpc2FibGVkID0gJC5tYXAodGhpcy5fZGlzYWJsZWQsXHJcblx0XHRcdFx0ZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuICh2YWx1ZSA9PT0gZWxlbVswXSA/IG51bGwgOiB2YWx1ZSk7IH0pOyAvLyBEZWxldGUgZW50cnlcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIERpc2FibGUgdGhlIGNvbnRyb2wuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cclxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ2Rpc2FibGUnKSAqL1xyXG5cdFx0ZGlzYWJsZTogZnVuY3Rpb24oZWxlbSkge1xyXG5cdFx0XHRlbGVtID0gJChlbGVtKTtcclxuXHRcdFx0aWYgKCFlbGVtLmhhc0NsYXNzKHRoaXMuX2dldE1hcmtlcigpKSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmIChpbnN0LmlubGluZSkge1xyXG5cdFx0XHRcdHZhciBpbmxpbmUgPSBlbGVtLmNoaWxkcmVuKCc6bGFzdCcpO1xyXG5cdFx0XHRcdHZhciBvZmZzZXQgPSBpbmxpbmUub2Zmc2V0KCk7XHJcblx0XHRcdFx0dmFyIHJlbE9mZnNldCA9IHtsZWZ0OiAwLCB0b3A6IDB9O1xyXG5cdFx0XHRcdGlubGluZS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICgkKHRoaXMpLmNzcygncG9zaXRpb24nKSA9PT0gJ3JlbGF0aXZlJykge1xyXG5cdFx0XHRcdFx0XHRyZWxPZmZzZXQgPSAkKHRoaXMpLm9mZnNldCgpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0dmFyIHpJbmRleCA9IGVsZW0uY3NzKCd6SW5kZXgnKTtcclxuXHRcdFx0XHR6SW5kZXggPSAoekluZGV4ID09PSAnYXV0bycgPyAwIDogcGFyc2VJbnQoekluZGV4LCAxMCkpICsgMTtcclxuXHRcdFx0XHRlbGVtLnByZXBlbmQoJzxkaXYgY2xhc3M9XCInICsgdGhpcy5fZGlzYWJsZUNsYXNzICsgJ1wiIHN0eWxlPVwiJyArXHJcblx0XHRcdFx0XHQnd2lkdGg6ICcgKyBpbmxpbmUub3V0ZXJXaWR0aCgpICsgJ3B4OyBoZWlnaHQ6ICcgKyBpbmxpbmUub3V0ZXJIZWlnaHQoKSArXHJcblx0XHRcdFx0XHQncHg7IGxlZnQ6ICcgKyAob2Zmc2V0LmxlZnQgLSByZWxPZmZzZXQubGVmdCkgKyAncHg7IHRvcDogJyArXHJcblx0XHRcdFx0XHQob2Zmc2V0LnRvcCAtIHJlbE9mZnNldC50b3ApICsgJ3B4OyB6LWluZGV4OiAnICsgekluZGV4ICsgJ1wiPjwvZGl2PicpLlxyXG5cdFx0XHRcdFx0ZmluZCgnYnV0dG9uLHNlbGVjdCcpLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSkuZW5kKCkuXHJcblx0XHRcdFx0XHRmaW5kKCdhJykucmVtb3ZlQXR0cignaHJlZicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGVsZW0ucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcclxuXHRcdFx0XHRpbnN0LnRyaWdnZXIuZmlsdGVyKCdidXR0b24uJyArIHRoaXMuX3RyaWdnZXJDbGFzcykucHJvcCgnZGlzYWJsZWQnLCB0cnVlKS5lbmQoKS5cclxuXHRcdFx0XHRcdGZpbHRlcignaW1nLicgKyB0aGlzLl90cmlnZ2VyQ2xhc3MpLmNzcyh7b3BhY2l0eTogJzAuNScsIGN1cnNvcjogJ2RlZmF1bHQnfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fZGlzYWJsZWQgPSAkLm1hcCh0aGlzLl9kaXNhYmxlZCxcclxuXHRcdFx0XHRmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gKHZhbHVlID09PSBlbGVtWzBdID8gbnVsbCA6IHZhbHVlKTsgfSk7IC8vIERlbGV0ZSBlbnRyeVxyXG5cdFx0XHR0aGlzLl9kaXNhYmxlZC5wdXNoKGVsZW1bMF0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogSXMgdGhlIGZpcnN0IGZpZWxkIGluIGEgalF1ZXJ5IGNvbGxlY3Rpb24gZGlzYWJsZWQgYXMgYSBkYXRlcGlja2VyP1xyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBkaXNhYmxlZCwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIGVuYWJsZWQuXHJcblx0XHRcdEBleGFtcGxlIGlmICgkKHNlbGVjdG9yKS5kYXRlcGljaygnaXNEaXNhYmxlZCcpKSB7Li4ufSAqL1xyXG5cdFx0aXNEaXNhYmxlZDogZnVuY3Rpb24oZWxlbSkge1xyXG5cdFx0XHRyZXR1cm4gKGVsZW0gJiYgJC5pbkFycmF5KGVsZW0sIHRoaXMuX2Rpc2FibGVkKSA+IC0xKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFNob3cgYSBwb3B1cCBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFdmVudHxFbGVtZW50fSBhIGZvY3VzIGV2ZW50IG9yIHRoZSBjb250cm9sIHRvIHVzZS5cclxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ3Nob3cnKSAqL1xyXG5cdFx0c2hvdzogZnVuY3Rpb24oZWxlbSkge1xyXG5cdFx0XHRlbGVtID0gJChlbGVtLnRhcmdldCB8fCBlbGVtKTtcclxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmIChwbHVnaW4uY3VySW5zdCA9PT0gaW5zdCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAocGx1Z2luLmN1ckluc3QpIHtcclxuXHRcdFx0XHRwbHVnaW4uaGlkZShwbHVnaW4uY3VySW5zdCwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkpIHtcclxuXHRcdFx0XHQvLyBSZXRyaWV2ZSBleGlzdGluZyBkYXRlKHMpXHJcblx0XHRcdFx0aW5zdC5sYXN0VmFsID0gbnVsbDtcclxuXHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMgPSBwbHVnaW4uX2V4dHJhY3REYXRlcyhpbnN0LCBlbGVtLnZhbCgpKTtcclxuXHRcdFx0XHRpbnN0LnBpY2tpbmdSYW5nZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGluc3QuZHJhd0RhdGUgPSBwbHVnaW4uX2NoZWNrTWluTWF4KChpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gfHxcclxuXHRcdFx0XHRcdGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpKS5uZXdEYXRlKCksIGluc3QpO1xyXG5cdFx0XHRcdGluc3QucHJldkRhdGUgPSBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKTtcclxuXHRcdFx0XHRwbHVnaW4uY3VySW5zdCA9IGluc3Q7XHJcblx0XHRcdFx0Ly8gR2VuZXJhdGUgY29udGVudFxyXG5cdFx0XHRcdHBsdWdpbi5fdXBkYXRlKGVsZW1bMF0sIHRydWUpO1xyXG5cdFx0XHRcdC8vIEFkanVzdCBwb3NpdGlvbiBiZWZvcmUgc2hvd2luZ1xyXG5cdFx0XHRcdHZhciBvZmZzZXQgPSBwbHVnaW4uX2NoZWNrT2Zmc2V0KGluc3QpO1xyXG5cdFx0XHRcdGluc3QuZGl2LmNzcyh7bGVmdDogb2Zmc2V0LmxlZnQsIHRvcDogb2Zmc2V0LnRvcH0pO1xyXG5cdFx0XHRcdC8vIEFuZCBkaXNwbGF5XHJcblx0XHRcdFx0dmFyIHNob3dBbmltID0gaW5zdC5vcHRpb25zLnNob3dBbmltO1xyXG5cdFx0XHRcdHZhciBzaG93U3BlZWQgPSBpbnN0Lm9wdGlvbnMuc2hvd1NwZWVkO1xyXG5cdFx0XHRcdHNob3dTcGVlZCA9IChzaG93U3BlZWQgPT09ICdub3JtYWwnICYmICQudWkgJiZcclxuXHRcdFx0XHRcdHBhcnNlSW50KCQudWkudmVyc2lvbi5zdWJzdHJpbmcoMikpID49IDggPyAnX2RlZmF1bHQnIDogc2hvd1NwZWVkKTtcclxuXHRcdFx0XHRpZiAoJC5lZmZlY3RzICYmICgkLmVmZmVjdHNbc2hvd0FuaW1dIHx8ICgkLmVmZmVjdHMuZWZmZWN0ICYmICQuZWZmZWN0cy5lZmZlY3Rbc2hvd0FuaW1dKSkpIHtcclxuXHRcdFx0XHRcdHZhciBkYXRhID0gaW5zdC5kaXYuZGF0YSgpOyAvLyBVcGRhdGUgb2xkIGVmZmVjdHMgZGF0YVxyXG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGtleS5tYXRjaCgvXmVjXFwuc3RvcmFnZVxcLi8pKSB7XHJcblx0XHRcdFx0XHRcdFx0ZGF0YVtrZXldID0gaW5zdC5fbWFpbkRpdi5jc3Moa2V5LnJlcGxhY2UoL2VjXFwuc3RvcmFnZVxcLi8sICcnKSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGluc3QuZGl2LmRhdGEoZGF0YSkuc2hvdyhzaG93QW5pbSwgaW5zdC5vcHRpb25zLnNob3dPcHRpb25zLCBzaG93U3BlZWQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGluc3QuZGl2W3Nob3dBbmltIHx8ICdzaG93J10oc2hvd0FuaW0gPyBzaG93U3BlZWQgOiAwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEV4dHJhY3QgcG9zc2libGUgZGF0ZXMgZnJvbSBhIHN0cmluZy5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHBhcmFtIHRleHQge3N0cmluZ30gVGhlIHRleHQgdG8gZXh0cmFjdCBmcm9tLlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZVtdfSBUaGUgZXh0cmFjdGVkIGRhdGVzLiAqL1xyXG5cdFx0X2V4dHJhY3REYXRlczogZnVuY3Rpb24oaW5zdCwgZGF0ZXNUZXh0KSB7XHJcblx0XHRcdGlmIChkYXRlc1RleHQgPT09IGluc3QubGFzdFZhbCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpbnN0Lmxhc3RWYWwgPSBkYXRlc1RleHQ7XHJcblx0XHRcdGRhdGVzVGV4dCA9IGRhdGVzVGV4dC5zcGxpdChpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgPyBpbnN0Lm9wdGlvbnMubXVsdGlTZXBhcmF0b3IgOlxyXG5cdFx0XHRcdChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgPyBpbnN0Lm9wdGlvbnMucmFuZ2VTZXBhcmF0b3IgOiAnXFx4MDAnKSk7XHJcblx0XHRcdHZhciBkYXRlcyA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGVzVGV4dC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR2YXIgZGF0ZSA9IGluc3Qub3B0aW9ucy5jYWxlbmRhci5wYXJzZURhdGUoaW5zdC5nZXQoJ2RhdGVGb3JtYXQnKSwgZGF0ZXNUZXh0W2ldKTtcclxuXHRcdFx0XHRcdGlmIChkYXRlKSB7XHJcblx0XHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGRhdGVzW2pdLmNvbXBhcmVUbyhkYXRlKSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmICghZm91bmQpIHtcclxuXHRcdFx0XHRcdFx0XHRkYXRlcy5wdXNoKGRhdGUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHQvLyBJZ25vcmVcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0ZXMuc3BsaWNlKGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCB8fCAoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ID8gMiA6IDEpLCBkYXRlcy5sZW5ndGgpO1xyXG5cdFx0XHRpZiAoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ICYmIGRhdGVzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRcdGRhdGVzWzFdID0gZGF0ZXNbMF07XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGRhdGVzO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogVXBkYXRlIHRoZSBkYXRlcGlja2VyIGRpc3BsYXkuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0V2ZW50fEVsZW1lbnR9IGEgZm9jdXMgZXZlbnQgb3IgdGhlIGNvbnRyb2wgdG8gdXNlLlxyXG5cdFx0XHRAcGFyYW0gaGlkZGVuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBpbml0aWFsbHkgaGlkZSB0aGUgZGF0ZXBpY2tlci4gKi9cclxuXHRcdF91cGRhdGU6IGZ1bmN0aW9uKGVsZW0sIGhpZGRlbikge1xyXG5cdFx0XHRlbGVtID0gJChlbGVtLnRhcmdldCB8fCBlbGVtKTtcclxuXHRcdFx0dmFyIGluc3QgPSBwbHVnaW4uX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XHJcblx0XHRcdFx0aWYgKGluc3QuaW5saW5lIHx8IHBsdWdpbi5jdXJJbnN0ID09PSBpbnN0KSB7XHJcblx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5vbkNoYW5nZU1vbnRoWWVhcikgJiYgKCFpbnN0LnByZXZEYXRlIHx8XHJcblx0XHRcdFx0XHRcdFx0aW5zdC5wcmV2RGF0ZS55ZWFyKCkgIT09IGluc3QuZHJhd0RhdGUueWVhcigpIHx8XHJcblx0XHRcdFx0XHRcdFx0aW5zdC5wcmV2RGF0ZS5tb250aCgpICE9PSBpbnN0LmRyYXdEYXRlLm1vbnRoKCkpKSB7XHJcblx0XHRcdFx0XHRcdGluc3Qub3B0aW9ucy5vbkNoYW5nZU1vbnRoWWVhci5hcHBseShlbGVtWzBdLFxyXG5cdFx0XHRcdFx0XHRcdFtpbnN0LmRyYXdEYXRlLnllYXIoKSwgaW5zdC5kcmF3RGF0ZS5tb250aCgpXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChpbnN0LmlubGluZSkge1xyXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gJCgnYSwgOmlucHV0JywgZWxlbSkuaW5kZXgoJCgnOmZvY3VzJywgZWxlbSkpO1xyXG5cdFx0XHRcdFx0ZWxlbS5odG1sKHRoaXMuX2dlbmVyYXRlQ29udGVudChlbGVtWzBdLCBpbnN0KSk7XHJcblx0XHRcdFx0XHR2YXIgZm9jdXMgPSBlbGVtLmZpbmQoJ2EsIDppbnB1dCcpO1xyXG5cdFx0XHRcdFx0Zm9jdXMuZXEoTWF0aC5tYXgoTWF0aC5taW4oaW5kZXgsIGZvY3VzLmxlbmd0aCAtIDEpLCAwKSkuZm9jdXMoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAocGx1Z2luLmN1ckluc3QgPT09IGluc3QpIHtcclxuXHRcdFx0XHRcdGlmICghaW5zdC5kaXYpIHtcclxuXHRcdFx0XHRcdFx0aW5zdC5kaXYgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKHRoaXMuX3BvcHVwQ2xhc3MpLlxyXG5cdFx0XHRcdFx0XHRcdGNzcyh7ZGlzcGxheTogKGhpZGRlbiA/ICdub25lJyA6ICdzdGF0aWMnKSwgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcblx0XHRcdFx0XHRcdFx0XHRsZWZ0OiBlbGVtLm9mZnNldCgpLmxlZnQsIHRvcDogZWxlbS5vZmZzZXQoKS50b3AgKyBlbGVtLm91dGVySGVpZ2h0KCl9KS5cclxuXHRcdFx0XHRcdFx0XHRhcHBlbmRUbygkKGluc3Qub3B0aW9ucy5wb3B1cENvbnRhaW5lciB8fCAnYm9keScpKTtcclxuXHRcdFx0XHRcdFx0aWYgKCQuZm4ubW91c2V3aGVlbCkge1xyXG5cdFx0XHRcdFx0XHRcdGluc3QuZGl2Lm1vdXNld2hlZWwodGhpcy5fZG9Nb3VzZVdoZWVsKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aW5zdC5kaXYuaHRtbCh0aGlzLl9nZW5lcmF0ZUNvbnRlbnQoZWxlbVswXSwgaW5zdCkpO1xyXG5cdFx0XHRcdFx0ZWxlbS5mb2N1cygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogVXBkYXRlIHRoZSBpbnB1dCBmaWVsZCBhbmQgYW55IGFsdGVybmF0ZSBmaWVsZCB3aXRoIHRoZSBjdXJyZW50IGRhdGVzLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byB1c2UuXHJcblx0XHRcdEBwYXJhbSBrZXlVcCB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgY29taW5nIGZyb20gPGNvZGU+a2V5VXA8L2NvZGU+IHByb2Nlc3NpbmcgKGludGVybmFsKS4gKi9cclxuXHRcdF91cGRhdGVJbnB1dDogZnVuY3Rpb24oZWxlbSwga2V5VXApIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xyXG5cdFx0XHRcdHZhciB2YWx1ZSA9ICcnO1xyXG5cdFx0XHRcdHZhciBhbHRWYWx1ZSA9ICcnO1xyXG5cdFx0XHRcdHZhciBzZXAgPSAoaW5zdC5vcHRpb25zLm11bHRpU2VsZWN0ID8gaW5zdC5vcHRpb25zLm11bHRpU2VwYXJhdG9yIDpcclxuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5yYW5nZVNlcGFyYXRvcik7XHJcblx0XHRcdFx0dmFyIGNhbGVuZGFyID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyO1xyXG5cdFx0XHRcdHZhciBkYXRlRm9ybWF0ID0gaW5zdC5nZXQoJ2RhdGVGb3JtYXQnKTtcclxuXHRcdFx0XHR2YXIgYWx0Rm9ybWF0ID0gaW5zdC5vcHRpb25zLmFsdEZvcm1hdCB8fCBkYXRlRm9ybWF0O1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YWx1ZSArPSAoa2V5VXAgPyAnJyA6IChpID4gMCA/IHNlcCA6ICcnKSArXHJcblx0XHRcdFx0XHRcdGNhbGVuZGFyLmZvcm1hdERhdGUoZGF0ZUZvcm1hdCwgaW5zdC5zZWxlY3RlZERhdGVzW2ldKSk7XHJcblx0XHRcdFx0XHRhbHRWYWx1ZSArPSAoaSA+IDAgPyBzZXAgOiAnJykgK1xyXG5cdFx0XHRcdFx0XHRjYWxlbmRhci5mb3JtYXREYXRlKGFsdEZvcm1hdCwgaW5zdC5zZWxlY3RlZERhdGVzW2ldKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCFpbnN0LmlubGluZSAmJiAha2V5VXApIHtcclxuXHRcdFx0XHRcdCQoZWxlbSkudmFsKHZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0JChpbnN0Lm9wdGlvbnMuYWx0RmllbGQpLnZhbChhbHRWYWx1ZSk7XHJcblx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMub25TZWxlY3QpICYmICFrZXlVcCAmJiAhaW5zdC5pblNlbGVjdCkge1xyXG5cdFx0XHRcdFx0aW5zdC5pblNlbGVjdCA9IHRydWU7IC8vIFByZXZlbnQgZW5kbGVzcyBsb29wc1xyXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLm9uU2VsZWN0LmFwcGx5KGVsZW0sIFtpbnN0LnNlbGVjdGVkRGF0ZXNdKTtcclxuXHRcdFx0XHRcdGluc3QuaW5TZWxlY3QgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFJldHJpZXZlIHRoZSBzaXplIG9mIGxlZnQgYW5kIHRvcCBib3JkZXJzIGZvciBhbiBlbGVtZW50LlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtqUXVlcnl9IFRoZSBlbGVtZW50IG9mIGludGVyZXN0LlxyXG5cdFx0XHRAcmV0dXJuIHtudW1iZXJbXX0gVGhlIGxlZnQgYW5kIHRvcCBib3JkZXJzLiAqL1xyXG5cdFx0X2dldEJvcmRlcnM6IGZ1bmN0aW9uKGVsZW0pIHtcclxuXHRcdFx0dmFyIGNvbnZlcnQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHRcdHJldHVybiB7dGhpbjogMSwgbWVkaXVtOiAzLCB0aGljazogNX1bdmFsdWVdIHx8IHZhbHVlO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRyZXR1cm4gW3BhcnNlRmxvYXQoY29udmVydChlbGVtLmNzcygnYm9yZGVyLWxlZnQtd2lkdGgnKSkpLFxyXG5cdFx0XHRcdHBhcnNlRmxvYXQoY29udmVydChlbGVtLmNzcygnYm9yZGVyLXRvcC13aWR0aCcpKSldO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ2hlY2sgcG9zaXRpb25pbmcgdG8gcmVtYWluIG9uIHRoZSBzY3JlZW4uXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEByZXR1cm4ge29iamVjdH0gVGhlIHVwZGF0ZWQgb2Zmc2V0IGZvciB0aGUgZGF0ZXBpY2tlci4gKi9cclxuXHRcdF9jaGVja09mZnNldDogZnVuY3Rpb24oaW5zdCkge1xyXG5cdFx0XHR2YXIgYmFzZSA9IChpbnN0LmVsZW0uaXMoJzpoaWRkZW4nKSAmJiBpbnN0LnRyaWdnZXIgPyBpbnN0LnRyaWdnZXIgOiBpbnN0LmVsZW0pO1xyXG5cdFx0XHR2YXIgb2Zmc2V0ID0gYmFzZS5vZmZzZXQoKTtcclxuXHRcdFx0dmFyIGJyb3dzZXJXaWR0aCA9ICQod2luZG93KS53aWR0aCgpO1xyXG5cdFx0XHR2YXIgYnJvd3NlckhlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKTtcclxuXHRcdFx0aWYgKGJyb3dzZXJXaWR0aCA9PT0gMCkge1xyXG5cdFx0XHRcdHJldHVybiBvZmZzZXQ7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGlzRml4ZWQgPSBmYWxzZTtcclxuXHRcdFx0JChpbnN0LmVsZW0pLnBhcmVudHMoKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlzRml4ZWQgfD0gJCh0aGlzKS5jc3MoJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCc7XHJcblx0XHRcdFx0cmV0dXJuICFpc0ZpeGVkO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0dmFyIHNjcm9sbFggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XHJcblx0XHRcdHZhciBzY3JvbGxZID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcclxuXHRcdFx0dmFyIGFib3ZlID0gb2Zmc2V0LnRvcCAtIChpc0ZpeGVkID8gc2Nyb2xsWSA6IDApIC0gaW5zdC5kaXYub3V0ZXJIZWlnaHQoKTtcclxuXHRcdFx0dmFyIGJlbG93ID0gb2Zmc2V0LnRvcCAtIChpc0ZpeGVkID8gc2Nyb2xsWSA6IDApICsgYmFzZS5vdXRlckhlaWdodCgpO1xyXG5cdFx0XHR2YXIgYWxpZ25MID0gb2Zmc2V0LmxlZnQgLSAoaXNGaXhlZCA/IHNjcm9sbFggOiAwKTtcclxuXHRcdFx0dmFyIGFsaWduUiA9IG9mZnNldC5sZWZ0IC0gKGlzRml4ZWQgPyBzY3JvbGxYIDogMCkgKyBiYXNlLm91dGVyV2lkdGgoKSAtIGluc3QuZGl2Lm91dGVyV2lkdGgoKTtcclxuXHRcdFx0dmFyIHRvb1dpZGUgPSAob2Zmc2V0LmxlZnQgLSBzY3JvbGxYICsgaW5zdC5kaXYub3V0ZXJXaWR0aCgpKSA+IGJyb3dzZXJXaWR0aDtcclxuXHRcdFx0dmFyIHRvb0hpZ2ggPSAob2Zmc2V0LnRvcCAtIHNjcm9sbFkgKyBpbnN0LmVsZW0ub3V0ZXJIZWlnaHQoKSArXHJcblx0XHRcdFx0aW5zdC5kaXYub3V0ZXJIZWlnaHQoKSkgPiBicm93c2VySGVpZ2h0O1xyXG5cdFx0XHRpbnN0LmRpdi5jc3MoJ3Bvc2l0aW9uJywgaXNGaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnKTtcclxuXHRcdFx0dmFyIGFsaWdubWVudCA9IGluc3Qub3B0aW9ucy5hbGlnbm1lbnQ7XHJcblx0XHRcdGlmIChhbGlnbm1lbnQgPT09ICd0b3BMZWZ0Jykge1xyXG5cdFx0XHRcdG9mZnNldCA9IHtsZWZ0OiBhbGlnbkwsIHRvcDogYWJvdmV9O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKGFsaWdubWVudCA9PT0gJ3RvcFJpZ2h0Jykge1xyXG5cdFx0XHRcdG9mZnNldCA9IHtsZWZ0OiBhbGlnblIsIHRvcDogYWJvdmV9O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKGFsaWdubWVudCA9PT0gJ2JvdHRvbUxlZnQnKSB7XHJcblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IGFsaWduTCwgdG9wOiBiZWxvd307XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoYWxpZ25tZW50ID09PSAnYm90dG9tUmlnaHQnKSB7XHJcblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IGFsaWduUiwgdG9wOiBiZWxvd307XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoYWxpZ25tZW50ID09PSAndG9wJykge1xyXG5cdFx0XHRcdG9mZnNldCA9IHtsZWZ0OiAoaW5zdC5vcHRpb25zLmlzUlRMIHx8IHRvb1dpZGUgPyBhbGlnblIgOiBhbGlnbkwpLCB0b3A6IGFib3ZlfTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHsgLy8gYm90dG9tXHJcblx0XHRcdFx0b2Zmc2V0ID0ge2xlZnQ6IChpbnN0Lm9wdGlvbnMuaXNSVEwgfHwgdG9vV2lkZSA/IGFsaWduUiA6IGFsaWduTCksXHJcblx0XHRcdFx0XHR0b3A6ICh0b29IaWdoID8gYWJvdmUgOiBiZWxvdyl9O1xyXG5cdFx0XHR9XHJcblx0XHRcdG9mZnNldC5sZWZ0ID0gTWF0aC5tYXgoKGlzRml4ZWQgPyAwIDogc2Nyb2xsWCksIG9mZnNldC5sZWZ0KTtcclxuXHRcdFx0b2Zmc2V0LnRvcCA9IE1hdGgubWF4KChpc0ZpeGVkID8gMCA6IHNjcm9sbFkpLCBvZmZzZXQudG9wKTtcclxuXHRcdFx0cmV0dXJuIG9mZnNldDtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIENsb3NlIGRhdGUgcGlja2VyIGlmIGNsaWNrZWQgZWxzZXdoZXJlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBldmVudCB7TW91c2VFdmVudH0gVGhlIG1vdXNlIGNsaWNrIHRvIGNoZWNrLiAqL1xyXG5cdFx0X2NoZWNrRXh0ZXJuYWxDbGljazogZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0aWYgKCFwbHVnaW4uY3VySW5zdCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgZWxlbSA9ICQoZXZlbnQudGFyZ2V0KTtcclxuXHRcdFx0aWYgKGVsZW0uY2xvc2VzdCgnLicgKyBwbHVnaW4uX3BvcHVwQ2xhc3MgKyAnLC4nICsgcGx1Z2luLl90cmlnZ2VyQ2xhc3MpLmxlbmd0aCA9PT0gMCAmJlxyXG5cdFx0XHRcdFx0IWVsZW0uaGFzQ2xhc3MocGx1Z2luLl9nZXRNYXJrZXIoKSkpIHtcclxuXHRcdFx0XHRwbHVnaW4uaGlkZShwbHVnaW4uY3VySW5zdCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEhpZGUgYSBwb3B1cCBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fG9iamVjdH0gVGhlIGNvbnRyb2wgdG8gdXNlIG9yIHRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcGFyYW0gaW1tZWRpYXRlIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiB0byBjbG9zZSBpbW1lZGlhdGVseSB3aXRob3V0IGFuaW1hdGlvbiAoaW50ZXJuYWwpLlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnaGlkZScpICovXHJcblx0XHRoaWRlOiBmdW5jdGlvbihlbGVtLCBpbW1lZGlhdGUpIHtcclxuXHRcdFx0aWYgKCFlbGVtKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xyXG5cdFx0XHRcdGluc3QgPSBlbGVtO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChpbnN0ICYmIGluc3QgPT09IHBsdWdpbi5jdXJJbnN0KSB7XHJcblx0XHRcdFx0dmFyIHNob3dBbmltID0gKGltbWVkaWF0ZSA/ICcnIDogaW5zdC5vcHRpb25zLnNob3dBbmltKTtcclxuXHRcdFx0XHR2YXIgc2hvd1NwZWVkID0gaW5zdC5vcHRpb25zLnNob3dTcGVlZDtcclxuXHRcdFx0XHRzaG93U3BlZWQgPSAoc2hvd1NwZWVkID09PSAnbm9ybWFsJyAmJiAkLnVpICYmXHJcblx0XHRcdFx0XHRwYXJzZUludCgkLnVpLnZlcnNpb24uc3Vic3RyaW5nKDIpKSA+PSA4ID8gJ19kZWZhdWx0JyA6IHNob3dTcGVlZCk7XHJcblx0XHRcdFx0dmFyIHBvc3RQcm9jZXNzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRpZiAoIWluc3QuZGl2KSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGluc3QuZGl2LnJlbW92ZSgpO1xyXG5cdFx0XHRcdFx0aW5zdC5kaXYgPSBudWxsO1xyXG5cdFx0XHRcdFx0cGx1Z2luLmN1ckluc3QgPSBudWxsO1xyXG5cdFx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMub25DbG9zZSkpIHtcclxuXHRcdFx0XHRcdFx0aW5zdC5vcHRpb25zLm9uQ2xvc2UuYXBwbHkoZWxlbSwgW2luc3Quc2VsZWN0ZWREYXRlc10pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0aW5zdC5kaXYuc3RvcCgpO1xyXG5cdFx0XHRcdGlmICgkLmVmZmVjdHMgJiYgKCQuZWZmZWN0c1tzaG93QW5pbV0gfHwgKCQuZWZmZWN0cy5lZmZlY3QgJiYgJC5lZmZlY3RzLmVmZmVjdFtzaG93QW5pbV0pKSkge1xyXG5cdFx0XHRcdFx0aW5zdC5kaXYuaGlkZShzaG93QW5pbSwgaW5zdC5vcHRpb25zLnNob3dPcHRpb25zLCBzaG93U3BlZWQsIHBvc3RQcm9jZXNzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgaGlkZUFuaW0gPSAoc2hvd0FuaW0gPT09ICdzbGlkZURvd24nID8gJ3NsaWRlVXAnIDpcclxuXHRcdFx0XHRcdFx0KHNob3dBbmltID09PSAnZmFkZUluJyA/ICdmYWRlT3V0JyA6ICdoaWRlJykpO1xyXG5cdFx0XHRcdFx0aW5zdC5kaXZbaGlkZUFuaW1dKChzaG93QW5pbSA/IHNob3dTcGVlZCA6ICcnKSwgcG9zdFByb2Nlc3MpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIXNob3dBbmltKSB7XHJcblx0XHRcdFx0XHRwb3N0UHJvY2VzcygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogSGFuZGxlIGtleXN0cm9rZXMgaW4gdGhlIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGV2ZW50IHtLZXlFdmVudH0gVGhlIGtleXN0cm9rZS5cclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgbm90IGhhbmRsZWQsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBoYW5kbGVkLiAqL1xyXG5cdFx0X2tleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdHZhciBlbGVtID0gKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lbGVtKSB8fCBldmVudC50YXJnZXQ7XHJcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHR2YXIgaGFuZGxlZCA9IGZhbHNlO1xyXG5cdFx0XHRpZiAoaW5zdC5pbmxpbmUgfHwgaW5zdC5kaXYpIHtcclxuXHRcdFx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gOSkgeyAvLyBUYWIgLSBjbG9zZVxyXG5cdFx0XHRcdFx0cGx1Z2luLmhpZGUoZWxlbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7IC8vIEVudGVyIC0gc2VsZWN0XHJcblx0XHRcdFx0XHRwbHVnaW4uc2VsZWN0RGF0ZShlbGVtLFxyXG5cdFx0XHRcdFx0XHQkKCdhLicgKyBpbnN0Lm9wdGlvbnMucmVuZGVyZXIuaGlnaGxpZ2h0ZWRDbGFzcywgaW5zdC5kaXYpWzBdKTtcclxuXHRcdFx0XHRcdGhhbmRsZWQgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHsgLy8gQ29tbWFuZCBrZXlzdHJva2VzXHJcblx0XHRcdFx0XHR2YXIgY29tbWFuZHMgPSBpbnN0Lm9wdGlvbnMuY29tbWFuZHM7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBuYW1lIGluIGNvbW1hbmRzKSB7XHJcblx0XHRcdFx0XHRcdHZhciBjb21tYW5kID0gY29tbWFuZHNbbmFtZV07XHJcblx0XHRcdFx0XHRcdGlmIChjb21tYW5kLmtleXN0cm9rZS5rZXlDb2RlID09PSBldmVudC5rZXlDb2RlICYmXHJcblx0XHRcdFx0XHRcdFx0XHQhIWNvbW1hbmQua2V5c3Ryb2tlLmN0cmxLZXkgPT09ICEhKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJiZcclxuXHRcdFx0XHRcdFx0XHRcdCEhY29tbWFuZC5rZXlzdHJva2UuYWx0S2V5ID09PSBldmVudC5hbHRLZXkgJiZcclxuXHRcdFx0XHRcdFx0XHRcdCEhY29tbWFuZC5rZXlzdHJva2Uuc2hpZnRLZXkgPT09IGV2ZW50LnNoaWZ0S2V5KSB7XHJcblx0XHRcdFx0XHRcdFx0cGx1Z2luLnBlcmZvcm1BY3Rpb24oZWxlbSwgbmFtZSk7XHJcblx0XHRcdFx0XHRcdFx0aGFuZGxlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7IC8vIFNob3cgb24gJ2N1cnJlbnQnIGtleXN0cm9rZVxyXG5cdFx0XHRcdHZhciBjb21tYW5kID0gaW5zdC5vcHRpb25zLmNvbW1hbmRzLmN1cnJlbnQ7XHJcblx0XHRcdFx0aWYgKGNvbW1hbmQua2V5c3Ryb2tlLmtleUNvZGUgPT09IGV2ZW50LmtleUNvZGUgJiZcclxuXHRcdFx0XHRcdFx0ISFjb21tYW5kLmtleXN0cm9rZS5jdHJsS2V5ID09PSAhIShldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICYmXHJcblx0XHRcdFx0XHRcdCEhY29tbWFuZC5rZXlzdHJva2UuYWx0S2V5ID09PSBldmVudC5hbHRLZXkgJiZcclxuXHRcdFx0XHRcdFx0ISFjb21tYW5kLmtleXN0cm9rZS5zaGlmdEtleSA9PT0gZXZlbnQuc2hpZnRLZXkpIHtcclxuXHRcdFx0XHRcdHBsdWdpbi5zaG93KGVsZW0pO1xyXG5cdFx0XHRcdFx0aGFuZGxlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGluc3QuY3RybEtleSA9ICgoZXZlbnQua2V5Q29kZSA8IDQ4ICYmIGV2ZW50LmtleUNvZGUgIT09IDMyKSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpO1xyXG5cdFx0XHRpZiAoaGFuZGxlZCkge1xyXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuICFoYW5kbGVkO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRmlsdGVyIGtleXN0cm9rZXMgaW4gdGhlIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGV2ZW50IHtLZXlFdmVudH0gVGhlIGtleXN0cm9rZS5cclxuXHRcdFx0QHJldHVybiB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgYWxsb3dlZCwgPGNvZGU+ZmFsc2U8L2NvZGU+IGlmIG5vdCBhbGxvd2VkLiAqL1xyXG5cdFx0X2tleVByZXNzOiBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdCgoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmVsZW0pIHx8IGV2ZW50LnRhcmdldCk7XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpICYmIGluc3Qub3B0aW9ucy5jb25zdHJhaW5JbnB1dCkge1xyXG5cdFx0XHRcdHZhciBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQua2V5Q29kZSB8fCBldmVudC5jaGFyQ29kZSk7XHJcblx0XHRcdFx0dmFyIGFsbG93ZWRDaGFycyA9IHBsdWdpbi5fYWxsb3dlZENoYXJzKGluc3QpO1xyXG5cdFx0XHRcdHJldHVybiAoZXZlbnQubWV0YUtleSB8fCBpbnN0LmN0cmxLZXkgfHwgY2ggPCAnICcgfHxcclxuXHRcdFx0XHRcdCFhbGxvd2VkQ2hhcnMgfHwgYWxsb3dlZENoYXJzLmluZGV4T2YoY2gpID4gLTEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogRGV0ZXJtaW5lIHRoZSBzZXQgb2YgY2hhcmFjdGVycyBhbGxvd2VkIGJ5IHRoZSBkYXRlIGZvcm1hdC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgc2V0IG9mIGFsbG93ZWQgY2hhcmFjdGVycywgb3IgPGNvZGU+bnVsbDwvY29kZT4gaWYgYW55dGhpbmcgYWxsb3dlZC4gKi9cclxuXHRcdF9hbGxvd2VkQ2hhcnM6IGZ1bmN0aW9uKGluc3QpIHtcclxuXHRcdFx0dmFyIGFsbG93ZWRDaGFycyA9IChpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QgPyBpbnN0Lm9wdGlvbnMubXVsdGlTZXBhcmF0b3IgOlxyXG5cdFx0XHRcdChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QgPyBpbnN0Lm9wdGlvbnMucmFuZ2VTZXBhcmF0b3IgOiAnJykpO1xyXG5cdFx0XHR2YXIgbGl0ZXJhbCA9IGZhbHNlO1xyXG5cdFx0XHR2YXIgaGFzTnVtID0gZmFsc2U7XHJcblx0XHRcdHZhciBkYXRlRm9ybWF0ID0gaW5zdC5nZXQoJ2RhdGVGb3JtYXQnKTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRlRm9ybWF0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGNoID0gZGF0ZUZvcm1hdC5jaGFyQXQoaSk7XHJcblx0XHRcdFx0aWYgKGxpdGVyYWwpIHtcclxuXHRcdFx0XHRcdGlmIChjaCA9PT0gXCInXCIgJiYgZGF0ZUZvcm1hdC5jaGFyQXQoaSArIDEpICE9PSBcIidcIikge1xyXG5cdFx0XHRcdFx0XHRsaXRlcmFsID0gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0YWxsb3dlZENoYXJzICs9IGNoO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHN3aXRjaCAoY2gpIHtcclxuXHRcdFx0XHRcdFx0Y2FzZSAnZCc6IGNhc2UgJ20nOiBjYXNlICdvJzogY2FzZSAndyc6XHJcblx0XHRcdFx0XHRcdFx0YWxsb3dlZENoYXJzICs9IChoYXNOdW0gPyAnJyA6ICcwMTIzNDU2Nzg5Jyk7IGhhc051bSA9IHRydWU7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICd5JzogY2FzZSAnQCc6IGNhc2UgJyEnOlxyXG5cdFx0XHRcdFx0XHRcdGFsbG93ZWRDaGFycyArPSAoaGFzTnVtID8gJycgOiAnMDEyMzQ1Njc4OScpICsgJy0nOyBoYXNOdW0gPSB0cnVlOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnSic6XHJcblx0XHRcdFx0XHRcdFx0YWxsb3dlZENoYXJzICs9IChoYXNOdW0gPyAnJyA6ICcwMTIzNDU2Nzg5JykgKyAnLS4nOyBoYXNOdW0gPSB0cnVlOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnRCc6IGNhc2UgJ00nOiBjYXNlICdZJzpcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDsgLy8gQWNjZXB0IGFueXRoaW5nXHJcblx0XHRcdFx0XHRcdGNhc2UgXCInXCI6XHJcblx0XHRcdFx0XHRcdFx0aWYgKGRhdGVGb3JtYXQuY2hhckF0KGkgKyAxKSA9PT0gXCInXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGFsbG93ZWRDaGFycyArPSBcIidcIjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRsaXRlcmFsID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdFx0YWxsb3dlZENoYXJzICs9IGNoO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gYWxsb3dlZENoYXJzO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU3luY2hyb25pc2UgZGF0ZXBpY2tlciB3aXRoIHRoZSBmaWVsZC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZXZlbnQge0tleUV2ZW50fSBUaGUga2V5c3Ryb2tlLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBhbGxvd2VkLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90IGFsbG93ZWQuICovXHJcblx0XHRfa2V5VXA6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdHZhciBlbGVtID0gKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5lbGVtKSB8fCBldmVudC50YXJnZXQ7XHJcblx0XHRcdHZhciBpbnN0ID0gcGx1Z2luLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSAmJiAhaW5zdC5jdHJsS2V5ICYmIGluc3QubGFzdFZhbCAhPT0gaW5zdC5lbGVtLnZhbCgpKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHZhciBkYXRlcyA9IHBsdWdpbi5fZXh0cmFjdERhdGVzKGluc3QsIGluc3QuZWxlbS52YWwoKSk7XHJcblx0XHRcdFx0XHRpZiAoZGF0ZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0XHRwbHVnaW4uc2V0RGF0ZShlbGVtLCBkYXRlcywgbnVsbCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhdGNoIChldmVudCkge1xyXG5cdFx0XHRcdFx0Ly8gSWdub3JlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogSW5jcmVtZW50L2RlY3JlbWVudCBtb250aC95ZWFyIG9uIG1vdXNlIHdoZWVsIGFjdGl2aXR5LlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBldmVudCB7ZXZlbnR9IFRoZSBtb3VzZSB3aGVlbCBldmVudC5cclxuXHRcdFx0QHBhcmFtIGRlbHRhIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgY2hhbmdlLiAqL1xyXG5cdFx0X2RvTW91c2VXaGVlbDogZnVuY3Rpb24oZXZlbnQsIGRlbHRhKSB7XHJcblx0XHRcdHZhciBlbGVtID0gKHBsdWdpbi5jdXJJbnN0ICYmIHBsdWdpbi5jdXJJbnN0LmVsZW1bMF0pIHx8XHJcblx0XHRcdFx0JChldmVudC50YXJnZXQpLmNsb3Nlc3QoJy4nICsgcGx1Z2luLl9nZXRNYXJrZXIoKSlbMF07XHJcblx0XHRcdGlmIChwbHVnaW4uaXNEaXNhYmxlZChlbGVtKSkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgaW5zdCA9IHBsdWdpbi5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy51c2VNb3VzZVdoZWVsKSB7XHJcblx0XHRcdFx0ZGVsdGEgPSAoZGVsdGEgPCAwID8gLTEgOiArMSk7XHJcblx0XHRcdFx0cGx1Z2luLmNoYW5nZU1vbnRoKGVsZW0sIC1pbnN0Lm9wdGlvbnNbZXZlbnQuY3RybEtleSA/ICdtb250aHNUb0p1bXAnIDogJ21vbnRoc1RvU3RlcCddICogZGVsdGEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBDbGVhciBhbiBpbnB1dCBhbmQgY2xvc2UgYSBwb3B1cCBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byB1c2UuXHJcblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdjbGVhcicpICovXHJcblx0XHRjbGVhcjogZnVuY3Rpb24oZWxlbSkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XHJcblx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzID0gW107XHJcblx0XHRcdFx0dGhpcy5oaWRlKGVsZW0pO1xyXG5cdFx0XHRcdHZhciBkZWZhdWx0RGF0ZSA9IGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpO1xyXG5cdFx0XHRcdGlmIChpbnN0Lm9wdGlvbnMuc2VsZWN0RGVmYXVsdERhdGUgJiYgZGVmYXVsdERhdGUpIHtcclxuXHRcdFx0XHRcdHRoaXMuc2V0RGF0ZShlbGVtLCAoZGVmYXVsdERhdGUgfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCkpLm5ld0RhdGUoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlSW5wdXQoZWxlbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBSZXRyaWV2ZSB0aGUgc2VsZWN0ZWQgZGF0ZShzKSBmb3IgYSBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZVtdfSBUaGUgc2VsZWN0ZWQgZGF0ZShzKS5cclxuXHRcdFx0QGV4YW1wbGUgdmFyIGRhdGVzID0gJChzZWxlY3RvcikuZGF0ZXBpY2soJ2dldERhdGUnKSAqL1xyXG5cdFx0Z2V0RGF0ZTogZnVuY3Rpb24oZWxlbSkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdHJldHVybiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSA/IGluc3Quc2VsZWN0ZWREYXRlcyA6IFtdKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFNldCB0aGUgc2VsZWN0ZWQgZGF0ZShzKSBmb3IgYSBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSB0aGUgY29udHJvbCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gZGF0ZXMge0NEYXRlfG51bWJlcnxzdHJpbmd8YXJyYXl9IHRoZSBzZWxlY3RlZCBkYXRlKHMpLlxyXG5cdFx0XHRAcGFyYW0gW2VuZERhdGVdIHtDRGF0ZXxudW1iZXJ8c3RyaW5nfSB0aGUgZW5kaW5nIGRhdGUgZm9yIGEgcmFuZ2UuXHJcblx0XHRcdEBwYXJhbSBba2V5VXBdIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBjb21pbmcgZnJvbSA8Y29kZT5rZXlVcDwvY29kZT4gcHJvY2Vzc2luZyAoaW50ZXJuYWwpLlxyXG5cdFx0XHRAcGFyYW0gW3NldE9wdF0ge2Jvb2xlYW59IDxjb2RlPnRydWU8L2NvZGU+IGlmIGNvbWluZyBmcm9tIG9wdGlvbiBwcm9jZXNzaW5nIChpbnRlcm5hbCkuXHJcblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdzZXREYXRlJywgbmV3IERhdGUoMjAxNCwgMTItMSwgMjUpKVxyXG4gJChzZWxlY3RvcikuZGF0ZXBpY2soJ3NldERhdGUnLCAnMTIvMjUvMjAxNCcsICcwMS8wMS8yMDE1JylcclxuICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdzZXREYXRlJywgW2RhdGUxLCBkYXRlMiwgZGF0ZTNdKSAqL1xyXG5cdFx0c2V0RGF0ZTogZnVuY3Rpb24oZWxlbSwgZGF0ZXMsIGVuZERhdGUsIGtleVVwLCBzZXRPcHQpIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xyXG5cdFx0XHRcdGlmICghJC5pc0FycmF5KGRhdGVzKSkge1xyXG5cdFx0XHRcdFx0ZGF0ZXMgPSBbZGF0ZXNdO1xyXG5cdFx0XHRcdFx0aWYgKGVuZERhdGUpIHtcclxuXHRcdFx0XHRcdFx0ZGF0ZXMucHVzaChlbmREYXRlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIG1pbkRhdGUgPSBpbnN0LmdldCgnbWluRGF0ZScpO1xyXG5cdFx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcclxuXHRcdFx0XHR2YXIgY3VyRGF0ZSA9IGluc3Quc2VsZWN0ZWREYXRlc1swXTtcclxuXHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMgPSBbXTtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgZGF0ZSA9IGluc3Qub3B0aW9ucy5jYWxlbmRhci5kZXRlcm1pbmVEYXRlKFxyXG5cdFx0XHRcdFx0XHRkYXRlc1tpXSwgbnVsbCwgY3VyRGF0ZSwgaW5zdC5nZXQoJ2RhdGVGb3JtYXQnKSwgaW5zdC5nZXRDb25maWcoKSk7XHJcblx0XHRcdFx0XHRpZiAoZGF0ZSkge1xyXG5cdFx0XHRcdFx0XHRpZiAoKCFtaW5EYXRlIHx8IGRhdGUuY29tcGFyZVRvKG1pbkRhdGUpICE9PSAtMSkgJiZcclxuXHRcdFx0XHRcdFx0XHRcdCghbWF4RGF0ZSB8fCBkYXRlLmNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGZvdW5kID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChpbnN0LnNlbGVjdGVkRGF0ZXNbal0uY29tcGFyZVRvKGRhdGUpID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmICghZm91bmQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcy5wdXNoKGRhdGUpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXMuc3BsaWNlKGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCB8fFxyXG5cdFx0XHRcdFx0KGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCA/IDIgOiAxKSwgaW5zdC5zZWxlY3RlZERhdGVzLmxlbmd0aCk7XHJcblx0XHRcdFx0aWYgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCkge1xyXG5cdFx0XHRcdFx0c3dpdGNoIChpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdGNhc2UgMTogaW5zdC5zZWxlY3RlZERhdGVzWzFdID0gaW5zdC5zZWxlY3RlZERhdGVzWzBdOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAyOiBpbnN0LnNlbGVjdGVkRGF0ZXNbMV0gPVxyXG5cdFx0XHRcdFx0XHRcdChpbnN0LnNlbGVjdGVkRGF0ZXNbMF0uY29tcGFyZVRvKGluc3Quc2VsZWN0ZWREYXRlc1sxXSkgPT09ICsxID9cclxuXHRcdFx0XHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gOiBpbnN0LnNlbGVjdGVkRGF0ZXNbMV0pOyBicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGluc3QucGlja2luZ1JhbmdlID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGluc3QucHJldkRhdGUgPSAoaW5zdC5kcmF3RGF0ZSA/IGluc3QuZHJhd0RhdGUubmV3RGF0ZSgpIDogbnVsbCk7XHJcblx0XHRcdFx0aW5zdC5kcmF3RGF0ZSA9IHRoaXMuX2NoZWNrTWluTWF4KChpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gfHxcclxuXHRcdFx0XHRcdGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpKS5uZXdEYXRlKCksIGluc3QpO1xyXG5cdFx0XHRcdGlmICghc2V0T3B0KSB7XHJcblx0XHRcdFx0XHR0aGlzLl91cGRhdGUoZWxlbSk7XHJcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVJbnB1dChlbGVtLCBrZXlVcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBEZXRlcm1pbmUgd2hldGhlciBhIGRhdGUgaXMgc2VsZWN0YWJsZSBmb3IgdGhpcyBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBjaGVjay5cclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfHN0cmluZ3xudW1iZXJ9IFRoZSBkYXRlIHRvIGNoZWNrLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBzZWxlY3RhYmxlLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LlxyXG5cdFx0XHRAZXhhbXBsZSB2YXIgc2VsZWN0YWJsZSA9ICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdpc1NlbGVjdGFibGUnLCBkYXRlKSAqL1xyXG5cdFx0aXNTZWxlY3RhYmxlOiBmdW5jdGlvbihlbGVtLCBkYXRlKSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRlID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyLmRldGVybWluZURhdGUoZGF0ZSxcclxuXHRcdFx0XHRpbnN0LnNlbGVjdGVkRGF0ZXNbMF0gfHwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLnRvZGF5KCksIG51bGwsXHJcblx0XHRcdFx0aW5zdC5vcHRpb25zLmRhdGVGb3JtYXQsIGluc3QuZ2V0Q29uZmlnKCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5faXNTZWxlY3RhYmxlKGVsZW0sIGRhdGUsIGluc3Qub3B0aW9ucy5vbkRhdGUsXHJcblx0XHRcdFx0aW5zdC5nZXQoJ21pbkRhdGUnKSwgaW5zdC5nZXQoJ21heERhdGUnKSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBJbnRlcm5hbGx5IGRldGVybWluZSB3aGV0aGVyIGEgZGF0ZSBpcyBzZWxlY3RhYmxlIGZvciB0aGlzIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHByaXZhdGVcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IHRoZSBjb250cm9sIHRvIGNoZWNrLlxyXG5cdFx0XHRAcGFyYW0gZGF0ZSB7Q0RhdGV9IFRoZSBkYXRlIHRvIGNoZWNrLlxyXG5cdFx0XHRAcGFyYW0gb25EYXRlIHtmdW5jdGlvbnxib29sZWFufSBBbnkgPGNvZGU+b25EYXRlPC9jb2RlPiBjYWxsYmFjayBvciA8Y29kZT5jYWxsYmFjay5zZWxlY3RhYmxlPC9jb2RlPi5cclxuXHRcdFx0QHBhcmFtIG1pbkRhdGUge0NEYXRlfSBUaGUgbWluaW11bSBhbGxvd2VkIGRhdGUuXHJcblx0XHRcdEBwYXJhbSBtYXhEYXRlIHtDRGF0ZX0gVGhlIG1heGltdW0gYWxsb3dlZCBkYXRlLlxyXG5cdFx0XHRAcmV0dXJuIHtib29sZWFufSA8Y29kZT50cnVlPC9jb2RlPiBpZiBzZWxlY3RhYmxlLCA8Y29kZT5mYWxzZTwvY29kZT4gaWYgbm90LiAqL1xyXG5cdFx0X2lzU2VsZWN0YWJsZTogZnVuY3Rpb24oZWxlbSwgZGF0ZSwgb25EYXRlLCBtaW5EYXRlLCBtYXhEYXRlKSB7XHJcblx0XHRcdHZhciBkYXRlSW5mbyA9ICh0eXBlb2Ygb25EYXRlID09PSAnYm9vbGVhbicgPyB7c2VsZWN0YWJsZTogb25EYXRlfSA6XHJcblx0XHRcdFx0KCEkLmlzRnVuY3Rpb24ob25EYXRlKSA/IHt9IDogb25EYXRlLmFwcGx5KGVsZW0sIFtkYXRlLCB0cnVlXSkpKTtcclxuXHRcdFx0cmV0dXJuIChkYXRlSW5mby5zZWxlY3RhYmxlICE9PSBmYWxzZSkgJiZcclxuXHRcdFx0XHQoIW1pbkRhdGUgfHwgZGF0ZS50b0pEKCkgPj0gbWluRGF0ZS50b0pEKCkpICYmICghbWF4RGF0ZSB8fCBkYXRlLnRvSkQoKSA8PSBtYXhEYXRlLnRvSkQoKSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBQZXJmb3JtIGEgbmFtZWQgYWN0aW9uIGZvciBhIGRhdGVwaWNrZXIuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge2VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cclxuXHRcdFx0QHBhcmFtIGFjdGlvbiB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgYWN0aW9uLiAqL1xyXG5cdFx0cGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oZWxlbSwgYWN0aW9uKSB7XHJcblx0XHRcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdChlbGVtKTtcclxuXHRcdFx0aWYgKCEkLmlzRW1wdHlPYmplY3QoaW5zdCkgJiYgIXRoaXMuaXNEaXNhYmxlZChlbGVtKSkge1xyXG5cdFx0XHRcdHZhciBjb21tYW5kcyA9IGluc3Qub3B0aW9ucy5jb21tYW5kcztcclxuXHRcdFx0XHRpZiAoY29tbWFuZHNbYWN0aW9uXSAmJiBjb21tYW5kc1thY3Rpb25dLmVuYWJsZWQuYXBwbHkoZWxlbSwgW2luc3RdKSkge1xyXG5cdFx0XHRcdFx0Y29tbWFuZHNbYWN0aW9uXS5hY3Rpb24uYXBwbHkoZWxlbSwgW2luc3RdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFNldCB0aGUgY3VycmVudGx5IHNob3duIG1vbnRoLCBkZWZhdWx0aW5nIHRvIHRvZGF5J3MuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cclxuXHRcdFx0QHBhcmFtIFt5ZWFyXSB7bnVtYmVyfSBUaGUgeWVhciB0byBzaG93LlxyXG5cdFx0XHRAcGFyYW0gW21vbnRoXSB7bnVtYmVyfSBUaGUgbW9udGggdG8gc2hvdyAoMS0xMikuXHJcblx0XHRcdEBwYXJhbSBbZGF5XSB7bnVtYmVyfSBUaGUgZGF5IHRvIHNob3cuXHJcblx0XHRcdEBleGFtcGxlICQoc2VsZWN0b3IpLmRhdGVwaWNrKCdzaG93TW9udGgnLCAyMDE0LCAxMiwgMjUpICovXHJcblx0XHRzaG93TW9udGg6IGZ1bmN0aW9uKGVsZW0sIHllYXIsIG1vbnRoLCBkYXkpIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSAmJiAoZGF5ICE9IG51bGwgfHxcclxuXHRcdFx0XHRcdChpbnN0LmRyYXdEYXRlLnllYXIoKSAhPT0geWVhciB8fCBpbnN0LmRyYXdEYXRlLm1vbnRoKCkgIT09IG1vbnRoKSkpIHtcclxuXHRcdFx0XHRpbnN0LnByZXZEYXRlID0gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCk7XHJcblx0XHRcdFx0dmFyIGNhbGVuZGFyID0gaW5zdC5vcHRpb25zLmNhbGVuZGFyO1xyXG5cdFx0XHRcdHZhciBzaG93ID0gdGhpcy5fY2hlY2tNaW5NYXgoKHllYXIgIT0gbnVsbCA/XHJcblx0XHRcdFx0XHRjYWxlbmRhci5uZXdEYXRlKHllYXIsIG1vbnRoLCAxKSA6IGNhbGVuZGFyLnRvZGF5KCkpLCBpbnN0KTtcclxuXHRcdFx0XHRpbnN0LmRyYXdEYXRlLmRhdGUoc2hvdy55ZWFyKCksIHNob3cubW9udGgoKSwgXHJcblx0XHRcdFx0XHQoZGF5ICE9IG51bGwgPyBkYXkgOiBNYXRoLm1pbihpbnN0LmRyYXdEYXRlLmRheSgpLFxyXG5cdFx0XHRcdFx0Y2FsZW5kYXIuZGF5c0luTW9udGgoc2hvdy55ZWFyKCksIHNob3cubW9udGgoKSkpKSk7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlKGVsZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBBZGp1c3QgdGhlIGN1cnJlbnRseSBzaG93biBtb250aC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxyXG5cdFx0XHRAcGFyYW0gb2Zmc2V0IHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbW9udGhzIHRvIGNoYW5nZSBieS5cclxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ2NoYW5nZU1vbnRoJywgMikqL1xyXG5cdFx0Y2hhbmdlTW9udGg6IGZ1bmN0aW9uKGVsZW0sIG9mZnNldCkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpKSB7XHJcblx0XHRcdFx0dmFyIGRhdGUgPSBpbnN0LmRyYXdEYXRlLm5ld0RhdGUoKS5hZGQob2Zmc2V0LCAnbScpO1xyXG5cdFx0XHRcdHRoaXMuc2hvd01vbnRoKGVsZW0sIGRhdGUueWVhcigpLCBkYXRlLm1vbnRoKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBBZGp1c3QgdGhlIGN1cnJlbnRseSBzaG93biBkYXkuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGVsZW0ge0VsZW1lbnR9IFRoZSBjb250cm9sIHRvIGFmZmVjdC5cclxuXHRcdFx0QHBhcmFtIG9mZnNldCB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGRheXMgdG8gY2hhbmdlIGJ5LlxyXG5cdFx0XHRAZXhhbXBsZSAkKHNlbGVjdG9yKS5kYXRlcGljaygnY2hhbmdlRGF5JywgNykqL1xyXG5cdFx0Y2hhbmdlRGF5OiBmdW5jdGlvbihlbGVtLCBvZmZzZXQpIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRpZiAoISQuaXNFbXB0eU9iamVjdChpbnN0KSkge1xyXG5cdFx0XHRcdHZhciBkYXRlID0gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKG9mZnNldCwgJ2QnKTtcclxuXHRcdFx0XHR0aGlzLnNob3dNb250aChlbGVtLCBkYXRlLnllYXIoKSwgZGF0ZS5tb250aCgpLCBkYXRlLmRheSgpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmVzdHJpY3QgYSBkYXRlIHRvIHRoZSBtaW5pbXVtL21heGltdW0gc3BlY2lmaWVkLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIGRhdGUgdG8gY2hlY2suXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLiAqL1xyXG5cdFx0X2NoZWNrTWluTWF4OiBmdW5jdGlvbihkYXRlLCBpbnN0KSB7XHJcblx0XHRcdHZhciBtaW5EYXRlID0gaW5zdC5nZXQoJ21pbkRhdGUnKTtcclxuXHRcdFx0dmFyIG1heERhdGUgPSBpbnN0LmdldCgnbWF4RGF0ZScpO1xyXG5cdFx0XHRkYXRlID0gKG1pbkRhdGUgJiYgZGF0ZS5jb21wYXJlVG8obWluRGF0ZSkgPT09IC0xID8gbWluRGF0ZS5uZXdEYXRlKCkgOiBkYXRlKTtcclxuXHRcdFx0ZGF0ZSA9IChtYXhEYXRlICYmIGRhdGUuY29tcGFyZVRvKG1heERhdGUpID09PSArMSA/IG1heERhdGUubmV3RGF0ZSgpIDogZGF0ZSk7XHJcblx0XHRcdHJldHVybiBkYXRlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogUmV0cmlldmUgdGhlIGRhdGUgYXNzb2NpYXRlZCB3aXRoIGFuIGVudHJ5IGluIHRoZSBkYXRlcGlja2VyLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBleGFtaW5lLlxyXG5cdFx0XHRAcGFyYW0gdGFyZ2V0IHtFbGVtZW50fSBUaGUgc2VsZWN0ZWQgZGF0ZXBpY2tlciBlbGVtZW50LlxyXG5cdFx0XHRAcmV0dXJuIHtDRGF0ZX0gVGhlIGNvcnJlc3BvbmRpbmcgZGF0ZSwgb3IgPGNvZGU+bnVsbDwvY29kZT4uXHRcdFx0XHJcblx0XHRcdEBleGFtcGxlIHZhciBkYXRlID0gJChzZWxlY3RvcikuZGF0ZXBpY2soJ3JldHJpZXZlRGF0ZScsICQoJ2Rpdi5kYXRlcGljay1wb3B1cCBhOmNvbnRhaW5zKDEwKScpWzBdKSAqL1xyXG5cdFx0cmV0cmlldmVEYXRlOiBmdW5jdGlvbihlbGVtLCB0YXJnZXQpIHtcclxuXHRcdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KGVsZW0pO1xyXG5cdFx0XHRyZXR1cm4gKCQuaXNFbXB0eU9iamVjdChpbnN0KSA/IG51bGwgOiBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIuZnJvbUpEKFxyXG5cdFx0XHRcdHBhcnNlRmxvYXQodGFyZ2V0LmNsYXNzTmFtZS5yZXBsYWNlKC9eLipqZChcXGQrXFwuNSkuKiQvLCAnJDEnKSkpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFNlbGVjdCBhIGRhdGUgZm9yIHRoaXMgZGF0ZXBpY2tlci5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gZXhhbWluZS5cclxuXHRcdFx0QHBhcmFtIHRhcmdldCB7RWxlbWVudH0gVGhlIHNlbGVjdGVkIGRhdGVwaWNrZXIgZWxlbWVudC5cclxuXHRcdFx0QGV4YW1wbGUgJChzZWxlY3RvcikuZGF0ZXBpY2soJ3NlbGVjdERhdGUnLCAkKCdkaXYuZGF0ZXBpY2stcG9wdXAgYTpjb250YWlucygxMCknKVswXSkgKi9cclxuXHRcdHNlbGVjdERhdGU6IGZ1bmN0aW9uKGVsZW0sIHRhcmdldCkge1xyXG5cdFx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoZWxlbSk7XHJcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KGluc3QpICYmICF0aGlzLmlzRGlzYWJsZWQoZWxlbSkpIHtcclxuXHRcdFx0XHR2YXIgZGF0ZSA9IHRoaXMucmV0cmlldmVEYXRlKGVsZW0sIHRhcmdldCk7XHJcblx0XHRcdFx0aWYgKGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCkge1xyXG5cdFx0XHRcdFx0dmFyIGZvdW5kID0gZmFsc2U7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRpZiAoZGF0ZS5jb21wYXJlVG8oaW5zdC5zZWxlY3RlZERhdGVzW2ldKSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlcy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoIWZvdW5kICYmIGluc3Quc2VsZWN0ZWREYXRlcy5sZW5ndGggPCBpbnN0Lm9wdGlvbnMubXVsdGlTZWxlY3QpIHtcclxuXHRcdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzLnB1c2goZGF0ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCkge1xyXG5cdFx0XHRcdFx0aWYgKGluc3QucGlja2luZ1JhbmdlKSB7XHJcblx0XHRcdFx0XHRcdGluc3Quc2VsZWN0ZWREYXRlc1sxXSA9IGRhdGU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzID0gW2RhdGUsIGRhdGVdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aW5zdC5waWNraW5nUmFuZ2UgPSAhaW5zdC5waWNraW5nUmFuZ2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aW5zdC5zZWxlY3RlZERhdGVzID0gW2RhdGVdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpbnN0LnByZXZEYXRlID0gaW5zdC5kcmF3RGF0ZSA9IGRhdGUubmV3RGF0ZSgpO1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUlucHV0KGVsZW0pO1xyXG5cdFx0XHRcdGlmIChpbnN0LmlubGluZSB8fCBpbnN0LnBpY2tpbmdSYW5nZSB8fCBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoIDxcclxuXHRcdFx0XHRcdFx0KGluc3Qub3B0aW9ucy5tdWx0aVNlbGVjdCB8fCAoaW5zdC5vcHRpb25zLnJhbmdlU2VsZWN0ID8gMiA6IDEpKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlKGVsZW0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuaGlkZShlbGVtKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEdlbmVyYXRlIHRoZSBkYXRlcGlja2VyIGNvbnRlbnQgZm9yIHRoaXMgY29udHJvbC5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gZWxlbSB7RWxlbWVudH0gVGhlIGNvbnRyb2wgdG8gYWZmZWN0LlxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHJldHVybiB7alF1ZXJ5fSBUaGUgZGF0ZXBpY2tlciBjb250ZW50ICovXHJcblx0XHRfZ2VuZXJhdGVDb250ZW50OiBmdW5jdGlvbihlbGVtLCBpbnN0KSB7XHJcblx0XHRcdHZhciBtb250aHNUb1Nob3cgPSBpbnN0Lm9wdGlvbnMubW9udGhzVG9TaG93O1xyXG5cdFx0XHRtb250aHNUb1Nob3cgPSAoJC5pc0FycmF5KG1vbnRoc1RvU2hvdykgPyBtb250aHNUb1Nob3cgOiBbMSwgbW9udGhzVG9TaG93XSk7XHJcblx0XHRcdGluc3QuZHJhd0RhdGUgPSB0aGlzLl9jaGVja01pbk1heChcclxuXHRcdFx0XHRpbnN0LmRyYXdEYXRlIHx8IGluc3QuZ2V0KCdkZWZhdWx0RGF0ZScpIHx8IGluc3Qub3B0aW9ucy5jYWxlbmRhci50b2RheSgpLCBpbnN0KTtcclxuXHRcdFx0dmFyIGRyYXdEYXRlID0gaW5zdC5kcmF3RGF0ZS5uZXdEYXRlKCkuYWRkKC1pbnN0Lm9wdGlvbnMubW9udGhzT2Zmc2V0LCAnbScpO1xyXG5cdFx0XHQvLyBHZW5lcmF0ZSBtb250aHNcclxuXHRcdFx0dmFyIG1vbnRoUm93cyA9ICcnO1xyXG5cdFx0XHRmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb250aHNUb1Nob3dbMF07IHJvdysrKSB7XHJcblx0XHRcdFx0dmFyIG1vbnRocyA9ICcnO1xyXG5cdFx0XHRcdGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vbnRoc1RvU2hvd1sxXTsgY29sKyspIHtcclxuXHRcdFx0XHRcdG1vbnRocyArPSB0aGlzLl9nZW5lcmF0ZU1vbnRoKGVsZW0sIGluc3QsIGRyYXdEYXRlLnllYXIoKSxcclxuXHRcdFx0XHRcdFx0ZHJhd0RhdGUubW9udGgoKSwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLCBpbnN0Lm9wdGlvbnMucmVuZGVyZXIsIChyb3cgPT09IDAgJiYgY29sID09PSAwKSk7XHJcblx0XHRcdFx0XHRkcmF3RGF0ZS5hZGQoMSwgJ20nKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bW9udGhSb3dzICs9IHRoaXMuX3ByZXBhcmUoaW5zdC5vcHRpb25zLnJlbmRlcmVyLm1vbnRoUm93LCBpbnN0KS5yZXBsYWNlKC9cXHttb250aHNcXH0vLCBtb250aHMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBwaWNrZXIgPSB0aGlzLl9wcmVwYXJlKGluc3Qub3B0aW9ucy5yZW5kZXJlci5waWNrZXIsIGluc3QpLnJlcGxhY2UoL1xce21vbnRoc1xcfS8sIG1vbnRoUm93cykuXHJcblx0XHRcdFx0cmVwbGFjZSgvXFx7d2Vla0hlYWRlclxcfS9nLCB0aGlzLl9nZW5lcmF0ZURheUhlYWRlcnMoaW5zdCwgaW5zdC5vcHRpb25zLmNhbGVuZGFyLCBpbnN0Lm9wdGlvbnMucmVuZGVyZXIpKTtcclxuXHRcdFx0Ly8gQWRkIGNvbW1hbmRzXHJcblx0XHRcdHZhciBhZGRDb21tYW5kID0gZnVuY3Rpb24odHlwZSwgb3BlbiwgY2xvc2UsIG5hbWUsIGNsYXNzZXMpIHtcclxuXHRcdFx0XHRpZiAocGlja2VyLmluZGV4T2YoJ3snICsgdHlwZSArICc6JyArIG5hbWUgKyAnfScpID09PSAtMSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgY29tbWFuZCA9IGluc3Qub3B0aW9ucy5jb21tYW5kc1tuYW1lXTtcclxuXHRcdFx0XHR2YXIgZGF0ZSA9IChpbnN0Lm9wdGlvbnMuY29tbWFuZHNBc0RhdGVGb3JtYXQgPyBjb21tYW5kLmRhdGUuYXBwbHkoZWxlbSwgW2luc3RdKSA6IG51bGwpO1xyXG5cdFx0XHRcdHBpY2tlciA9IHBpY2tlci5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFx7JyArIHR5cGUgKyAnOicgKyBuYW1lICsgJ1xcXFx9JywgJ2cnKSxcclxuXHRcdFx0XHRcdCc8JyArIG9wZW4gKyAoY29tbWFuZC5zdGF0dXMgPyAnIHRpdGxlPVwiJyArIGluc3Qub3B0aW9uc1tjb21tYW5kLnN0YXR1c10gKyAnXCInIDogJycpICtcclxuXHRcdFx0XHRcdCcgY2xhc3M9XCInICsgaW5zdC5vcHRpb25zLnJlbmRlcmVyLmNvbW1hbmRDbGFzcyArICcgJyArXHJcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMucmVuZGVyZXIuY29tbWFuZENsYXNzICsgJy0nICsgbmFtZSArICcgJyArIGNsYXNzZXMgK1xyXG5cdFx0XHRcdFx0KGNvbW1hbmQuZW5hYmxlZChpbnN0KSA/ICcnIDogJyAnICsgaW5zdC5vcHRpb25zLnJlbmRlcmVyLmRpc2FibGVkQ2xhc3MpICsgJ1wiPicgK1xyXG5cdFx0XHRcdFx0KGRhdGUgPyBkYXRlLmZvcm1hdERhdGUoaW5zdC5vcHRpb25zW2NvbW1hbmQudGV4dF0pIDpcclxuXHRcdFx0XHRcdGluc3Qub3B0aW9uc1tjb21tYW5kLnRleHRdKSArICc8LycgKyBjbG9zZSArICc+Jyk7XHJcblx0XHRcdH07XHJcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gaW5zdC5vcHRpb25zLmNvbW1hbmRzKSB7XHJcblx0XHRcdFx0YWRkQ29tbWFuZCgnYnV0dG9uJywgJ2J1dHRvbiB0eXBlPVwiYnV0dG9uXCInLCAnYnV0dG9uJywgbmFtZSxcclxuXHRcdFx0XHRcdGluc3Qub3B0aW9ucy5yZW5kZXJlci5jb21tYW5kQnV0dG9uQ2xhc3MpO1xyXG5cdFx0XHRcdGFkZENvbW1hbmQoJ2xpbmsnLCAnYSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCInLCAnYScsIG5hbWUsXHJcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMucmVuZGVyZXIuY29tbWFuZExpbmtDbGFzcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cGlja2VyID0gJChwaWNrZXIpO1xyXG5cdFx0XHRpZiAobW9udGhzVG9TaG93WzFdID4gMSkge1xyXG5cdFx0XHRcdHZhciBjb3VudCA9IDA7XHJcblx0XHRcdFx0JChpbnN0Lm9wdGlvbnMucmVuZGVyZXIubW9udGhTZWxlY3RvciwgcGlja2VyKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dmFyIG50aCA9ICsrY291bnQgJSBtb250aHNUb1Nob3dbMV07XHJcblx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKG50aCA9PT0gMSA/ICdmaXJzdCcgOiAobnRoID09PSAwID8gJ2xhc3QnIDogJycpKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBBZGQgZGF0ZXBpY2tlciBiZWhhdmlvdXJcclxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRmdW5jdGlvbiByZW1vdmVIaWdobGlnaHQoKSB7XHJcblx0XHRcdFx0KGluc3QuaW5saW5lID8gJCh0aGlzKS5jbG9zZXN0KCcuJyArIHNlbGYuX2dldE1hcmtlcigpKSA6IGluc3QuZGl2KS5cclxuXHRcdFx0XHRcdGZpbmQoaW5zdC5vcHRpb25zLnJlbmRlcmVyLmRheVNlbGVjdG9yICsgJyBhJykuXHJcblx0XHRcdFx0XHRyZW1vdmVDbGFzcyhpbnN0Lm9wdGlvbnMucmVuZGVyZXIuaGlnaGxpZ2h0ZWRDbGFzcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cGlja2VyLmZpbmQoaW5zdC5vcHRpb25zLnJlbmRlcmVyLmRheVNlbGVjdG9yICsgJyBhJykuaG92ZXIoXHJcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0cmVtb3ZlSGlnaGxpZ2h0LmFwcGx5KHRoaXMpO1xyXG5cdFx0XHRcdFx0XHQkKHRoaXMpLmFkZENsYXNzKGluc3Qub3B0aW9ucy5yZW5kZXJlci5oaWdobGlnaHRlZENsYXNzKTtcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRyZW1vdmVIaWdobGlnaHQpLlxyXG5cdFx0XHRcdGNsaWNrKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0c2VsZi5zZWxlY3REYXRlKGVsZW0sIHRoaXMpO1xyXG5cdFx0XHRcdH0pLmVuZCgpLlxyXG5cdFx0XHRcdGZpbmQoJ3NlbGVjdC4nICsgdGhpcy5fbW9udGhZZWFyQ2xhc3MgKyAnOm5vdCguJyArIHRoaXMuX2FueVllYXJDbGFzcyArICcpJykuXHJcblx0XHRcdFx0Y2hhbmdlKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dmFyIG1vbnRoWWVhciA9ICQodGhpcykudmFsKCkuc3BsaXQoJy8nKTtcclxuXHRcdFx0XHRcdHNlbGYuc2hvd01vbnRoKGVsZW0sIHBhcnNlSW50KG1vbnRoWWVhclsxXSwgMTApLCBwYXJzZUludChtb250aFllYXJbMF0sIDEwKSk7XHJcblx0XHRcdFx0fSkuZW5kKCkuXHJcblx0XHRcdFx0ZmluZCgnc2VsZWN0LicgKyB0aGlzLl9hbnlZZWFyQ2xhc3MpLmNsaWNrKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0JCh0aGlzKS5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuXHJcblx0XHRcdFx0XHRcdG5leHQoJ2lucHV0JykuY3NzKHtsZWZ0OiB0aGlzLm9mZnNldExlZnQsIHRvcDogdGhpcy5vZmZzZXRUb3AsXHJcblx0XHRcdFx0XHRcdHdpZHRoOiB0aGlzLm9mZnNldFdpZHRoLCBoZWlnaHQ6IHRoaXMub2Zmc2V0SGVpZ2h0fSkuc2hvdygpLmZvY3VzKCk7XHJcblx0XHRcdFx0fSkuZW5kKCkuXHJcblx0XHRcdFx0ZmluZCgnaW5wdXQuJyArIHNlbGYuX21vbnRoWWVhckNsYXNzKS5jaGFuZ2UoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHR2YXIgeWVhciA9IHBhcnNlSW50KCQodGhpcykudmFsKCksIDEwKTtcclxuXHRcdFx0XHRcdFx0eWVhciA9IChpc05hTih5ZWFyKSA/IGluc3QuZHJhd0RhdGUueWVhcigpIDogeWVhcik7XHJcblx0XHRcdFx0XHRcdHNlbGYuc2hvd01vbnRoKGVsZW0sIHllYXIsIGluc3QuZHJhd0RhdGUubW9udGgoKSwgaW5zdC5kcmF3RGF0ZS5kYXkoKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjYXRjaCAoZSkge1xyXG5cdFx0XHRcdFx0XHRhbGVydChlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KS5rZXlkb3duKGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdFx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHsgLy8gRW50ZXJcclxuXHRcdFx0XHRcdFx0JChldmVudC5lbGVtKS5jaGFuZ2UoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7IC8vIEVzY2FwZVxyXG5cdFx0XHRcdFx0XHQkKGV2ZW50LmVsZW0pLmhpZGUoKS5wcmV2KCdzZWxlY3QnKS5jc3MoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xyXG5cdFx0XHRcdFx0XHRpbnN0LmVsZW0uZm9jdXMoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0Ly8gQWRkIGtleWJvYXJkIGhhbmRsaW5nXHJcblx0XHRcdHZhciBkYXRhID0ge2VsZW06IGluc3QuZWxlbVswXX07XHJcblx0XHRcdHBpY2tlci5rZXlkb3duKGRhdGEsIHRoaXMuX2tleURvd24pLmtleXByZXNzKGRhdGEsIHRoaXMuX2tleVByZXNzKS5rZXl1cChkYXRhLCB0aGlzLl9rZXlVcCk7XHJcblx0XHRcdC8vIEFkZCBjb21tYW5kIGJlaGF2aW91clxyXG5cdFx0XHRwaWNrZXIuZmluZCgnLicgKyBpbnN0Lm9wdGlvbnMucmVuZGVyZXIuY29tbWFuZENsYXNzKS5jbGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICghJCh0aGlzKS5oYXNDbGFzcyhpbnN0Lm9wdGlvbnMucmVuZGVyZXIuZGlzYWJsZWRDbGFzcykpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGFjdGlvbiA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoXHJcblx0XHRcdFx0XHRcdFx0bmV3IFJlZ0V4cCgnXi4qJyArIGluc3Qub3B0aW9ucy5yZW5kZXJlci5jb21tYW5kQ2xhc3MgKyAnLShbXiBdKykuKiQnKSwgJyQxJyk7XHJcblx0XHRcdFx0XHRcdHBsdWdpbi5wZXJmb3JtQWN0aW9uKGVsZW0sIGFjdGlvbik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdC8vIEFkZCBjbGFzc2VzXHJcblx0XHRcdGlmIChpbnN0Lm9wdGlvbnMuaXNSVEwpIHtcclxuXHRcdFx0XHRwaWNrZXIuYWRkQ2xhc3MoaW5zdC5vcHRpb25zLnJlbmRlcmVyLnJ0bENsYXNzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAobW9udGhzVG9TaG93WzBdICogbW9udGhzVG9TaG93WzFdID4gMSkge1xyXG5cdFx0XHRcdHBpY2tlci5hZGRDbGFzcyhpbnN0Lm9wdGlvbnMucmVuZGVyZXIubXVsdGlDbGFzcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGluc3Qub3B0aW9ucy5waWNrZXJDbGFzcykge1xyXG5cdFx0XHRcdHBpY2tlci5hZGRDbGFzcyhpbnN0Lm9wdGlvbnMucGlja2VyQ2xhc3MpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIFJlc2l6ZVxyXG5cdFx0XHQkKCdib2R5JykuYXBwZW5kKHBpY2tlcik7XHJcblx0XHRcdHZhciB3aWR0aCA9IDA7XHJcblx0XHRcdHBpY2tlci5maW5kKGluc3Qub3B0aW9ucy5yZW5kZXJlci5tb250aFNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHdpZHRoICs9ICQodGhpcykub3V0ZXJXaWR0aCgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cGlja2VyLndpZHRoKHdpZHRoIC8gbW9udGhzVG9TaG93WzBdKTtcclxuXHRcdFx0Ly8gUHJlLXNob3cgY3VzdG9taXNhdGlvblxyXG5cdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5vblNob3cpKSB7XHJcblx0XHRcdFx0aW5zdC5vcHRpb25zLm9uU2hvdy5hcHBseShlbGVtLCBbcGlja2VyLCBpbnN0Lm9wdGlvbnMuY2FsZW5kYXIsIGluc3RdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcGlja2VyO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogR2VuZXJhdGUgdGhlIGNvbnRlbnQgZm9yIGEgc2luZ2xlIG1vbnRoLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBlbGVtIHtFbGVtZW50fSBUaGUgY29udHJvbCB0byBhZmZlY3QuXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcGFyYW0geWVhciB7bnVtYmVyfSBUaGUgeWVhciB0byBnZW5lcmF0ZS5cclxuXHRcdFx0QHBhcmFtIG1vbnRoIHtudW1iZXJ9IFRoZSBtb250aCB0byBnZW5lcmF0ZS5cclxuXHRcdFx0QHBhcmFtIGNhbGVuZGFyIHtCYXNlQ2FsZW5kYXJ9IFRoZSBjdXJyZW50IGNhbGVuZGFyLlxyXG5cdFx0XHRAcGFyYW0gcmVuZGVyZXIge29iamVjdH0gVGhlIHJlbmRlcmluZyB0ZW1wbGF0ZXMuXHJcblx0XHRcdEBwYXJhbSBmaXJzdCB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgZmlyc3Qgb2YgbXVsdGlwbGUgbW9udGhzLlxyXG5cdFx0XHRAcmV0dXJuIHtzdHJpbmd9IFRoZSBtb250aCBjb250ZW50LiAqL1xyXG5cdFx0X2dlbmVyYXRlTW9udGg6IGZ1bmN0aW9uKGVsZW0sIGluc3QsIHllYXIsIG1vbnRoLCBjYWxlbmRhciwgcmVuZGVyZXIsIGZpcnN0KSB7XHJcblx0XHRcdHZhciBkYXlzSW5Nb250aCA9IGNhbGVuZGFyLmRheXNJbk1vbnRoKHllYXIsIG1vbnRoKTtcclxuXHRcdFx0dmFyIG1vbnRoc1RvU2hvdyA9IGluc3Qub3B0aW9ucy5tb250aHNUb1Nob3c7XHJcblx0XHRcdG1vbnRoc1RvU2hvdyA9ICgkLmlzQXJyYXkobW9udGhzVG9TaG93KSA/IG1vbnRoc1RvU2hvdyA6IFsxLCBtb250aHNUb1Nob3ddKTtcclxuXHRcdFx0dmFyIGZpeGVkV2Vla3MgPSBpbnN0Lm9wdGlvbnMuZml4ZWRXZWVrcyB8fCAobW9udGhzVG9TaG93WzBdICogbW9udGhzVG9TaG93WzFdID4gMSk7XHJcblx0XHRcdHZhciBmaXJzdERheSA9IGluc3Qub3B0aW9ucy5maXJzdERheTtcclxuXHRcdFx0Zmlyc3REYXkgPSAoZmlyc3REYXkgPT0gbnVsbCA/IGNhbGVuZGFyLmxvY2FsLmZpcnN0RGF5IDogZmlyc3REYXkpO1xyXG5cdFx0XHR2YXIgbGVhZERheXMgPSAoY2FsZW5kYXIuZGF5T2ZXZWVrKHllYXIsIG1vbnRoLCBjYWxlbmRhci5taW5EYXkpIC1cclxuXHRcdFx0XHRmaXJzdERheSArIGNhbGVuZGFyLmRheXNJbldlZWsoKSkgJSBjYWxlbmRhci5kYXlzSW5XZWVrKCk7XHJcblx0XHRcdHZhciBudW1XZWVrcyA9IChmaXhlZFdlZWtzID8gNiA6IE1hdGguY2VpbCgobGVhZERheXMgKyBkYXlzSW5Nb250aCkgLyBjYWxlbmRhci5kYXlzSW5XZWVrKCkpKTtcclxuXHRcdFx0dmFyIHNlbGVjdE90aGVyTW9udGhzID0gaW5zdC5vcHRpb25zLnNlbGVjdE90aGVyTW9udGhzICYmIGluc3Qub3B0aW9ucy5zaG93T3RoZXJNb250aHM7XHJcblx0XHRcdHZhciBtaW5EYXRlID0gKGluc3QucGlja2luZ1JhbmdlID8gaW5zdC5zZWxlY3RlZERhdGVzWzBdIDogaW5zdC5nZXQoJ21pbkRhdGUnKSk7XHJcblx0XHRcdHZhciBtYXhEYXRlID0gaW5zdC5nZXQoJ21heERhdGUnKTtcclxuXHRcdFx0dmFyIHNob3dXZWVrcyA9IHJlbmRlcmVyLndlZWsuaW5kZXhPZigne3dlZWtPZlllYXJ9JykgPiAtMTtcclxuXHRcdFx0dmFyIHRvZGF5ID0gY2FsZW5kYXIudG9kYXkoKTtcclxuXHRcdFx0dmFyIGRyYXdEYXRlID0gY2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtb250aCwgY2FsZW5kYXIubWluRGF5KTtcclxuXHRcdFx0ZHJhd0RhdGUuYWRkKC1sZWFkRGF5cyAtIChmaXhlZFdlZWtzICYmXHJcblx0XHRcdFx0KGRyYXdEYXRlLmRheU9mV2VlaygpID09PSBmaXJzdERheSB8fCBkcmF3RGF0ZS5kYXlzSW5Nb250aCgpIDwgY2FsZW5kYXIuZGF5c0luV2VlaygpKT9cclxuXHRcdFx0XHRjYWxlbmRhci5kYXlzSW5XZWVrKCkgOiAwKSwgJ2QnKTtcclxuXHRcdFx0dmFyIGpkID0gZHJhd0RhdGUudG9KRCgpO1xyXG5cdFx0XHQvLyBHZW5lcmF0ZSB3ZWVrc1xyXG5cdFx0XHR2YXIgd2Vla3MgPSAnJztcclxuXHRcdFx0Zm9yICh2YXIgd2VlayA9IDA7IHdlZWsgPCBudW1XZWVrczsgd2VlaysrKSB7XHJcblx0XHRcdFx0dmFyIHdlZWtPZlllYXIgPSAoIXNob3dXZWVrcyA/ICcnIDogJzxzcGFuIGNsYXNzPVwiamQnICsgamQgKyAnXCI+JyArXHJcblx0XHRcdFx0XHQoJC5pc0Z1bmN0aW9uKGluc3Qub3B0aW9ucy5jYWxjdWxhdGVXZWVrKSA/XHJcblx0XHRcdFx0XHRpbnN0Lm9wdGlvbnMuY2FsY3VsYXRlV2VlayhkcmF3RGF0ZSkgOiBkcmF3RGF0ZS53ZWVrT2ZZZWFyKCkpICsgJzwvc3Bhbj4nKTtcclxuXHRcdFx0XHR2YXIgZGF5cyA9ICcnO1xyXG5cdFx0XHRcdGZvciAodmFyIGRheSA9IDA7IGRheSA8IGNhbGVuZGFyLmRheXNJbldlZWsoKTsgZGF5KyspIHtcclxuXHRcdFx0XHRcdHZhciBzZWxlY3RlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0aWYgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCAmJiBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0XHRzZWxlY3RlZCA9IChkcmF3RGF0ZS5jb21wYXJlVG8oaW5zdC5zZWxlY3RlZERhdGVzWzBdKSAhPT0gLTEgJiZcclxuXHRcdFx0XHRcdFx0XHRkcmF3RGF0ZS5jb21wYXJlVG8oaW5zdC5zZWxlY3RlZERhdGVzWzFdKSAhPT0gKzEpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0LnNlbGVjdGVkRGF0ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaW5zdC5zZWxlY3RlZERhdGVzW2ldLmNvbXBhcmVUbyhkcmF3RGF0ZSkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHNlbGVjdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIGRhdGVJbmZvID0gKCEkLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLm9uRGF0ZSkgPyB7fSA6XHJcblx0XHRcdFx0XHRcdGluc3Qub3B0aW9ucy5vbkRhdGUuYXBwbHkoZWxlbSwgW2RyYXdEYXRlLCBkcmF3RGF0ZS5tb250aCgpID09PSBtb250aF0pKTtcclxuXHRcdFx0XHRcdHZhciBzZWxlY3RhYmxlID0gKHNlbGVjdE90aGVyTW9udGhzIHx8IGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoKSAmJlxyXG5cdFx0XHRcdFx0XHR0aGlzLl9pc1NlbGVjdGFibGUoZWxlbSwgZHJhd0RhdGUsIGRhdGVJbmZvLnNlbGVjdGFibGUsIG1pbkRhdGUsIG1heERhdGUpO1xyXG5cdFx0XHRcdFx0ZGF5cyArPSB0aGlzLl9wcmVwYXJlKHJlbmRlcmVyLmRheSwgaW5zdCkucmVwbGFjZSgvXFx7ZGF5XFx9L2csXHJcblx0XHRcdFx0XHRcdChzZWxlY3RhYmxlID8gJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIicgOiAnPHNwYW4nKSArXHJcblx0XHRcdFx0XHRcdCcgY2xhc3M9XCJqZCcgKyBqZCArICcgJyArIChkYXRlSW5mby5kYXRlQ2xhc3MgfHwgJycpICtcclxuXHRcdFx0XHRcdFx0KHNlbGVjdGVkICYmIChzZWxlY3RPdGhlck1vbnRocyB8fCBkcmF3RGF0ZS5tb250aCgpID09PSBtb250aCkgP1xyXG5cdFx0XHRcdFx0XHQnICcgKyByZW5kZXJlci5zZWxlY3RlZENsYXNzIDogJycpICtcclxuXHRcdFx0XHRcdFx0KHNlbGVjdGFibGUgPyAnICcgKyByZW5kZXJlci5kZWZhdWx0Q2xhc3MgOiAnJykgK1xyXG5cdFx0XHRcdFx0XHQoZHJhd0RhdGUud2Vla0RheSgpID8gJycgOiAnICcgKyByZW5kZXJlci53ZWVrZW5kQ2xhc3MpICtcclxuXHRcdFx0XHRcdFx0KGRyYXdEYXRlLm1vbnRoKCkgPT09IG1vbnRoID8gJycgOiAnICcgKyByZW5kZXJlci5vdGhlck1vbnRoQ2xhc3MpICtcclxuXHRcdFx0XHRcdFx0KGRyYXdEYXRlLmNvbXBhcmVUbyh0b2RheSkgPT09IDAgJiYgZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGggP1xyXG5cdFx0XHRcdFx0XHQnICcgKyByZW5kZXJlci50b2RheUNsYXNzIDogJycpICtcclxuXHRcdFx0XHRcdFx0KGRyYXdEYXRlLmNvbXBhcmVUbyhpbnN0LmRyYXdEYXRlKSA9PT0gMCAmJiBkcmF3RGF0ZS5tb250aCgpID09PSBtb250aCA/XHJcblx0XHRcdFx0XHRcdCcgJyArIHJlbmRlcmVyLmhpZ2hsaWdodGVkQ2xhc3MgOiAnJykgKyAnXCInICtcclxuXHRcdFx0XHRcdFx0KGRhdGVJbmZvLnRpdGxlIHx8IChpbnN0Lm9wdGlvbnMuZGF5U3RhdHVzICYmIHNlbGVjdGFibGUpID8gJyB0aXRsZT1cIicgK1xyXG5cdFx0XHRcdFx0XHQoZGF0ZUluZm8udGl0bGUgfHwgZHJhd0RhdGUuZm9ybWF0RGF0ZShpbnN0Lm9wdGlvbnMuZGF5U3RhdHVzKSkgKyAnXCInIDogJycpICsgJz4nICtcclxuXHRcdFx0XHRcdFx0KGluc3Qub3B0aW9ucy5zaG93T3RoZXJNb250aHMgfHwgZHJhd0RhdGUubW9udGgoKSA9PT0gbW9udGggP1xyXG5cdFx0XHRcdFx0XHRkYXRlSW5mby5jb250ZW50IHx8IGRyYXdEYXRlLmRheSgpIDogJyYjMTYwOycpICtcclxuXHRcdFx0XHRcdFx0KHNlbGVjdGFibGUgPyAnPC9hPicgOiAnPC9zcGFuPicpKTtcclxuXHRcdFx0XHRcdGRyYXdEYXRlLmFkZCgxLCAnZCcpO1xyXG5cdFx0XHRcdFx0amQrKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0d2Vla3MgKz0gdGhpcy5fcHJlcGFyZShyZW5kZXJlci53ZWVrLCBpbnN0KS5yZXBsYWNlKC9cXHtkYXlzXFx9L2csIGRheXMpLlxyXG5cdFx0XHRcdFx0cmVwbGFjZSgvXFx7d2Vla09mWWVhclxcfS9nLCB3ZWVrT2ZZZWFyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgbW9udGhIZWFkZXIgPSB0aGlzLl9wcmVwYXJlKHJlbmRlcmVyLm1vbnRoLCBpbnN0KS5tYXRjaCgvXFx7bW9udGhIZWFkZXIoOlteXFx9XSspP1xcfS8pO1xyXG5cdFx0XHRtb250aEhlYWRlciA9IChtb250aEhlYWRlclswXS5sZW5ndGggPD0gMTMgPyAnTU0geXl5eScgOlxyXG5cdFx0XHRcdG1vbnRoSGVhZGVyWzBdLnN1YnN0cmluZygxMywgbW9udGhIZWFkZXJbMF0ubGVuZ3RoIC0gMSkpO1xyXG5cdFx0XHRtb250aEhlYWRlciA9IChmaXJzdCA/IHRoaXMuX2dlbmVyYXRlTW9udGhTZWxlY3Rpb24oXHJcblx0XHRcdFx0aW5zdCwgeWVhciwgbW9udGgsIG1pbkRhdGUsIG1heERhdGUsIG1vbnRoSGVhZGVyLCBjYWxlbmRhciwgcmVuZGVyZXIpIDpcclxuXHRcdFx0XHRjYWxlbmRhci5mb3JtYXREYXRlKG1vbnRoSGVhZGVyLCBjYWxlbmRhci5uZXdEYXRlKHllYXIsIG1vbnRoLCBjYWxlbmRhci5taW5EYXkpKSk7XHJcblx0XHRcdHZhciB3ZWVrSGVhZGVyID0gdGhpcy5fcHJlcGFyZShyZW5kZXJlci53ZWVrSGVhZGVyLCBpbnN0KS5cclxuXHRcdFx0XHRyZXBsYWNlKC9cXHtkYXlzXFx9L2csIHRoaXMuX2dlbmVyYXRlRGF5SGVhZGVycyhpbnN0LCBjYWxlbmRhciwgcmVuZGVyZXIpKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX3ByZXBhcmUocmVuZGVyZXIubW9udGgsIGluc3QpLnJlcGxhY2UoL1xce21vbnRoSGVhZGVyKDpbXlxcfV0rKT9cXH0vZywgbW9udGhIZWFkZXIpLlxyXG5cdFx0XHRcdHJlcGxhY2UoL1xce3dlZWtIZWFkZXJcXH0vZywgd2Vla0hlYWRlcikucmVwbGFjZSgvXFx7d2Vla3NcXH0vZywgd2Vla3MpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogR2VuZXJhdGUgdGhlIEhUTUwgZm9yIHRoZSBkYXkgaGVhZGVycy5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcHJpdmF0ZVxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHBhcmFtIGNhbGVuZGFyIHtCYXNlQ2FsZW5kYXJ9IFRoZSBjdXJyZW50IGNhbGVuZGFyLlxyXG5cdFx0XHRAcGFyYW0gcmVuZGVyZXIge29iamVjdH0gVGhlIHJlbmRlcmluZyB0ZW1wbGF0ZXMuXHJcblx0XHRcdEByZXR1cm4ge3N0cmluZ30gQSB3ZWVrJ3Mgd29ydGggb2YgZGF5IGhlYWRlcnMuICovXHJcblx0XHRfZ2VuZXJhdGVEYXlIZWFkZXJzOiBmdW5jdGlvbihpbnN0LCBjYWxlbmRhciwgcmVuZGVyZXIpIHtcclxuXHRcdFx0dmFyIGZpcnN0RGF5ID0gaW5zdC5vcHRpb25zLmZpcnN0RGF5O1xyXG5cdFx0XHRmaXJzdERheSA9IChmaXJzdERheSA9PSBudWxsID8gY2FsZW5kYXIubG9jYWwuZmlyc3REYXkgOiBmaXJzdERheSk7XHJcblx0XHRcdHZhciBoZWFkZXIgPSAnJztcclxuXHRcdFx0Zm9yICh2YXIgZGF5ID0gMDsgZGF5IDwgY2FsZW5kYXIuZGF5c0luV2VlaygpOyBkYXkrKykge1xyXG5cdFx0XHRcdHZhciBkb3cgPSAoZGF5ICsgZmlyc3REYXkpICUgY2FsZW5kYXIuZGF5c0luV2VlaygpO1xyXG5cdFx0XHRcdGhlYWRlciArPSB0aGlzLl9wcmVwYXJlKHJlbmRlcmVyLmRheUhlYWRlciwgaW5zdCkucmVwbGFjZSgvXFx7ZGF5XFx9L2csXHJcblx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCInICsgdGhpcy5fY3VyRG9XQ2xhc3MgKyBkb3cgKyAnXCIgdGl0bGU9XCInICtcclxuXHRcdFx0XHRcdGNhbGVuZGFyLmxvY2FsLmRheU5hbWVzW2Rvd10gKyAnXCI+JyArIGNhbGVuZGFyLmxvY2FsLmRheU5hbWVzTWluW2Rvd10gKyAnPC9zcGFuPicpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBoZWFkZXI7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBHZW5lcmF0ZSBzZWxlY3Rpb24gY29udHJvbHMgZm9yIG1vbnRoLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAcGFyYW0geWVhciB7bnVtYmVyfSBUaGUgeWVhciB0byBnZW5lcmF0ZS5cclxuXHRcdFx0QHBhcmFtIG1vbnRoIHtudW1iZXJ9IFRoZSBtb250aCB0byBnZW5lcmF0ZS5cclxuXHRcdFx0QHBhcmFtIG1pbkRhdGUge0NEYXRlfSBUaGUgbWluaW11bSBkYXRlIGFsbG93ZWQuXHJcblx0XHRcdEBwYXJhbSBtYXhEYXRlIHtDRGF0ZX0gVGhlIG1heGltdW0gZGF0ZSBhbGxvd2VkLlxyXG5cdFx0XHRAcGFyYW0gbW9udGhIZWFkZXIge3N0cmluZ30gVGhlIG1vbnRoL3llYXIgZm9ybWF0LlxyXG5cdFx0XHRAcGFyYW0gY2FsZW5kYXIge0Jhc2VDYWxlbmRhcn0gVGhlIGN1cnJlbnQgY2FsZW5kYXIuXHJcblx0XHRcdEByZXR1cm4ge3N0cmluZ30gVGhlIG1vbnRoIHNlbGVjdGlvbiBjb250ZW50LiAqL1xyXG5cdFx0X2dlbmVyYXRlTW9udGhTZWxlY3Rpb246IGZ1bmN0aW9uKGluc3QsIHllYXIsIG1vbnRoLCBtaW5EYXRlLCBtYXhEYXRlLCBtb250aEhlYWRlciwgY2FsZW5kYXIpIHtcclxuXHRcdFx0aWYgKCFpbnN0Lm9wdGlvbnMuY2hhbmdlTW9udGgpIHtcclxuXHRcdFx0XHRyZXR1cm4gY2FsZW5kYXIuZm9ybWF0RGF0ZShtb250aEhlYWRlciwgY2FsZW5kYXIubmV3RGF0ZSh5ZWFyLCBtb250aCwgMSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIE1vbnRoc1xyXG5cdFx0XHR2YXIgbW9udGhOYW1lcyA9IGNhbGVuZGFyLmxvY2FsW1xyXG5cdFx0XHRcdCdtb250aE5hbWVzJyArIChtb250aEhlYWRlci5tYXRjaCgvbW0vaSkgPyAnJyA6ICdTaG9ydCcpXTtcclxuXHRcdFx0dmFyIGh0bWwgPSBtb250aEhlYWRlci5yZXBsYWNlKC9tKy9pLCAnXFxcXHgyRScpLnJlcGxhY2UoL3krL2ksICdcXFxceDJGJyk7XHJcblx0XHRcdHZhciBzZWxlY3RvciA9ICc8c2VsZWN0IGNsYXNzPVwiJyArIHRoaXMuX21vbnRoWWVhckNsYXNzICtcclxuXHRcdFx0XHQnXCIgdGl0bGU9XCInICsgaW5zdC5vcHRpb25zLm1vbnRoU3RhdHVzICsgJ1wiPic7XHJcblx0XHRcdHZhciBtYXhNb250aCA9IGNhbGVuZGFyLm1vbnRoc0luWWVhcih5ZWFyKSArIGNhbGVuZGFyLm1pbk1vbnRoO1xyXG5cdFx0XHRmb3IgKHZhciBtID0gY2FsZW5kYXIubWluTW9udGg7IG0gPCBtYXhNb250aDsgbSsrKSB7XHJcblx0XHRcdFx0aWYgKCghbWluRGF0ZSB8fCBjYWxlbmRhci5uZXdEYXRlKHllYXIsIG0sXHJcblx0XHRcdFx0XHRcdGNhbGVuZGFyLmRheXNJbk1vbnRoKHllYXIsIG0pIC0gMSArIGNhbGVuZGFyLm1pbkRheSkuXHJcblx0XHRcdFx0XHRcdGNvbXBhcmVUbyhtaW5EYXRlKSAhPT0gLTEpICYmXHJcblx0XHRcdFx0XHRcdCghbWF4RGF0ZSB8fCBjYWxlbmRhci5uZXdEYXRlKHllYXIsIG0sIGNhbGVuZGFyLm1pbkRheSkuXHJcblx0XHRcdFx0XHRcdGNvbXBhcmVUbyhtYXhEYXRlKSAhPT0gKzEpKSB7XHJcblx0XHRcdFx0XHRzZWxlY3RvciArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBtICsgJy8nICsgeWVhciArICdcIicgK1xyXG5cdFx0XHRcdFx0XHQobW9udGggPT09IG0gPyAnIHNlbGVjdGVkPVwic2VsZWN0ZWRcIicgOiAnJykgKyAnPicgK1xyXG5cdFx0XHRcdFx0XHRtb250aE5hbWVzW20gLSBjYWxlbmRhci5taW5Nb250aF0gKyAnPC9vcHRpb24+JztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0c2VsZWN0b3IgKz0gJzwvc2VsZWN0Pic7XHJcblx0XHRcdGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcXFx4MkUvLCBzZWxlY3Rvcik7XHJcblx0XHRcdC8vIFllYXJzXHJcblx0XHRcdHZhciB5ZWFyUmFuZ2UgPSBpbnN0Lm9wdGlvbnMueWVhclJhbmdlO1xyXG5cdFx0XHRpZiAoeWVhclJhbmdlID09PSAnYW55Jykge1xyXG5cdFx0XHRcdHNlbGVjdG9yID0gJzxzZWxlY3QgY2xhc3M9XCInICsgdGhpcy5fbW9udGhZZWFyQ2xhc3MgKyAnICcgKyB0aGlzLl9hbnlZZWFyQ2xhc3MgK1xyXG5cdFx0XHRcdFx0J1wiIHRpdGxlPVwiJyArIGluc3Qub3B0aW9ucy55ZWFyU3RhdHVzICsgJ1wiPicgK1xyXG5cdFx0XHRcdFx0JzxvcHRpb24+JyArIHllYXIgKyAnPC9vcHRpb24+PC9zZWxlY3Q+JyArXHJcblx0XHRcdFx0XHQnPGlucHV0IGNsYXNzPVwiJyArIHRoaXMuX21vbnRoWWVhckNsYXNzICsgJyAnICsgdGhpcy5fY3VyTW9udGhDbGFzcyArXHJcblx0XHRcdFx0XHRtb250aCArICdcIiB2YWx1ZT1cIicgKyB5ZWFyICsgJ1wiPic7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0eWVhclJhbmdlID0geWVhclJhbmdlLnNwbGl0KCc6Jyk7XHJcblx0XHRcdFx0dmFyIHRvZGF5WWVhciA9IGNhbGVuZGFyLnRvZGF5KCkueWVhcigpO1xyXG5cdFx0XHRcdHZhciBzdGFydCA9ICh5ZWFyUmFuZ2VbMF0ubWF0Y2goJ2NbKy1dLionKSA/IHllYXIgKyBwYXJzZUludCh5ZWFyUmFuZ2VbMF0uc3Vic3RyaW5nKDEpLCAxMCkgOlxyXG5cdFx0XHRcdFx0KCh5ZWFyUmFuZ2VbMF0ubWF0Y2goJ1srLV0uKicpID8gdG9kYXlZZWFyIDogMCkgKyBwYXJzZUludCh5ZWFyUmFuZ2VbMF0sIDEwKSkpO1xyXG5cdFx0XHRcdHZhciBlbmQgPSAoeWVhclJhbmdlWzFdLm1hdGNoKCdjWystXS4qJykgPyB5ZWFyICsgcGFyc2VJbnQoeWVhclJhbmdlWzFdLnN1YnN0cmluZygxKSwgMTApIDpcclxuXHRcdFx0XHRcdCgoeWVhclJhbmdlWzFdLm1hdGNoKCdbKy1dLionKSA/IHRvZGF5WWVhciA6IDApICsgcGFyc2VJbnQoeWVhclJhbmdlWzFdLCAxMCkpKTtcclxuXHRcdFx0XHRzZWxlY3RvciA9ICc8c2VsZWN0IGNsYXNzPVwiJyArIHRoaXMuX21vbnRoWWVhckNsYXNzICtcclxuXHRcdFx0XHRcdCdcIiB0aXRsZT1cIicgKyBpbnN0Lm9wdGlvbnMueWVhclN0YXR1cyArICdcIj4nO1xyXG5cdFx0XHRcdHN0YXJ0ID0gY2FsZW5kYXIubmV3RGF0ZShzdGFydCArIDEsIGNhbGVuZGFyLmZpcnN0TW9udGgsIGNhbGVuZGFyLm1pbkRheSkuYWRkKC0xLCAnZCcpO1xyXG5cdFx0XHRcdGVuZCA9IGNhbGVuZGFyLm5ld0RhdGUoZW5kLCBjYWxlbmRhci5maXJzdE1vbnRoLCBjYWxlbmRhci5taW5EYXkpO1xyXG5cdFx0XHRcdHZhciBhZGRZZWFyID0gZnVuY3Rpb24oeSwgeURpc3BsYXkpIHtcclxuXHRcdFx0XHRcdGlmICh5ICE9PSAwIHx8IGNhbGVuZGFyLmhhc1llYXJaZXJvKSB7XHJcblx0XHRcdFx0XHRcdHNlbGVjdG9yICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArXHJcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4obW9udGgsIGNhbGVuZGFyLm1vbnRoc0luWWVhcih5KSAtIDEgKyBjYWxlbmRhci5taW5Nb250aCkgK1xyXG5cdFx0XHRcdFx0XHRcdCcvJyArIHkgKyAnXCInICsgKHllYXIgPT09IHkgPyAnIHNlbGVjdGVkPVwic2VsZWN0ZWRcIicgOiAnJykgKyAnPicgK1xyXG5cdFx0XHRcdFx0XHRcdCh5RGlzcGxheSB8fCB5KSArICc8L29wdGlvbj4nO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0aWYgKHN0YXJ0LnRvSkQoKSA8IGVuZC50b0pEKCkpIHtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gKG1pbkRhdGUgJiYgbWluRGF0ZS5jb21wYXJlVG8oc3RhcnQpID09PSArMSA/IG1pbkRhdGUgOiBzdGFydCkueWVhcigpO1xyXG5cdFx0XHRcdFx0ZW5kID0gKG1heERhdGUgJiYgbWF4RGF0ZS5jb21wYXJlVG8oZW5kKSA9PT0gLTEgPyBtYXhEYXRlIDogZW5kKS55ZWFyKCk7XHJcblx0XHRcdFx0XHR2YXIgZWFybGllckxhdGVyID0gTWF0aC5mbG9vcigoZW5kIC0gc3RhcnQpIC8gMik7XHJcblx0XHRcdFx0XHRpZiAoIW1pbkRhdGUgfHwgbWluRGF0ZS55ZWFyKCkgPCBzdGFydCkge1xyXG5cdFx0XHRcdFx0XHRhZGRZZWFyKHN0YXJ0IC0gZWFybGllckxhdGVyLCBpbnN0Lm9wdGlvbnMuZWFybGllclRleHQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Zm9yICh2YXIgeSA9IHN0YXJ0OyB5IDw9IGVuZDsgeSsrKSB7XHJcblx0XHRcdFx0XHRcdGFkZFllYXIoeSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoIW1heERhdGUgfHwgbWF4RGF0ZS55ZWFyKCkgPiBlbmQpIHtcclxuXHRcdFx0XHRcdFx0YWRkWWVhcihlbmQgKyBlYXJsaWVyTGF0ZXIsIGluc3Qub3B0aW9ucy5sYXRlclRleHQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gKG1heERhdGUgJiYgbWF4RGF0ZS5jb21wYXJlVG8oc3RhcnQpID09PSAtMSA/IG1heERhdGUgOiBzdGFydCkueWVhcigpO1xyXG5cdFx0XHRcdFx0ZW5kID0gKG1pbkRhdGUgJiYgbWluRGF0ZS5jb21wYXJlVG8oZW5kKSA9PT0gKzEgPyBtaW5EYXRlIDogZW5kKS55ZWFyKCk7XHJcblx0XHRcdFx0XHR2YXIgZWFybGllckxhdGVyID0gTWF0aC5mbG9vcigoc3RhcnQgLSBlbmQpIC8gMik7XHJcblx0XHRcdFx0XHRpZiAoIW1heERhdGUgfHwgbWF4RGF0ZS55ZWFyKCkgPiBzdGFydCkge1xyXG5cdFx0XHRcdFx0XHRhZGRZZWFyKHN0YXJ0ICsgZWFybGllckxhdGVyLCBpbnN0Lm9wdGlvbnMuZWFybGllclRleHQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Zm9yICh2YXIgeSA9IHN0YXJ0OyB5ID49IGVuZDsgeS0tKSB7XHJcblx0XHRcdFx0XHRcdGFkZFllYXIoeSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoIW1pbkRhdGUgfHwgbWluRGF0ZS55ZWFyKCkgPCBlbmQpIHtcclxuXHRcdFx0XHRcdFx0YWRkWWVhcihlbmQgLSBlYXJsaWVyTGF0ZXIsIGluc3Qub3B0aW9ucy5sYXRlclRleHQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzZWxlY3RvciArPSAnPC9zZWxlY3Q+JztcclxuXHRcdFx0fVxyXG5cdFx0XHRodG1sID0gaHRtbC5yZXBsYWNlKC9cXFxceDJGLywgc2VsZWN0b3IpO1xyXG5cdFx0XHRyZXR1cm4gaHRtbDtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFByZXBhcmUgYSByZW5kZXIgdGVtcGxhdGUgZm9yIHVzZS5cclxuXHRcdFx0RXhjbHVkZSBwb3B1cC9pbmxpbmUgc2VjdGlvbnMgdGhhdCBhcmUgbm90IGFwcGxpY2FibGUuXHJcblx0XHRcdExvY2FsaXNlIHRleHQgb2YgdGhlIGZvcm06IHtsMTBuOm5hbWV9LlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwcml2YXRlXHJcblx0XHRcdEBwYXJhbSB0ZXh0IHtzdHJpbmd9IFRoZSB0ZXh0IHRvIGxvY2FsaXNlLlxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QHJldHVybiB7c3RyaW5nfSBUaGUgbG9jYWxpc2VkIHRleHQuICovXHJcblx0XHRfcHJlcGFyZTogZnVuY3Rpb24odGV4dCwgaW5zdCkge1xyXG5cdFx0XHR2YXIgcmVwbGFjZVNlY3Rpb24gPSBmdW5jdGlvbih0eXBlLCByZXRhaW4pIHtcclxuXHRcdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gdGV4dC5pbmRleE9mKCd7JyArIHR5cGUgKyAnOnN0YXJ0fScpO1xyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgZW5kID0gdGV4dC5zdWJzdHJpbmcoc3RhcnQpLmluZGV4T2YoJ3snICsgdHlwZSArICc6ZW5kfScpO1xyXG5cdFx0XHRcdFx0aWYgKGVuZCA+IC0xKSB7XHJcblx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydCkgK1xyXG5cdFx0XHRcdFx0XHRcdChyZXRhaW4gPyB0ZXh0LnN1YnN0cihzdGFydCArIHR5cGUubGVuZ3RoICsgOCwgZW5kIC0gdHlwZS5sZW5ndGggLSA4KSA6ICcnKSArXHJcblx0XHRcdFx0XHRcdFx0dGV4dC5zdWJzdHJpbmcoc3RhcnQgKyBlbmQgKyB0eXBlLmxlbmd0aCArIDYpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdFx0cmVwbGFjZVNlY3Rpb24oJ2lubGluZScsIGluc3QuaW5saW5lKTtcclxuXHRcdFx0cmVwbGFjZVNlY3Rpb24oJ3BvcHVwJywgIWluc3QuaW5saW5lKTtcclxuXHRcdFx0dmFyIHBhdHRlcm4gPSAvXFx7bDEwbjooW15cXH1dKylcXH0vO1xyXG5cdFx0XHR2YXIgbWF0Y2hlcyA9IG51bGw7XHJcblx0XHRcdHdoaWxlIChtYXRjaGVzID0gcGF0dGVybi5leGVjKHRleHQpKSB7XHJcblx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZShtYXRjaGVzWzBdLCBpbnN0Lm9wdGlvbnNbbWF0Y2hlc1sxXV0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0ZXh0O1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHR2YXIgcGx1Z2luID0gJC5jYWxlbmRhcnNQaWNrZXI7IC8vIFNpbmdsZXRvbiBpbnN0YW5jZVxyXG5cclxuXHQkKGZ1bmN0aW9uKCkge1xyXG5cdFx0JChkb2N1bWVudCkub24oJ21vdXNlZG93bi4nICsgcGx1Z2luTmFtZSwgcGx1Z2luLl9jaGVja0V4dGVybmFsQ2xpY2spLlxyXG5cdFx0XHRvbigncmVzaXplLicgKyBwbHVnaW5OYW1lLCBmdW5jdGlvbigpIHsgcGx1Z2luLmhpZGUocGx1Z2luLmN1ckluc3QpOyB9KTtcclxuXHR9KTtcclxuXHJcbn0pKGpRdWVyeSk7XHJcbiIsIi8qIGh0dHA6Ly9rZWl0aC13b29kLm5hbWUvY2FsZW5kYXJzLmh0bWxcclxuICAgQ2FsZW5kYXJzIGRhdGUgcGlja2VyIGV4dGVuc2lvbnMgZm9yIGpRdWVyeSB2Mi4wLjEuXHJcbiAgIFdyaXR0ZW4gYnkgS2VpdGggV29vZCAoa2J3b29ke2F0fWlpbmV0LmNvbS5hdSkgQXVndXN0IDIwMDkuXHJcbiAgIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIChodHRwOi8va2VpdGgtd29vZC5uYW1lL2xpY2VuY2UuaHRtbCkgbGljZW5zZS4gXHJcbiAgIFBsZWFzZSBhdHRyaWJ1dGUgdGhlIGF1dGhvciBpZiB5b3UgdXNlIGl0LiAqL1xyXG5cclxuKGZ1bmN0aW9uKCQpIHsgLy8gSGlkZSBzY29wZSwgbm8gJCBjb25mbGljdFxyXG5cclxuXHR2YXIgdGhlbWVSb2xsZXJSZW5kZXJlciA9IHtcclxuXHRcdHBpY2tlcjogJzxkaXZ7cG9wdXA6c3RhcnR9IGlkPVwidWktZGF0ZXBpY2tlci1kaXZcIntwb3B1cDplbmR9IGNsYXNzPVwidWktZGF0ZXBpY2tlciB1aS13aWRnZXQgJyArXHJcblx0XHQndWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci1hbGx7aW5saW5lOnN0YXJ0fSB1aS1kYXRlcGlja2VyLWlubGluZXtpbmxpbmU6ZW5kfVwiPicgK1xyXG5cdFx0JzxkaXYgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLWhlYWRlciB1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsXCI+JyArXHJcblx0XHQne2xpbms6cHJldn17bGluazp0b2RheX17bGluazpuZXh0fTwvZGl2Pnttb250aHN9JyArXHJcblx0XHQne3BvcHVwOnN0YXJ0fTxkaXYgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLWhlYWRlciB1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeCAnICtcclxuXHRcdCd1aS1jb3JuZXItYWxsXCI+e2J1dHRvbjpjbGVhcn17YnV0dG9uOmNsb3NlfTwvZGl2Pntwb3B1cDplbmR9JyArXHJcblx0XHQnPGRpdiBjbGFzcz1cInVpLWhlbHBlci1jbGVhcmZpeFwiPjwvZGl2PjwvZGl2PicsXHJcblx0XHRtb250aFJvdzogJzxkaXYgY2xhc3M9XCJ1aS1kYXRlcGlja2VyLXJvdy1icmVha1wiPnttb250aHN9PC9kaXY+JyxcclxuXHRcdG1vbnRoOiAnPGRpdiBjbGFzcz1cInVpLWRhdGVwaWNrZXItZ3JvdXBcIj4nICtcclxuXHRcdCc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci1oZWFkZXIgdWktd2lkZ2V0LWhlYWRlciB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbFwiPnttb250aEhlYWRlcjpNTSB5eXl5fTwvZGl2PicgK1xyXG5cdFx0Jzx0YWJsZSBjbGFzcz1cInVpLWRhdGVwaWNrZXItY2FsZW5kYXJcIj48dGhlYWQ+e3dlZWtIZWFkZXJ9PC90aGVhZD48dGJvZHk+e3dlZWtzfTwvdGJvZHk+PC90YWJsZT48L2Rpdj4nLFxyXG5cdFx0d2Vla0hlYWRlcjogJzx0cj57ZGF5c308L3RyPicsXHJcblx0XHRkYXlIZWFkZXI6ICc8dGg+e2RheX08L3RoPicsXHJcblx0XHR3ZWVrOiAnPHRyPntkYXlzfTwvdHI+JyxcclxuXHRcdGRheTogJzx0ZD57ZGF5fTwvdGQ+JyxcclxuXHRcdG1vbnRoU2VsZWN0b3I6ICcudWktZGF0ZXBpY2tlci1ncm91cCcsXHJcblx0XHRkYXlTZWxlY3RvcjogJ3RkJyxcclxuXHRcdHJ0bENsYXNzOiAndWktZGF0ZXBpY2tlci1ydGwnLFxyXG5cdFx0bXVsdGlDbGFzczogJ3VpLWRhdGVwaWNrZXItbXVsdGknLFxyXG5cdFx0ZGVmYXVsdENsYXNzOiAndWktc3RhdGUtZGVmYXVsdCcsXHJcblx0XHRzZWxlY3RlZENsYXNzOiAndWktc3RhdGUtYWN0aXZlJyxcclxuXHRcdGhpZ2hsaWdodGVkQ2xhc3M6ICd1aS1zdGF0ZS1ob3ZlcicsXHJcblx0XHR0b2RheUNsYXNzOiAndWktc3RhdGUtaGlnaGxpZ2h0JyxcclxuXHRcdG90aGVyTW9udGhDbGFzczogJ3VpLWRhdGVwaWNrZXItb3RoZXItbW9udGgnLFxyXG5cdFx0d2Vla2VuZENsYXNzOiAndWktZGF0ZXBpY2tlci13ZWVrLWVuZCcsXHJcblx0XHRjb21tYW5kQ2xhc3M6ICd1aS1kYXRlcGlja2VyLWNtZCcsXHJcblx0XHRjb21tYW5kQnV0dG9uQ2xhc3M6ICd1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGwnLFxyXG5cdFx0Y29tbWFuZExpbmtDbGFzczogJycsXHJcblx0XHRkaXNhYmxlZENsYXNzOiAndWktZGF0ZXBpY2tlci1kaXNhYmxlZCdcclxuXHR9O1xyXG5cclxuXHQkLmV4dGVuZCgkLmNhbGVuZGFyc1BpY2tlciwge1xyXG5cclxuXHRcdC8qKiBUZW1wbGF0ZSBmb3IgZ2VuZXJhdGluZyBhIGNhbGVuZGFyIHBpY2tlciBzaG93aW5nIHdlZWsgb2YgeWVhci5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGlja2VyLmV4dC5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyICovXHJcblx0XHR3ZWVrT2ZZZWFyUmVuZGVyZXI6ICQuZXh0ZW5kKHt9LCAkLmNhbGVuZGFyc1BpY2tlci5kZWZhdWx0UmVuZGVyZXIsIHtcclxuXHRcdFx0d2Vla0hlYWRlcjogJzx0cj48dGggY2xhc3M9XCJjYWxlbmRhcnMtd2Vla1wiPicgK1xyXG5cdFx0XHQnPHNwYW4gdGl0bGU9XCJ7bDEwbjp3ZWVrU3RhdHVzfVwiPntsMTBuOndlZWtUZXh0fTwvc3Bhbj48L3RoPntkYXlzfTwvdHI+JyxcclxuXHRcdFx0d2VlazogJzx0cj48dGQgY2xhc3M9XCJjYWxlbmRhcnMtd2Vla1wiPnt3ZWVrT2ZZZWFyfTwvdGQ+e2RheXN9PC90cj4nXHJcblx0XHR9KSxcclxuXHJcblx0XHQvKiogVGhlbWVSb2xsZXIgdGVtcGxhdGUgZm9yIGdlbmVyYXRpbmcgYSBjYWxlbmRhciBwaWNrZXIuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBpY2tlci5leHQuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlciAqL1xyXG5cdFx0dGhlbWVSb2xsZXJSZW5kZXJlcjogdGhlbWVSb2xsZXJSZW5kZXJlcixcclxuXHJcblx0XHQvKiogVGhlbWVSb2xsZXIgdGVtcGxhdGUgZm9yIGdlbmVyYXRpbmcgYSBjYWxlbmRhciBwaWNrZXIgc2hvd2luZyB3ZWVrIG9mIHllYXIuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBpY2tlci5leHQuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlciAqL1xyXG5cdFx0dGhlbWVSb2xsZXJXZWVrT2ZZZWFyUmVuZGVyZXI6ICQuZXh0ZW5kKHt9LCB0aGVtZVJvbGxlclJlbmRlcmVyLCB7XHJcblx0XHRcdHdlZWtIZWFkZXI6ICc8dHI+PHRoIGNsYXNzPVwidWktc3RhdGUtaG92ZXJcIj48c3Bhbj57bDEwbjp3ZWVrVGV4dH08L3NwYW4+PC90aD57ZGF5c308L3RyPicsXHJcblx0XHRcdHdlZWs6ICc8dHI+PHRkIGNsYXNzPVwidWktc3RhdGUtaG92ZXJcIj57d2Vla09mWWVhcn08L3RkPntkYXlzfTwvdHI+J1xyXG5cdFx0fSksXHJcblxyXG5cdFx0LyoqIERvbid0IGFsbG93IHdlZWtlbmRzIHRvIGJlIHNlbGVjdGVkLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5waWNrZXIuZXh0LmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIGRhdGUge0NEYXRlfSBUaGUgY3VycmVudCBkYXRlLlxyXG5cdFx0XHRAcmV0dXJuIHtvYmplY3R9IEluZm9ybWF0aW9uIGFib3V0IHRoaXMgZGF0ZS5cclxuXHRcdFx0QGV4YW1wbGUgb25EYXRlOiAkLmNhbGVuZGFyc1BpY2tlci5ub1dlZWtlbmRzICovXHJcblx0XHRub1dlZWtlbmRzOiBmdW5jdGlvbihkYXRlKSB7XHJcblx0XHRcdHJldHVybiB7c2VsZWN0YWJsZTogZGF0ZS53ZWVrRGF5KCl9O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQ2hhbmdlIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgYnkgY2xpY2tpbmcgb24gdGhlIGRheSBoZWFkZXIuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBpY2tlci5leHQuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gcGlja2VyIHtqUXVlcnl9IFRoZSBjb21wbGV0ZWQgZGF0ZXBpY2tlciBkaXZpc2lvbi5cclxuXHRcdFx0QHBhcmFtIGNhbGVuZGFyIHtCYXNlQ2FsZW5kYXJ9IFRoZSBjYWxlbmRhciBpbXBsZW1lbnRhdGlvbi5cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBleGFtcGxlIG9uU2hvdzogJC5jYWxlbmRhcnNQaWNrZXIuY2hhbmdlRmlyc3REYXkgKi9cclxuXHRcdGNoYW5nZUZpcnN0RGF5OiBmdW5jdGlvbihwaWNrZXIsIGNhbGVuZGFyLCBpbnN0KSB7XHJcblx0XHRcdHZhciB0YXJnZXQgPSAkKHRoaXMpO1xyXG5cdFx0XHRwaWNrZXIuZmluZCgndGggc3BhbicpLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMucGFyZW50Tm9kZS5jbGFzc05hbWUubWF0Y2goLy4qY2FsZW5kYXJzLXdlZWsuKi8pKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdCQoJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBjbGFzcz1cIicgKyB0aGlzLmNsYXNzTmFtZSArXHJcblx0XHRcdFx0XHRcdCdcIiB0aXRsZT1cIkNoYW5nZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWtcIj4nICsgJCh0aGlzKS50ZXh0KCkgKyAnPC9hPicpLlxyXG5cdFx0XHRcdFx0Y2xpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHZhciBkb3cgPSBwYXJzZUludCh0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKC9eLipjYWxlbmRhcnMtZG93LShcXGQrKS4qJC8sICckMScpLCAxMCk7XHJcblx0XHRcdFx0XHRcdHRhcmdldC5jYWxlbmRhcnNQaWNrZXIoJ29wdGlvbicsIHtmaXJzdERheTogZG93fSk7XHJcblx0XHRcdFx0XHR9KS5cclxuXHRcdFx0XHRcdHJlcGxhY2VBbGwodGhpcyk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogQSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBkYXRlIGlzIGhvdmVyZWQuXHJcblx0XHRcdEBjYWxsYmFjayBDYWxlbmRhcnNQaWNrZXJPbkhvdmVyXHJcblx0XHRcdEBwYXJhbSBkYXRlIHtDRGF0ZX0gVGhlIGRhdGUgYmVpbmcgaG92ZXJlZCBvciA8Y29kZT5udWxsPC9jb2RlPiBvbiBleGl0LlxyXG5cdFx0XHRAcGFyYW0gc2VsZWN0YWJsZSB7Ym9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhpcyBkYXRlIGlzIHNlbGVjdGFibGUsIDxjb2RlPmZhbHNlPC9jb2RlPiBpZiBub3QuXHJcblx0XHRcdEBleGFtcGxlIGZ1bmN0aW9uIHNob3dIb3ZlcmVkKGRhdGUsIHNlbGVjdGFibGUpIHtcclxuXHQkKCcjZmVlZGJhY2snKS50ZXh0KCdZb3UgYXJlIHZpZXdpbmcgJyArIChkYXRlID8gZGF0ZS5mb3JtYXREYXRlKCkgOiAnbm90aGluZycpKTtcclxuIH0gKi9cclxuXHJcblx0XHQvKiogQWRkIGEgY2FsbGJhY2sgd2hlbiBob3ZlcmluZyBvdmVyIGRhdGVzLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5waWNrZXIuZXh0LmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIG9uSG92ZXIge0NhbGVuZGFyc1BpY2tlck9uSG92ZXJ9IFRoZSBjYWxsYmFjayB3aGVuIGhvdmVyaW5nLlxyXG5cdFx0XHRAZXhhbXBsZSBvblNob3c6ICQuY2FsZW5kYXJzUGlja2VyLmhvdmVyQ2FsbGJhY2soc2hvd0hvdmVyZWQpICovXHJcblx0XHRob3ZlckNhbGxiYWNrOiBmdW5jdGlvbihvbkhvdmVyKSB7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbihwaWNrZXIsIGNhbGVuZGFyLCBpbnN0KSB7XHJcblx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbihvbkhvdmVyKSkge1xyXG5cdFx0XHRcdFx0dmFyIHRhcmdldCA9IHRoaXM7XHJcblx0XHRcdFx0XHR2YXIgcmVuZGVyZXIgPSBpbnN0Lm9wdGlvbnMucmVuZGVyZXI7XHJcblx0XHRcdFx0XHRwaWNrZXIuZmluZChyZW5kZXJlci5kYXlTZWxlY3RvciArICcgYSwgJyArIHJlbmRlcmVyLmRheVNlbGVjdG9yICsgJyBzcGFuJykuXHJcblx0XHRcdFx0XHRcdGhvdmVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRcdG9uSG92ZXIuYXBwbHkodGFyZ2V0LCBbJCh0YXJnZXQpLmNhbGVuZGFyc1BpY2tlcigncmV0cmlldmVEYXRlJywgdGhpcyksXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJ10pO1xyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHRmdW5jdGlvbigpIHsgb25Ib3Zlci5hcHBseSh0YXJnZXQsIFtdKTsgfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogSGlnaGxpZ2h0IHRoZSBlbnRpcmUgd2VlayB3aGVuIGhvdmVyaW5nIG92ZXIgaXQuXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBpY2tlci5leHQuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gcGlja2VyIHtqUXVlcnl9IFRoZSBjb21wbGV0ZWQgZGF0ZXBpY2tlciBkaXZpc2lvbi5cclxuXHRcdFx0QHBhcmFtIGNhbGVuZGFyIHtCYXNlQ2FsZW5kYXJ9IFRoZSBjYWxlbmRhciBpbXBsZW1lbnRhdGlvbi5cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBleGFtcGxlIG9uU2hvdzogJC5jYWxlbmRhcnNQaWNrZXIuaGlnaGxpZ2h0V2VlayAqL1xyXG5cdFx0aGlnaGxpZ2h0V2VlazogZnVuY3Rpb24ocGlja2VyLCBjYWxlbmRhciwgaW5zdCkge1xyXG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGhpcztcclxuXHRcdFx0dmFyIHJlbmRlcmVyID0gaW5zdC5vcHRpb25zLnJlbmRlcmVyO1xyXG5cdFx0XHRwaWNrZXIuZmluZChyZW5kZXJlci5kYXlTZWxlY3RvciArICcgYSwgJyArIHJlbmRlcmVyLmRheVNlbGVjdG9yICsgJyBzcGFuJykuXHJcblx0XHRcdFx0aG92ZXIoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQkKHRoaXMpLnBhcmVudHMoJ3RyJykuZmluZChyZW5kZXJlci5kYXlTZWxlY3RvciArICcgKicpLlxyXG5cdFx0XHRcdFx0XHRhZGRDbGFzcyhyZW5kZXJlci5oaWdobGlnaHRlZENsYXNzKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0JCh0aGlzKS5wYXJlbnRzKCd0cicpLmZpbmQocmVuZGVyZXIuZGF5U2VsZWN0b3IgKyAnIConKS5cclxuXHRcdFx0XHRcdFx0cmVtb3ZlQ2xhc3MocmVuZGVyZXIuaGlnaGxpZ2h0ZWRDbGFzcyk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBTaG93IGEgc3RhdHVzIGJhciB3aXRoIG1lc3NhZ2VzLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5waWNrZXIuZXh0LmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIHBpY2tlciB7alF1ZXJ5fSBUaGUgY29tcGxldGVkIGRhdGVwaWNrZXIgZGl2aXNpb24uXHJcblx0XHRcdEBwYXJhbSBjYWxlbmRhciB7QmFzZUNhbGVuZGFyfSBUaGUgY2FsZW5kYXIgaW1wbGVtZW50YXRpb24uXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAZXhhbXBsZSBvblNob3c6ICQuY2FsZW5kYXJzUGlja2VyLnNob3dTdGF0dXMgKi9cclxuXHRcdHNob3dTdGF0dXM6IGZ1bmN0aW9uKHBpY2tlciwgY2FsZW5kYXIsIGluc3QpIHtcclxuXHRcdFx0dmFyIGlzVFIgPSAoaW5zdC5vcHRpb25zLnJlbmRlcmVyLnNlbGVjdGVkQ2xhc3MgPT09ICd1aS1zdGF0ZS1hY3RpdmUnKTtcclxuXHRcdFx0dmFyIGRlZmF1bHRTdGF0dXMgPSBpbnN0Lm9wdGlvbnMuZGVmYXVsdFN0YXR1cyB8fCAnJiMxNjA7JztcclxuXHRcdFx0dmFyIHN0YXR1cyA9ICQoJzxkaXYgY2xhc3M9XCInICsgKCFpc1RSID8gJ2NhbGVuZGFycy1zdGF0dXMnIDpcclxuXHRcdFx0XHQndWktZGF0ZXBpY2tlci1zdGF0dXMgdWktd2lkZ2V0LWhlYWRlciB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbCcpICsgJ1wiPicgK1xyXG5cdFx0XHRcdGRlZmF1bHRTdGF0dXMgKyAnPC9kaXY+JykuXHJcblx0XHRcdFx0aW5zZXJ0QWZ0ZXIocGlja2VyLmZpbmQoJy5jYWxlbmRhcnMtbW9udGgtcm93Omxhc3QsLnVpLWRhdGVwaWNrZXItcm93LWJyZWFrOmxhc3QnKSk7XHJcblx0XHRcdHBpY2tlci5maW5kKCcqW3RpdGxlXScpLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgdGl0bGUgPSAkKHRoaXMpLmF0dHIoJ3RpdGxlJyk7XHJcblx0XHRcdFx0XHQkKHRoaXMpLnJlbW92ZUF0dHIoJ3RpdGxlJykuaG92ZXIoXHJcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkgeyBzdGF0dXMudGV4dCh0aXRsZSB8fCBkZWZhdWx0U3RhdHVzKTsgfSxcclxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7IHN0YXR1cy50ZXh0KGRlZmF1bHRTdGF0dXMpOyB9KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIEFsbG93IGVhc2llciBuYXZpZ2F0aW9uIGJ5IG1vbnRoLlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5waWNrZXIuZXh0LmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIHBpY2tlciB7alF1ZXJ5fSBUaGUgY29tcGxldGVkIGRhdGVwaWNrZXIgZGl2aXNpb24uXHJcblx0XHRcdEBwYXJhbSBjYWxlbmRhciB7QmFzZUNhbGVuZGFyfSBUaGUgY2FsZW5kYXIgaW1wbGVtZW50YXRpb24uXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAZXhhbXBsZSBvblNob3c6ICQuY2FsZW5kYXJzUGlja2VyLm1vbnRoTmF2aWdhdGlvbiAqL1xyXG5cdFx0bW9udGhOYXZpZ2F0aW9uOiBmdW5jdGlvbihwaWNrZXIsIGNhbGVuZGFyLCBpbnN0KSB7XHJcblx0XHRcdHZhciB0YXJnZXQgPSAkKHRoaXMpO1xyXG5cdFx0XHR2YXIgaXNUUiA9IChpbnN0Lm9wdGlvbnMucmVuZGVyZXIuc2VsZWN0ZWRDbGFzcyA9PT0gJ3VpLXN0YXRlLWFjdGl2ZScpO1xyXG5cdFx0XHR2YXIgbWluRGF0ZSA9IGluc3QuY3VyTWluRGF0ZSgpO1xyXG5cdFx0XHR2YXIgbWF4RGF0ZSA9IGluc3QuZ2V0KCdtYXhEYXRlJyk7XHJcblx0XHRcdHZhciB5ZWFyID0gaW5zdC5kcmF3RGF0ZS55ZWFyKCk7XHJcblx0XHRcdHZhciBodG1sID0gJzxkaXYgY2xhc3M9XCInICsgKCFpc1RSID8gJ2NhbGVuZGFycy1tb250aC1uYXYnIDogJ3VpLWRhdGVwaWNrZXItbW9udGgtbmF2JykgKyAnXCI+JztcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYWxlbmRhci5tb250aHNJblllYXIoeWVhcik7IGkrKykge1xyXG5cdFx0XHRcdHZhciBvcmQgPSBjYWxlbmRhci5mcm9tTW9udGhPZlllYXIoeWVhciwgaSArIGNhbGVuZGFyLm1pbk1vbnRoKSAtIGNhbGVuZGFyLm1pbk1vbnRoO1xyXG5cdFx0XHRcdHZhciBpblJhbmdlID0gKCghbWluRGF0ZSB8fCBjYWxlbmRhci5uZXdEYXRlKHllYXIsIGkgKyBjYWxlbmRhci5taW5Nb250aCxcclxuXHRcdFx0XHRcdGNhbGVuZGFyLmRheXNJbk1vbnRoKHllYXIsIGkgKyBjYWxlbmRhci5taW5Nb250aCkpLmNvbXBhcmVUbyhtaW5EYXRlKSA+IC0xKSAmJiAoIW1heERhdGUgfHxcclxuXHRcdFx0XHRcdGNhbGVuZGFyLm5ld0RhdGUoeWVhciwgaSArIGNhbGVuZGFyLm1pbk1vbnRoLCBjYWxlbmRhci5taW5EYXkpLmNvbXBhcmVUbyhtYXhEYXRlKSA8ICsxKSk7XHJcblx0XHRcdFx0aHRtbCArPSAnPGRpdj4nICsgKGluUmFuZ2UgPyAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cImpkJyArXHJcblx0XHRcdFx0XHRjYWxlbmRhci5uZXdEYXRlKHllYXIsIGkgKyBjYWxlbmRhci5taW5Nb250aCwgY2FsZW5kYXIubWluRGF5KS50b0pEKCkgKyAnXCInIDogJzxzcGFuJykgK1xyXG5cdFx0XHRcdFx0JyB0aXRsZT1cIicgKyBjYWxlbmRhci5sb2NhbC5tb250aE5hbWVzW29yZF0gKyAnXCI+JyArIGNhbGVuZGFyLmxvY2FsLm1vbnRoTmFtZXNTaG9ydFtvcmRdICtcclxuXHRcdFx0XHRcdChpblJhbmdlID8gJzwvYT4nIDogJzwvc3Bhbj4nKSArICc8L2Rpdj4nO1xyXG5cdFx0XHR9XHJcblx0XHRcdGh0bWwgKz0gJzwvZGl2Pic7XHJcblx0XHRcdCQoaHRtbCkuaW5zZXJ0QWZ0ZXIocGlja2VyLmZpbmQoJ2Rpdi5jYWxlbmRhcnMtbmF2LGRpdi51aS1kYXRlcGlja2VyLWhlYWRlcjpmaXJzdCcpKS5cclxuXHRcdFx0XHRmaW5kKCdhJykuY2xpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgZGF0ZSA9IHRhcmdldC5jYWxlbmRhcnNQaWNrZXIoJ3JldHJpZXZlRGF0ZScsIHRoaXMpO1xyXG5cdFx0XHRcdFx0dGFyZ2V0LmNhbGVuZGFyc1BpY2tlcignc2hvd01vbnRoJywgZGF0ZS55ZWFyKCksIGRhdGUubW9udGgoKSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKiBTZWxlY3QgYW4gZW50aXJlIHdlZWsgd2hlbiBjbGlja2luZyBvbiBhIHdlZWsgbnVtYmVyLlxyXG5cdFx0XHRVc2UgaW4gY29uanVuY3Rpb24gd2l0aCA8Y29kZT53ZWVrT2ZZZWFyUmVuZGVyZXI8L2NvZGU+LlxyXG5cdFx0XHRGb3VuZCBpbiB0aGUgPGNvZGU+anF1ZXJ5LmNhbGVuZGFycy5waWNrZXIuZXh0LmpzPC9jb2RlPiBtb2R1bGUuXHJcblx0XHRcdEBtZW1iZXJvZiBDYWxlbmRhcnNQaWNrZXJcclxuXHRcdFx0QHBhcmFtIHBpY2tlciB7alF1ZXJ5fSBUaGUgY29tcGxldGVkIGRhdGVwaWNrZXIgZGl2aXNpb24uXHJcblx0XHRcdEBwYXJhbSBjYWxlbmRhciB7QmFzZUNhbGVuZGFyfSBUaGUgY2FsZW5kYXIgaW1wbGVtZW50YXRpb24uXHJcblx0XHRcdEBwYXJhbSBpbnN0IHtvYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIHNldHRpbmdzLlxyXG5cdFx0XHRAZXhhbXBsZSBvblNob3c6ICQuY2FsZW5kYXJzUGlja2VyLnNlbGVjdFdlZWsgKi9cclxuXHRcdHNlbGVjdFdlZWs6IGZ1bmN0aW9uKHBpY2tlciwgY2FsZW5kYXIsIGluc3QpIHtcclxuXHRcdFx0dmFyIHRhcmdldCA9ICQodGhpcyk7XHJcblx0XHRcdHBpY2tlci5maW5kKCd0ZC5jYWxlbmRhcnMtd2VlayBzcGFuJykuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQkKCc8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgY2xhc3M9XCInICtcclxuXHRcdFx0XHRcdFx0dGhpcy5jbGFzc05hbWUgKyAnXCIgdGl0bGU9XCJTZWxlY3QgdGhlIGVudGlyZSB3ZWVrXCI+JyArXHJcblx0XHRcdFx0XHRcdCQodGhpcykudGV4dCgpICsgJzwvYT4nKS5cclxuXHRcdFx0XHRcdGNsaWNrKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgZGF0ZSA9IHRhcmdldC5jYWxlbmRhcnNQaWNrZXIoJ3JldHJpZXZlRGF0ZScsIHRoaXMpO1xyXG5cdFx0XHRcdFx0XHR2YXIgZGF0ZXMgPSBbZGF0ZV07XHJcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgY2FsZW5kYXIuZGF5c0luV2VlaygpOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRkYXRlcy5wdXNoKGRhdGUgPSBkYXRlLm5ld0RhdGUoKS5hZGQoMSwgJ2QnKSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYgKGluc3Qub3B0aW9ucy5yYW5nZVNlbGVjdCkge1xyXG5cdFx0XHRcdFx0XHRcdGRhdGVzLnNwbGljZSgxLCBkYXRlcy5sZW5ndGggLSAyKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR0YXJnZXQuY2FsZW5kYXJzUGlja2VyKCdzZXREYXRlJywgZGF0ZXMpLmNhbGVuZGFyc1BpY2tlcignaGlkZScpO1xyXG5cdFx0XHRcdFx0fSkuXHJcblx0XHRcdFx0XHRyZXBsYWNlQWxsKHRoaXMpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqIFNlbGVjdCBhbiBlbnRpcmUgbW9udGggd2hlbiBjbGlja2luZyBvbiB0aGUgd2VlayBoZWFkZXIuXHJcblx0XHRcdFVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIDxjb2RlPndlZWtPZlllYXJSZW5kZXJlcjwvY29kZT4uXHJcblx0XHRcdEZvdW5kIGluIHRoZSA8Y29kZT5qcXVlcnkuY2FsZW5kYXJzLnBpY2tlci5leHQuanM8L2NvZGU+IG1vZHVsZS5cclxuXHRcdFx0QG1lbWJlcm9mIENhbGVuZGFyc1BpY2tlclxyXG5cdFx0XHRAcGFyYW0gcGlja2VyIHtqUXVlcnl9IFRoZSBjb21wbGV0ZWQgZGF0ZXBpY2tlciBkaXZpc2lvbi5cclxuXHRcdFx0QHBhcmFtIGNhbGVuZGFyIHtCYXNlQ2FsZW5kYXJ9IFRoZSBjYWxlbmRhciBpbXBsZW1lbnRhdGlvbi5cclxuXHRcdFx0QHBhcmFtIGluc3Qge29iamVjdH0gVGhlIGN1cnJlbnQgaW5zdGFuY2Ugc2V0dGluZ3MuXHJcblx0XHRcdEBleGFtcGxlIG9uU2hvdzogJC5jYWxlbmRhcnNQaWNrZXIuc2VsZWN0TW9udGggKi9cclxuXHRcdHNlbGVjdE1vbnRoOiBmdW5jdGlvbihwaWNrZXIsIGNhbGVuZGFyLCBpbnN0KSB7XHJcblx0XHRcdHZhciB0YXJnZXQgPSAkKHRoaXMpO1xyXG5cdFx0XHRwaWNrZXIuZmluZCgndGguY2FsZW5kYXJzLXdlZWsnKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCQoJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiB0aXRsZT1cIlNlbGVjdCB0aGUgZW50aXJlIG1vbnRoXCI+JyArXHJcblx0XHRcdFx0XHRcdCQodGhpcykudGV4dCgpICsgJzwvYT4nKS5cclxuXHRcdFx0XHRcdGNsaWNrKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgZGF0ZSA9IHRhcmdldC5jYWxlbmRhcnNQaWNrZXIoJ3JldHJpZXZlRGF0ZScsICQodGhpcykucGFyZW50cygndGFibGUnKS5cclxuXHRcdFx0XHRcdFx0XHRmaW5kKCd0ZDpub3QoLmNhbGVuZGFycy13ZWVrKSAqOm5vdCguY2FsZW5kYXJzLW90aGVyLW1vbnRoKScpWzBdKTtcclxuXHRcdFx0XHRcdFx0dmFyIGRhdGVzID0gW2RhdGUuZGF5KDEpXTtcclxuXHRcdFx0XHRcdFx0dmFyIGRpbSA9IGNhbGVuZGFyLmRheXNJbk1vbnRoKGRhdGUpO1xyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGRpbTsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0ZGF0ZXMucHVzaChkYXRlID0gZGF0ZS5uZXdEYXRlKCkuYWRkKDEsICdkJykpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmIChpbnN0Lm9wdGlvbnMucmFuZ2VTZWxlY3QpIHtcclxuXHRcdFx0XHRcdFx0XHRkYXRlcy5zcGxpY2UoMSwgZGF0ZXMubGVuZ3RoIC0gMik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0dGFyZ2V0LmNhbGVuZGFyc1BpY2tlcignc2V0RGF0ZScsIGRhdGVzKS5jYWxlbmRhcnNQaWNrZXIoJ2hpZGUnKTtcclxuXHRcdFx0XHRcdH0pLlxyXG5cdFx0XHRcdFx0YXBwZW5kVG8odGhpcyk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKiogU2VsZWN0IGEgbW9udGggb25seSBpbnN0ZWFkIG9mIGEgc2luZ2xlIGRheS5cclxuXHRcdFx0Rm91bmQgaW4gdGhlIDxjb2RlPmpxdWVyeS5jYWxlbmRhcnMucGlja2VyLmV4dC5qczwvY29kZT4gbW9kdWxlLlxyXG5cdFx0XHRAbWVtYmVyb2YgQ2FsZW5kYXJzUGlja2VyXHJcblx0XHRcdEBwYXJhbSBwaWNrZXIge2pRdWVyeX0gVGhlIGNvbXBsZXRlZCBkYXRlcGlja2VyIGRpdmlzaW9uLlxyXG5cdFx0XHRAcGFyYW0gY2FsZW5kYXIge0Jhc2VDYWxlbmRhcn0gVGhlIGNhbGVuZGFyIGltcGxlbWVudGF0aW9uLlxyXG5cdFx0XHRAcGFyYW0gaW5zdCB7b2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBzZXR0aW5ncy5cclxuXHRcdFx0QGV4YW1wbGUgb25TaG93OiAkLmNhbGVuZGFyc1BpY2tlci5tb250aE9ubHkgKi9cclxuXHRcdG1vbnRoT25seTogZnVuY3Rpb24ocGlja2VyLCBjYWxlbmRhciwgaW5zdCkge1xyXG5cdFx0XHR2YXIgdGFyZ2V0ID0gJCh0aGlzKTtcclxuXHRcdFx0dmFyIHNlbGVjdE1vbnRoID0gJCgnPGRpdiBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlcjtcIj48YnV0dG9uIHR5cGU9XCJidXR0b25cIj5TZWxlY3Q8L2J1dHRvbj48L2Rpdj4nKS5cclxuXHRcdFx0XHRpbnNlcnRBZnRlcihwaWNrZXIuZmluZCgnLmNhbGVuZGFycy1tb250aC1yb3c6bGFzdCwudWktZGF0ZXBpY2tlci1yb3ctYnJlYWs6bGFzdCcpKS5cclxuXHRcdFx0XHRjaGlsZHJlbigpLmNsaWNrKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dmFyIG1vbnRoWWVhciA9IHBpY2tlci5maW5kKCcuY2FsZW5kYXJzLW1vbnRoLXllYXI6Zmlyc3QnKS52YWwoKS5zcGxpdCgnLycpO1xyXG5cdFx0XHRcdFx0dGFyZ2V0LmNhbGVuZGFyc1BpY2tlcignc2V0RGF0ZScsIGNhbGVuZGFyLm5ld0RhdGUoXHJcblx0XHRcdFx0XHRcdHBhcnNlSW50KG1vbnRoWWVhclsxXSwgMTApLCBwYXJzZUludChtb250aFllYXJbMF0sIDEwKSwgY2FsZW5kYXIubWluRGF5KSkuXHJcblx0XHRcdFx0XHRcdGNhbGVuZGFyc1BpY2tlcignaGlkZScpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRwaWNrZXIuZmluZCgnLmNhbGVuZGFycy1tb250aC1yb3cgdGFibGUsLnVpLWRhdGVwaWNrZXItcm93LWJyZWFrIHRhYmxlJykucmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG59KShqUXVlcnkpO1xyXG4iXX0=
